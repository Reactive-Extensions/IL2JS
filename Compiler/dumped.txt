#if false
        public override Ast.Expression TransformStringLiteral(Ast.StringLiteral stringLiteral) {
            if (container != null) {
                var c = default(int);
                if (dict.TryGetValue(stringLiteral.Value, out c)) {
                    var asLitSize = c * stringLiteral.Value.Length;
                    var asVarSize = c * 2 + stringLiteral.Value.Length + 7;
                    if (asVarSize < asLitSize) {
                        var identifier = container.StringCache.For(stringLiteral.Value);
                        identifier.SourceLocation = stringLiteral.SourceLocation;
                        identifier.Comment = stringLiteral.Comment;
                        return new Ast.IdentifierExpression() {
                            SourceLocation = stringLiteral.SourceLocation,
                            Comment = stringLiteral.Comment,
                            Identifier = identifier
                        };
                    }
                }
            }
            return stringLiteral;
        }
#endif





        // Return expression representing the value at the top of the current CLR stack. Assume the value may be ignored, duplicated, 
        // or evaluated outside of bottom-to-top stack order.
        public Ast.Expression Pop(List<Ast.Statement> statements) {
            var n = staticStack.Count - 1;
            if (n >= 0) {
                EvalStackPrefix(statements, 0);
                var exp = staticStack[n].Exp;
                staticStack.RemoveAt(n);
                return exp;
            }
            else {
#if DEBUG_COMPILER
                if (!needRuntimeStack)
                    statements.Add(new Ast.ExpressionStatement(Ast.StringLiteral.FromDotNet("Pop")));
#endif
                needRuntimeStack = true;
                var id = GenSym();
                var pop = Ast.CallExpression.FunctionCall(Ast.CallExpression.Property(new Ast.Identifier("stack"), new Ast.Identifier("pop")));
                statements.Add(new Ast.VariableStatement(id, pop));
                return new Ast.IdentifierExpression(id);
            }
        }


        private static int NumberOfMembers<T>(Class classType) where T : Member
        {
            if (classType == null)
                return 0;
            else
            {
                var n = NumberOfMembers<T>(classType.BaseClass);
                foreach (var m in classType.Members)
                {
                    if (m is T) n++;
                }
                return n;
            }
        }

        private static int IndexOfMember<T>(Class classType, Func<T, string> getName, T member) where T : Member
        {
            var n = NumberOfMembers<T>(classType.BaseClass);
            var nms = new List<string>();
            foreach (var m in classType.Members)
            {
                var t = m as T;
                if (t != null)
                    nms.Add(getName(t));
            }
            list.Sort();
            var memnm = getName(member);
            foreach (var nm in nms)
            {
                if (nm == memnm)
                    return n;
                else
                    n++;
            }
            throw new InvalidOperationException("Cannot find member in declaring type");
        }




// TODO: move into type
function Constrained(obj, typedef)
{
    if (IsValueType(typedef)) {
        if (IsPointer(obj))
            return obj;
        else {
            debugger; // TODO
            return { _read : function () { return obj; },
                     _write :  function (v) { throw NewException("System.NotSupportedException"); }, 
                     _objectId : NextObjectId(),
                     _t : typedef };
        }
    }
    else {
        if (IsPointer(obj))
            return obj._read();
        else
            return obj;
    }
}

// TODO: nuke
function NullIfRefType(obj)
{
    if (obj === undefined || obj === null || IsValueType(obj._t))
        return obj;
    else
        return null;
}

/*
function OneLevelClone(oldobj)
{
    if (typeof(oldobj) == "number" || typeof(oldobj) == "boolean")
        return oldobj;
    else {
        var newobj = {};
        InheritProperties(newobj, oldobj);
        return newobj;
    }
}

function OneLevelCloneForStruct(oldobj, typedef)
{
    if (oldobj === undefined || oldobj === null || !IsValueType(typedef))
        return oldobj;
    else
        return OneLevelClone(oldobj);
}
*/



        private class ScopedIdentifier {
            public S scope;
            public I id;

            public override bool Equals(object obj)
            {
                var si = obj as ScopedIdentifier;
                if (si == null)
                    return false;
                else
                    return scope.Equals(si.scope) && id.Equals(si.id);
            }

            public override int GetHashCode()
            {
                return scope.GetHashCode()*37 ^ id.GetHashCode()*17;
            }
        }



        private class QualifiedTypeName
        {
            // Full assembly name (including version, etc)
            public string assemblyName;
            // Full type name (including namespace qualification)
            public string typeName;

            public override bool Equals(object obj)
            {
                var qtn = obj as QualifiedTypeName;
                if (qtn == null)
                    return false;
                else
                    return assemblyName == qtn.assemblyName && typeName == qtn.typeName;
            }

            public override int GetHashCode()
            {
                return assemblyName.GetHashCode() * 13 ^ typeName.GetHashCode() * 7;
            }
        }
           

        private static Ast.Expression CreateRuntimeError(string error)
        {
            return new Ast.CallExpression
                   {
                       Expression = new Ast.IdentifierExpression {Identifier = new Ast.Identifier("CreateError")},
                       Accessor = new Ast.Call {Arguments = new List<Ast.Expression>() {stringBindings.FromString(error)}}
                   };
        }

        private static Ast.Expression CreateRuntimeFieldLoadError(string error)
        {
            // When the created expression is used on the LHS, javascript error "cannot assign to function" is
            // given if only the CallRuntimeError expression (which is a function call) is used. So
            // instead return an extra "Dummy" field access, so that this expression can be safely
            // used both on the LHS and RHS.
            return Ast.CallExpression.Property(CreateRuntimeError(error), new Ast.Identifier("Dummy"));
        }



//     FieldMap : object                          (* Map from full field names (both static and instance) visible at instances of this type to internal field names
//                                                   (suitable for lookup in actual fields of type instance). Eg from
//                                                       "[WindowsBase, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]System.Windows.DependencyProperty [PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]System.Windows.Controls.Button::IsCancelProperty"
//                                                   to "fxmb" *)
//     MethodMap : object                         (* Map from full method names visible at instances of this type
//                                                   (mangled to include signature) to internal method names (suitable for lookup in actual methods of type instance). Eg from
//                                                       "[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Void [PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]System.Windows.Controls.ComboBox::OnKeyDown([PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]System.Windows.Input.KeyEventArgs)"
//                                                   to "my3o" *)

//     FieldMap : object                          (* Map from full field names visible at this type to internal method names (suitable for lookup in actual fields below) *)
//     MethodMap : object                         (* Map from full method names visible at this type (mangled to include signature) to internal method names (suitable for lookup in actual methods below) *)


// Resolve the method with name declared in type with given argument and result types to the corresponding mangled name, ready to be used
// as field name on (a possibly different) type. This is needed only to invoke a .Net method from JavaScript, compiled code invokes methods directly.
// Type cannot be an instance of a higher-kinded type.
function ResolveMethodName(declaringType, methodName, signature) {
    var method = type.MethodMap[FullMethodName(declaringType, methodName, signature)];
    if (method === undefined) {
        if (confirm("Failed to find method '" + methodName + "'\nWould you like to debug?"))
            debugger;
        return null;
    }
    else
        return method;
}

// As above, but for fields (static or instance)
function ResolveFieldName(declaringType, fieldName, fieldType) {
    var field = type.FieldMap[FullFieldName(declaringType, fieldName, fieldType)];
    if (field === undefined) {
        if (confirm("Failed to find field '" + fieldName + "'\nWould you like to debug?"))
            debugger;
        return null;
    }
    else
        return field;
}


// Return fully qualified name of method in type with signature types and return type. Eg:
//     "[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Void [PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]System.Windows.Controls.ComboBox::OnKeyDown([PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]System.Windows.Input.KeyEventArgs)"
function FullMethodName(declaringType, methodName, signature) {
    var sb = [];
    // Last element of signature is return type
    sb.push(FullTypeName(signature[signature.length - 1]), " ", FullTypeName(declaringType), "::", methodName, "(");
    for (var i = 0; i < signature.length - 1; i++) {
        if (i > 0)
            sb.push(",");
        sb.push(FullTypeName(signature[i]));
    }
    sb.push(")");
    return sb.join("");
}

// As above, but for field names. Eg:
//     "[WindowsBase, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]System.Windows.DependencyProperty [PresentationFramework, Version=3.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35]System.Windows.Controls.Button::IsCancelProperty"
function FullFieldName(declaringType, fieldName, fieldType) {
    return [FullTypeName(fieldType), " ", FullTypeName(declaringType), "::", fieldName].join(""); 
}



        // Make sure the stack is empty when leaving a guarded block
        public void EndOfGuardedBlock(List<Ast.Statement> statements)
        {
            if (staticStack.Count != 0)
                throw new InvalidOperationException("StackManager: Stack should be empty before leaving a guarded block");
            if (stackId != null)
                // Make sure the run-time stack is flushed
                statements.Add(new Ast.ExpressionStatement(Ast.BinaryExpression.Assignment(new Ast.IdentifierExpression(stackId), new Ast.ArrayLiteral())));
        }



            var typeArguments = default(Ast.ArrayLiteral);
            foreach (var id in m_typeBindings.BoundTypeParameters)
            {
                if (typeArguments == null)
                    typeArguments = new Ast.ArrayLiteral();
                typeArguments.Elements.Add(id);
            }
            if (typeArguments != null)
                BindTypeField(Constants.TypeArguments, typeArguments);





//
// The SHA-1 hash algorithm, without block padding).
// NOTE: Used only to compress global identifiers, has no relevance to security.
// mshields@microsoft.com
//

namespace Microsoft.LiveLabs.Volta
{

    public static class SHA1
    {
        public struct Hash
        {
            public uint H0;
            public uint H1;
            public uint H2;
            public uint H3;
            public uint H4;
        }

        public const int BlockLength = 16;

        public class Block
        {
            public uint[] Body;
            public Block()
            {
                Body = new uint[BlockLength];
            }
        }

        public static readonly Hash InitHash = new Hash() {
            H0 = 0x67452301u,
            H1 = 0xEFCDAB89u,
            H2 = 0x98BADCFEu,
            H3 = 0x10325476u,
            H4 = 0xC3D2E1F0u
        };

        private static uint RotL1(uint v) { return v << 1 | v >> 31; }
        private static uint RotL5(uint v) { return v << 5 | v >> 27; }
        private static uint RotL30(uint v) { return v << 30 | v >> 2; }

        public static void HashInPlace(ref Hash hash, Block block)
        {
            var w = new uint[80];

            for (var i = 0; i < BlockLength; i++)
                w[i] = block.Body[i];
            for (var i = BlockLength; i < 80; i++)
                w[i] = RotL1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);

            var a = hash.H0;
            var b = hash.H1;
            var c = hash.H2;
            var d = hash.H3;
            var e = hash.H4;

            for (var i = 0; i < 20; i++)
            {
                var f = (b & c) | ((~b) & d);
                var k = 0x5A827999u;
                var t = RotL5(a) + f + e + k + w[i];
                e = d;
                d = c;
                c = RotL30(b);
                b = a;
                a = t;
            }
            for (var i = 20; i < 40; i++)
            {
                var f = b ^ c ^ d;
                var k = 0x6ED9EBA1u;
                var t = RotL5(a) + f + e + k + w[i];
                e = d;
                d = c;
                c = RotL30(b);
                b = a;
                a = t;
            }
            for (var i = 40; i < 60; i++)
            {
                var f = (b & c) | (b & d) | (c & d);
                var k = 0x8F1BBCDCu;
                var t = RotL5(a) + f + e + k + w[i];
                e = d;
                d = c;
                c = RotL30(b);
                b = a;
                a = t;
            }
            for (var i = 60; i < 80; i++)
            {
                var f = b ^ c ^ d;
                var k = 0xCA62C1D6u;
                var t = RotL5(a) + f + e + k + w[i];
                e = d;
                d = c;
                c = RotL30(b);
                b = a;
                a = t;
            }

            hash.H0 += a;
            hash.H1 += b;
            hash.H2 += c;
            hash.H3 += d;
            hash.H4 += e;
        }
    }

}



       public void Dispose()
        {
            if (boundInThisScope == null)
                throw new InvalidOperationException("supply has been disposed");
#if false
            if (boundInChildScope.Count != 0)
                throw new InvalidOperationException("child scope has not been disposed");
            if (parent != null)
            {
                foreach (var nm in boundInThisScope)
                    parent.UnboundByChild(nm);
#endif
            }
            boundInChildScope = null;
            parent = null;
            prefix = null;
        }
 

        private void UnboundByChild(string nm)
        {
            var i = default(int);
            if (boundInChildScope.TryGetValue(nm, out i))
            {
                if (i == 1)
                    boundInChildScope.Remove(nm);
                else
                    boundInChildScope[nm] = i - 1;
            }
            else
                throw new InvalidOperationException("name is not bound by child");
            if (parent != null)
                parent.UnboundByChild(nm);
        }



function DynamicGetInstanceField(declType, fieldName, instance) {
    return instance[declType.NameToSlot[fieldName]];
}

function DynamicSetInstanceField(declType, fieldName, instance, value) {
    instance[declType.NameToSlot[fieldName]] = value;
}

function DynamicGetStaticField(declType, fieldName) {
    return declType[declType.NameToSlot[fieldName]];
}

function DynamicSetStaticField(declType, fieldName, value) {
    declType[declType.NameToSlot[fieldName]] = value;
}

function TypeHasMember(declType, simpleMemberName) {
    return declType.SimpleToFullName[simpleMemberName] !== undefined;
}

function TypeHasUniqueMember(declType, simpleMemberName) {
    return declType.SimpleToFullName[simpleMemberName] != null;
}

function ResolveSimpleMemberName(declType, simpleMemberName) {
    var name = declType.SimpleToFullName[simpleMemberName];
    if (name === undefined)
        return null;
    else
        return name;
}


        [Import("TypeHasMember")]
        extern private static bool TypeHasMember(Type declType, string simpleMemberName);

        [Import("TypeHasUniqueMember")]
        extern private static bool TypeHasUniqueMember(Type declType, string simpleMemberName);

        [Import("ResolveSimpleMemberName")]
        extern private static string ResolveSimpleMemberName(Type declType, string simpleMemberName);

        [Import("DynamicGetInstanceField")]
        extern private object DynamicGetInstanceField(Type declType, string fieldName, object instance);

        [Import("DynamicSetInstanceField")]
        extern private void DynamicSetInstanceField(Type declType, string fieldName, object instance, object value);






//
// The .Net JavaScript runtime system
//

//
// Names
// ~~~~~
//
//  - File Name:
//        Any name understood by the underlying file system.
//  - Assembly Name:
//        The strong assembly name, which includes version, culture and public key token. Eg:
//            "mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e"
//        Unique over all assemblies.
//  - Type Name:
//        Name of type, not including assembly, but including namespace and type nesting, and
//        possibly including type application argument names.
//         - Eg: If ordinary first-kinded type:
//               "System.Collections.IList"
//         - Eg: If higher-kinded type:
//               "System.Collections.Generic.List`1"
//         - Eg: If type application of higher-kinded type to first-kinded type arguments:
//               "System.Collections.Generic.List`1<[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Int32>"
//           (Note that type argument names are qualified type names).
//         - Eg: If built-in array type constructor:
//               "[]"
//           (Note only rank-1 arrays are supported)
//         - Eg: If built-in application of array type constructor to first-kinded type argument:
//               "[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Int32[]"
//       Unique over all types in same assembly.
//  - Qualified type name:
//       Type name prefixed by assembly name. Eg:
//           "[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Int"
//       Built-in array types live in the "ambient" assembly which has an empty name, and so look like:
//           "[][mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Int32[]"
//       Unique over all types in all assemblies.
//  - Simple method name:
//       What the user writes. Eg: "ToString".
//  - Method name:
//       Simple method name with its argument modifiers and types, and non-void return type (if any). All types are as qualified type names. Eg:
//           "ToString():[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.String"
//           "TryParse([mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.String,out [mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Int32):[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Boolean"
//       Constructors have name ".ctor(...)", and static constructors ".cctor(...)".
//       Unique over all members in same type.
//  - Qualified method name:
//       Method name prefixed by it's declaring type in C++ style. Type is as qualified type name. Eg:
//           "[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Int32::ToString():[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.String"
//       Unique over all members in all types in all assemblies.
//  - Simple field name:
//       What the user writes. Eg: "MinValue"
//  - Field name:
//       Simple field name with it's type and 'field' modififier. Eg:
//           "field MinValue:[mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]System.Int32"
//       Unique over all members in same type.
//  - Qualified field name:
//       As for qualified method names.
//  - Simple event name:
//       What the user writes.
//  - Event name:
//       Simple event name with it's event handler type and 'event' modifier.
//       Unique over all members in same type.
//  - Qualified event name:
//       As for qualified method names.
//  - Simple property name:
//       Whet the user writes.
//  - Property name:
//       Simple property name with it's underlying type and 'property' modifier.
//       Unique over all members in the same type.
//  - Qualified property name:
//       As for qualified method names.
//  - Simple member name:
//       A simple method, field, event or property name.
//  - Member name:
//       A method, field, event or property name. Unique over all members in same type.
//  - Qualified member name:
//       A qualified method, field, event or property name. Unique over all members in all types in all assemblies.
//  - Slot name:
//       A slot is a location in a type or instance structure who's field name is allocated by compiler:
//        - Fields have slots allocated according to static type heircharchy, and always start with 'f'.
//        - Non-interface methods have slot allocated according to static type heircharchy, and always start with 'm'.
//        - Interface methods have slot name based on the hash of the qualified method name, and always start with 'i'.
//        - Event rendevous have slots allocated according to static type heirchary, and always start with 'e'.
//        - Properties don't have slots, since they are just sugar for getter and setter methods.
//          (Indeed the only reason we care about properties in the runtime is to support the 'InvokeMember' method of
//           System.Type)
//

// ----------------------------------------------------------------------
// Global State
// ----------------------------------------------------------------------

// Map from assembly names to pre-assembly structures
var DownloadCache = {};
// Map from assembly names to assembly structures
var AssemblyCache = {};
// True if setup the runtime system
var IsSetup = false;

// Known assembly names
var PreludeName = "VoltaPrelude, Version=1.0.0.0, Culture=neutral, PublicKeyToken=03d63d4f4f89fd63";
var MSCorLibName = "mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e";
var InteropName = "VoltaInterop, Version=1.0.0.0, Culture=neutral, PublicKeyToken=03d63d4f4f89fd63";

// Cached special assembly structures
var Prelude;
var MSCorLib;
var Interop;

// The type of types. Filled in later.
var TypeType = { Id : 0 };
TypeType.T = TypeType;

// Other cached types
var ArrayType;
var NullableType;

// True if executing within a server-side host and not within a browser (heuristic...)
var OnServer = typeof window != "undefined" && typeof document != "undefined" && document.location.host != "";
// Paths to prepend to assembly names when requesting a download (if on server)
var SearchPaths;
// Path to prepend to initial jsfile request (if on server)
var PathToJSHandler = "";
// Function to load file (set by Setup depending on where we are)
var LoadCode;

// True if should invoke debugger on every exception
var $boe = false;

function SetPathToJSHandler(path) {
    PathToJSHandler = path;
}

// ----------------------------------------------------------------------
// Loading code
// ----------------------------------------------------------------------

function LoadCodeUsingExternal(fileName) {
    var code = window.external.LoadCode(fileName);
    eval(code);
    return true;
}

function LoadCodeUsingXmlHttp(fileName) {
    var xmlhttp;
    if (typeof ActiveXObject != "undefined")
        xmlhttp = new ActiveXObject("MSXML2.XMLHTTP");
    else if (typeof XMLHttpRequest != "undefined")
        xmlhttp = new XMLHttpRequest();
    else
        return false;

    try {
        xmlhttp.open("GET", fileName, false);
        xmlhttp.send(null);
    }
    catch (e) {
        return false;
    }

    if (xmlhttp.status == 200 || xmlhttp.status == 0) {
        var response = xmlhttp.responseText;
        if (response == null || response == "")
            return false;
        else {
            eval(response);
            return true;
        }
    }
    else
        return false;
}

function LoadCodeUsingSearchPath(fileName, loader) {
    if (SearchPaths == null)
        SearchPaths = ["."];

    for (var i = 0; i < SearchPaths.length; i++) {
        if (loader(SearchPaths[i] + "/" + fileName))
            return true;

        if (confirm("Failed to download '" + fileName + "'\nWould you like to debug?"))
            debugger;

        return false;
    }
}

function LoadCodeUsingScript(fileName) {
    if (SearchPaths == null)
        SearchPaths = ["."];

    var fullName = SearchPaths[0] + "/" + fileName;
    document.write("<script src=\"" + fullName + "\"></script>");
}

// ----------------------------------------------------------------------
// Setup and teardown
// ----------------------------------------------------------------------

function Setup() {
    if (!IsSetup) {
        IsSetup = true;

        // Setup the loader functions
        if (typeof voltaTestAPI != "undefined")
            LoadCode = LoadCodeUsingExternal;
        else if (OnServer)
            LoadCode = LoadCodeUsingXmlHttp;
        else
            LoadCode = function(fileName) { return LoadCodeUsingSearchPath(fileName, LoadCodeUsingXmlHttp); };

        // Cache the special assemblies
        Prelude = ResolveAssembly(PreludeName);
        MSCorLib = ResolveAssembly(MSCorLibName);
        Interop = ResolveAssembly(InteropName);

        // Cache the special types
        var loadedTypeType = ResolveType(MSCorLib, "Microsoft.LiveLabs.Volta.Reflection.VoltaType", null);
        InheritProperties(TypeType, loadedTypeType);

        ArrayType = ResolveType(MSCorLib, "System.Array", null);
        NullableType = ResolveType(MSCorLib, "System.Nullable`1", null);

        // Make the JavaScript built in types look like our types
        String.prototype.T = ResolveType(MSCorLib, "System.String", null);
        Date.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.Date", null);
        Function.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.Function", null);
        Number.prototype.T = ResolveType(MSCorLib, "System.Double", null);
        Boolean.prototype.T = ResolveType(MSCorLib, "System.Boolean", null);
        Error.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.Error", null);
        TypeError.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.TypeError", null);
        RangeError.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.RangeError", null);
        EvalError.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.EvalError", null);
        SyntaxError.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.SyntaxError", null);
        ReferenceError.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.ReferenceError", null);
        if (typeof UriError != "undefined")
            UriError.prototype.T = ResolveType(Interop, "Microsoft.LiveLabs.Volta.JavaScript.UriError", null);

        // Bootstrap
        // ResolveType(MSCorLib, "System.Type", null);

        // Bring the exported static functions into scope
        Prelude.RegisterExports();
        MSCorLib.RegisterExports();
        Interop.RegisterExports();
    }
}

function Teardown() {
    if (IsSetup) {
        IsSetup = false;
        for (var asmName in AssemblyCache) {
            var assembly = AssemblyCache[asmName];
            for (var typeName in assembly.TypeCache) {
                var type = assembly.TypeCache[typeName];
                for (var rank in type.ArrayCache) {
                    var arrType = type.ArrayCache[rank];
                    if (arrType.TypeFinalizer !== undefined)
                        arrType.TypeFinalizer();
                    delete type.ArrayCache[rank];
                }
                if (type.NullableCache != null) {
                    if (type.NullableCache.TypeFinalizer !== undefiend)
                        type.NullableCache.TypeFinalizer();
                    type.NullableCache = null;
                }
                if (type.TypeFinalizer !== undefined)
                    type.TypeFinalizer();
                delete assembly.TypeCache[typeName];
            }
            delete AssemblyCache[asmName];
        }
    }
}

// ----------------------------------------------------------------------
// Runtime type system
// ----------------------------------------------------------------------

//
// Pre-loaded assembly structure
// ~~~~~~~~~~~~~~~~~~~~~~
//
//     <is a JavaScript function () -> () which installs an assembly into the assembly cache>
//

//
// Assembly structure
// ~~~~~~~~~~~~~~~~~~
//
//     Name : string                   (* Assembly name *)
//     RegisterExports : () -> ()      (* Bind top-level exported static functions. Reset to undefined before called for first time. *)
//     TypeCache : object              (* Map from type names defined in assembly to corresponding type structures *)
//     EntryPoint : () -> ()           (* Entry point function, or undefined if assembly does not have one *)
//     TypeNameToFileName : object     (* Map from type names defined in assembly to filename containing JavaScript which,
//                                        when loaded, adds the type to the assembly structure. *)
//     <unique string name> : string   (* Shared string literals. String names begin with 's' to avoid clashing with other fields. *)
//

// Return assembly structure corresponding to assembly name
function ResolveAssembly(assemblyName) {

    Setup();

    // Have we already loaded this assembly?
    var assembly = AssemblyCache[assemblyName];
    if (assembly !== undefined)
        return assembly;
    else {
        // Have we pre-loaded this assembly?
        preAssembly = DownloadCache[assemblyName];
        if (preAssembly !== undefined) {
            // Add assembly to global cache
            preAssembly.Assembly();
            assembly = AssemblyCache[assemblyName];
            if (assembly !== undefined) {
                // Automatically register exports for pre-loaded assemblies
                RegisterExports(assemblyName);
                return assembly;
            }
            // else: fallthrough
        }
        // else: fallthrough

        // Actually load the assembly and try again
        if (OnServer)
            LoadCode(PathToJSHandler + "jsfile.aspx?a=" + encodeURIComponent(assemblyName));
        else
            LoadCode(assemblyName + "/assembly.js");
        assembly = AssemblyCache[assemblyName];
        if (assembly === undefined) {
            if (confirm("Failed to load assembly '" + assemblyName + "'\nWould you like to debug?"))
                debugger;
            AssemblyCache[assemblyName] = null;
            return null;
        }
        else
            // Non pre-loaded assemblies must have their exports registered manually
            return assembly;
    }
}

function RegisterExports(assemblyName) {
    var assembly = ResolveAssembly(assemblyName);
    if (assembly != null) {
        var re = assembly.RegisterExports;
        // Register exports at most once
        if (re !== undefined) {
            assembly.RegisterExports = undefined;
            re(); // >>> May trigger resolution of more types and assemblies <<<
        }
    }
}

//
// Higher-kinded type structure
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//     <is a JavaScript function from array of first-kinded type structures to first-kinded type structure>
//     T : object                                 (* As for object *)
//     Id : int                                   (* As for object *)
//     Assembly : assembly structure              (* Containing assembly *)
//     Name : string                              (* Type name *)
//
// First-kinded type structure (whether declared as such or constructed by type application)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//     T : object                                 (* As for object *)
//     Id : int                                   (* As for object *)
//     Assembly : assembly structure              (* Containing assembly. Undefined for array types. *)
//     Name : string                              (* Type name *)
//     Arguments : array                          (* If instance of higher-kinded type or array type, the type arguments for that type, otherwise undefined *)
//     Rank : int                                 (* If instance of array type, the array rank, otherwise undefined *)
//     TypeInitializer : () -> ()                 (* Initialize all the static fields of this type. Reset to undefined before called for first time. *)
//     TypeFinalizer : () -> ()                   (* Clear all the static fields of this type. *)
//     Parents : object                           (* Map from qualified type names to 'true' if immediate base type, 'false' if super-type but not immediate base type *)
//     ArrayCache : object                        (* Map from rank numbers to arrays over this type of that rank *)
//     NullableCache : type structure or null     (* Cached application of Nullable to this type, or null *)
//     RegisterExports : object -> ()             (* Add exported instance methods of type to given object *)
//     DynamicTypeMarshaller : object -> string   (* If type has a type marshaller: a function that given an instance, returns the qualified name of the instance's type. Otherwise: undefined *)
//     C : object -> object                       (* Clone - see below *)
//     I : type structure -> object               (* Instance initializer - see below *)
//     R : object -> object                       (* Read if value type - see below *)
//     U : object -> object                       (* Unbox if value type - see below*)
//     B : object -> object                       (* Box if value type - see below *)
//     D : () -> object                           (* Make default value - see below *)
//     O : object -> object                       (* Dereference if not value type - see below *)
//     V : bool                                   (* True if a value type - see below *)
//     NameToSlot : object                        (* Map each field and method name to corresponding slot name. (Events and properties have no slots). *)
//     PartialToFullName : object                 (* Map each method name with return type forced to be void to actual method name. *)
//     SimpleToFullName : object                  (* Map each simple member name (including events and properties) to the corresponding actual member name, or null if multiple members share the same simple name.
//     VirtualSlots : object                      (* Map each slot corresponding to a virtual method to 'true' *)
//     <static field slot> : object               (* Slot for static field. *)
//     <method slot> : function                   (* Slot for non-interface method implementation. *)
//     <interface method slot> : function         (* Slot for interface method implementation. *)
//
// Note that instance methods take "this" as explicit first argument, and do not use the "this" facility of JavaScript.
//
// Clone ('C' method in type structure)
// ~~~~~
//
// Given a JavaScript object:
//  - For ref types, return argument
//  - For numbers, boolean and string, return argument
//  - For structures, return (recursive) clone of argument
//
// Instance initializers ('I' method in type structure)
// ~~~~~~~~~~~~~~~~~~~~~
//
// Given a type, return a plain JavaScript object with all fields bound and set to appropriate default values.
// 
//  - For ref types:
//     - For Object, is equal to 'NewObject', which sets up the T and Id fields.
//     - If A derives from B then initializer for A looks like:
//          function (type) {
//              var obj = type_for_B.I(type);
//              obj.field_of_A = ...;
//              ...
//              return obj;
//          }
//     - Delegates and Arrays initialize as for Object, since we piggy-back on JavaScript classes for these.
//     - Strings initialize as the empty JavaScript string
//  - For value types:
//     - For numbers and enums:
//          These will be initialized in-place. Only locations of generic type must defer to the initializer function, which looks like:
//             function (type) {
//                 return ...A's default value ...
//             }
//     - For structs, the initializer allocates a structure (which has a T field but not an Id field) and fills in the fields:
//          function (type) {
//              var obj = NewStruct(type);
//              obj.field_of_A = ...;
//              ...
//              return obj;
//          }
//
// Read ('R' method in type structure)
// ~~~~
// 
// Given a JavaScript object:
//  - For ref types, return argument
//  - For value types:
//     - If nullable value type, invoke ReadNullable
//     - Otherwise, dereference argument pointer to yield underlying value
//
// Unbox ('U' method in type structure)
// ~~~~~
//
// In the CLR 'unboxing' takes a box object containing a value to a managed pointer to that value, and throws on null.
// In the JavaScript runtime, a box object is already represented as a pointer, hence only need to check for null.
// However, as a SPECIAL CASE, unboxing a null boxed Nullable<T> yields a pointer to a new "null" instance of Nullable<T>.
// 
// Given a JavaScript object:
//  - For ref types, raise InvalidCastException
//  - For value types:
//     - If nullable value type, return value pointer to result of ReadNullable
//     - Otherwise, assert argument is non-null and return it
//
// Box ('B' method in type structure)
// ~~~
//
// Given a JavaScipt object:
//  - For ref types, return argument
//  - For value types
//     - If nullable value type, return pointer to value inside nullable, or null if "null" nullable
//     - Otherwise return pointer to argument
//
// DefaultValue ('D' method in type structure)
// ~~~~~~~~~~~~
//
// Function with no args which returns a (fresh) default value for fields of this type:
//  - For ref types, return null
//  - For value types, return the appropriate initialized value. Note that for structures,
//    we must return a fresh instance upon every call lest we end up with accidential
//    aliasing of what should be a value but in JavaScript is actually a reference.
//
// Constrained ('O' method in type structure)
// ~~~~~~~~~~~
//
// Given an JavaScript object:
//  - If ref type: dereference argument as pointer
//  - If value type: return argument (which should be a pointer)
//
// IsValueType ('V' field in type structure)
// ~~~~~~~~~~~
//
// Boolean indicating if type is for a value type.
//

function TypeNameToQualifiedTypeName(assemblyName, typeName) {
    return ["[", assemblyName, "]", typeName].join("");
}

// Return qualified name of type
function QualifiedTypeName(type) {
    return TypeNameToQualifiedTypeName((type.Assembly == null ? "" : type.Assembly.Name), type.Name);
}

// Return a type name corresponding to the application of given type name to given type arguments.
// Note that we don't qualify the overall name by the assembly of the type name, but we do qualify each
// type argument type name by their defining assembly. Will be same as typeName for first-kinded types.
function FirstKindedTypeName(typeName, typeArgs) {
    var sb = [typeName];
    if (typeArgs != null) {
        for (var i = 0; i < typeArgs.length; i++) {
            if (i == 0)
                sb.push("<");
            else
                sb.push(",");
            sb.push(QualifiedTypeName(typeArgs[i]));
        }
        if (i > 0)
            sb.push(">");
    }
    return sb.join("");
}

// Return type structure corresponding to full type name within assembly structure, applied to given type structures
function ResolveType(assembly, typeName, typeArgs) {
    if (assembly == null && typeName == "[]")
        return ResolveArrayType(typeArgs[0], 1);
    else if (assembly == MSCorLib && typeName == "System.Nullable`1" && typeArgs != null)
        return ResolveNullableType(typeArgs[0]);
    else {
        var fkTypeName = FirstKindedTypeName(typeName, typeArgs);
        // Have we already loaded the (possibly higher-kinded) type and applied it to the given type arguments (if any)?
        var fkType = assembly.TypeCache[fkTypeName];
        if (fkType !== undefined) {
            // Is this the first time we're asking for this first-kinded type?
            var initializer = fkType.TypeInitializer;
            if (initializer !== undefined) {
                fkType.TypeInitializer = undefined;
                initializer();  // >>> May trigger resolution of more types and assemblies <<<
            }
            return fkType;
        }
        else {
            // Have we already loaded the higher-kinded type, even if we haven't applied it to these type arguments?
            var hkType = assembly.TypeCache[typeName];
            if (hkType !== undefined) {
                fkType = hkType.apply(null, typeArgs);
                assembly.TypeCache[fkTypeName] = fkType;
                // Go around again to ensure initialization
                return ResolveType(assembly, typeName, typeArgs);
            }
            else {
                // Have we pre-loaded this (possibly higher-kinded) type?
                var preloadedAssembly = DownloadCache[assembly.Name];
                if (preloadedAssembly !== undefined) {
                    var preloadedType = preloadedAssembly.Types[typeName];
                    if (preloadedType !== undefined) {
                        // Ask type to load itself
                        preloadedType();
                        // Go around again to apply type arguments (if any) and ensure initialization
                        return ResolveType(assembly, typeName, typeArgs);
                    }
                    // else: fall through
                }
                // else: fall through

                // Actually load the (possibly higher-kinded) type and try again
                if (OnServer)
                    LoadCode(PathToJSHandler + "jsfile.aspx?a=" + encodeURIComponent(assembly.Name) + "&t=" + encodeURIComponent(typeName));
                else {
                    var fileName = assembly.TypeNameToFileName[typeName];
                    if (fileName !== undefined)
                        LoadCode(assembly.Name + "/Types/" + fileName + ".js");
                }
                hkType = assembly.TypeCache[typeName];
                if (hkType === undefined) {
                    if (confirm("Failed to load type '" + typeName + "'\nWould you like to debug?"))
                        debugger;
                    assembly.TypeCache[typeName] = null;
                    return null;
                }
                else
                // Go around again to apply type arguments (if any) and ensure initialization
                    return ResolveType(assembly, typeName, typeArgs);
            }
        }
    }
}

function ResolveQualifiedType(qualTypeName) {
    var anb = qualTypeName.indexOf("[", 0);
    if (anb == -1) return null;
    var ane = qualTypeName.indexOf("]", anb + 1);
    var assemblyName = qualTypeName.substring(anb + 1, ane - anb - 1);
    var tne = qualTypeName.indexOf("<", ane + 1);
    if (tne == -1)
        tne = qualTypeName.length;
    var typeName = qualTypeName.substring(ane + 1, tne - ane);
    var typeArgs = [];
    var ab = tne;
    if (ab < qualTypeName.length && qualTypeName[ab] == "<")
        ab++;
    while (ab < qualTypeName.length) {
        var unclosed = 0;
        var ae = ab + 1;
        if (ae >= qualTypeName.length) return null;
        while ((qualTypeName[ae] != "," && qualTypeName[ae] != ">") || unclosed > 0) {
            if (qualTypeName[ae] == "<")
                unclosed++;
            else if (qualTypeName[ae] == ">")
                unclosed--;
            ae++;
            if (ae >= qualTypeName.length) return null;
        }
        var typeArgName = qualTypeName.substring(ab, ae - ab);
        typeArgs.push(ResolveQualifiedType(typeArgName));
        ab = ae + 1;
    }
    return ResolveType(ResolveAssembly(assemblyName), typeName, typeArgs);
}

// Return base type of first-kinded type structure
function BaseType(type) {
    for (var nm in type.Parents) {
        if (type.Parents[nm])
            return ResolveQualifiedType(nm);
    }
    return null;
}

// Return name of array over element type with given rank (typically 1).
function ArrayTypeName(elementType, rank) {
    var sb = [QualifiedTypeName(elementType), "["];
    while (--rank > 0)
        sb.push(",");
    sb.push("]");
    return sb.join("");
}

// As above, but specialized for the builtin array type constructor
function ResolveArrayType(elementType, rank) {
    // Have we already constructed this array type?
    var type = elementType.ArrayCache[rank];
    if (type !== undefined)
        return type;
    else {
        // Build on system array
        type = NewObject(TypeType);
        InheritProperties(type, ArrayType);
        // Specialize to this element type
        type.Name = ArrayTypeName(elementType, rank);
        type.Arguments = [elementType];
        type.Rank = rank;
        var parents = {};
        parents[TypeNameToQualifiedTypeName(MSCorLibName, "System.Object")] = false;
        parents[TypeNameToQualifiedTypeName(MSCorLibName, "System.Array")] = true;
        parents[type.Name] = false;
        type.Parents = parents;
        type.I = function(type2) { return NewArray(type2.Arguments[0], 0); };
        elementType.ArrayCache[rank] = type;
        return type;
    }
}

// As above, but specialized for the mostly-builtin Nullable type constructor
function ResolveNullableType(elementType) {
    // Have we already constructed this nullable type?
    var type = elementType.NullableCache;
    if (type !== undefined)
        return type;
    else {
        // Build on Nullable`1
        type = NewObject(TypeType);
        InheritProperties(type, NullableType);
        // Specialize to this element type
        type.Name = NullableTypeName(elementType);
        type.Arguments = [elementType];
        var parents = {};
        parents[TypeNameToQualifiedTypeName(MSCorLibName, "System.Object")] = false;
        parents[TypeNameToQualifiedTypeName(MSCorLibName, "System.ValueType")] = true;
        parents[type.Name] = false;
        type.Parents = parents;
        type.C = function(obj) {
            var res = NewStruct(obj.T);
            res.V = elementType.C(obj.V);
            return res;
        };
        type.I = function(type2) { return NewNullable(null, elementType); };
        type.R = function(obj) { return ReadNullable(obj, elementType); };
        type.U = function(obj) { return UnboxNullable(obj, elementType); };
        type.B = function(obj) { return BoxNullable(obj); };
        type.D = function() { return NewNullable(null, elementType); };
        type.O = function(ptr) { return ptr; };
        type.V = true;
        elementType.NullableCache = type;
        return type;
    }
}

// Return name of Nullable over element type.
function NullableTypeName(elementType) {
    return ["[", MSCorLibName, "]", "Nullable`1<", QualifiedTypeName(elementType), ">"].join("");
}

// ----------------------------------------------------------------------
// Type system helpers
// ----------------------------------------------------------------------

// Is srctype a subtype of dsttype?
function IsAssignableTo(srctype, dsttype) {
    return srctype.Parents[QualifiedTypeName(dsttype)] !== undefined;
}

// As above, but for array element types
function IsArrayElementAssignableTo(srctype, dsttype) {
    if (srctype.V) {
        // No covariance on arrays is allowed when element types are value types
        return srctype === dsttype;
    }
    else
        return IsAssignableTo(srctype, dsttype);
}

// Is obj an instance of type? Return obj if so, otherwise null.
function IsInst(obj, type) {
    if (obj === undefined)
        return undefined;
    else if (obj === null || obj.T === undefined || obj.T === null || !IsAssignableTo(obj.T, type))
        return null;
    else
        return obj;
}

// Is obj and instance of type? Return obj if so, otherwise raise an exception.
function CastClass(type, obj) {
    if (obj === undefined || obj === null)
        return obj;
    else if (obj.T.Rank !== undefined) {
        // obj is a built-in array
        if (type.Assembly === MSCorLib && type.Name == "System.Collections.Generic.IEnumerable`1") {
            // SPECIAL CASE 1: T[] may be cast to IEnumerable<U>, provided T is assignable to U as array element
            if (IsArrayElementAssignableTo(obj.T.Arguments[0], type.Arguments[0]))
                return obj;
            // else fall through
        }
        else if (type.Rank !== undefined) {
            // SPECIAL CASE 2: T[] may be cast to U[], provided T is assignable to U
            if (IsArrayElementAssignableTo(obj.T.Arguments[0], type.Arguments[0]))
                return obj;
            // else fall through
        }
        // else fall through
    }
    else if (IsAssignableTo(obj.T, type))
        return obj;
    // else fall through
    throw InvalidCastException(); // Exported from mscorlib
}

function GetElementType(type) {
    if (type.Rank === undefined)
        return null;
    else
        return type.Arguments[0];
}

// ----------------------------------------------------------------------
// Reflection helpers
// ----------------------------------------------------------------------

function MethodName(simpleMethodName, argTypes, returnTypeOrNull) {
    var sb = [simpleMethodName, "("];
    if (argTypes != null) {
        for (var i = 0; i < argTypes.length; i++) {
            if (i > 0)
                sb.push(",");
            sb.push(QualifiedTypeName(argTypes[i]));                 
        }
    }
    sb.push(")");
    if (returnTypeOrNull != null) {
        sb.push(":");
        sb.push(QualifiedTypeName(returnTypeOrNull));
    }
    return sb.join("");
}

function QualifiedMethodName(declType, simpleMethodName, argTypes, returnTypeOrNull) {
    var sb = [QualifiedTypeName(declType), "::", MethodName(simpleMethodName, argTypes, returnTypeOrNull)];
    return sb.join("");
}

function FieldName(simpleFieldName, fieldType) {
    var sb = ["field ", simpleFieldName, ":", QualifiedTypeName(fieldType)];
    return sb.join("");
 }

function QualifiedFieldName(declType, simpleFieldName, fieldType) {
    var sb = [QualifiedTypeName(declType), "::", FieldName(simpleFieldName, fieldType)];
    return sb.join("");
}

function EventName(simpleEventName, handlerType) {
    var sb = ["event ", simpleEventName, ":", QualifiedTypeName(handlerType)];
    return sb.join("");
 }

function QualifiedEventName(declType, simpleEventName, handlerType) {
    var sb = [QualifiedTypeName(declType), "::", EventName(simpleEventName, handlerType)];
    return sb.join("");
}

function DynamicInvokeConstructor(declType, simpleMethodName, paramTypes, paramValues) {
    var slot = declType.NameToSlot(MethodName(simpleMethodName, paramTypes, declType));
    var args = [];
    args.push(declType.I(declType));
    if (paramValues != null) {
        for (var i = 0; i < paramValues.length; i++) {
            if (paramTypes[i].V)
                args.push(AssertNonNull(paramValues[i]).R());
            else
                args.push(paramValues[i]);
        }
    }
    if (declType.V) {
        args[0] = NewPointerToValue(args[0], declType);
        declType[slot].apply(null, args);
        return args[0];
    }
    else
        return declType[slot].apply(null, args);
}

function DynamicInvokeMethod(declType, simpleMethodName, paramTypes, returnTypeIsKnown, returnTypeOrNull, instance, paramValues)  {
    var methodName;
    if (returnTypeIsKnown)
        methodName = MethodName(simpleMethodName, paramTypes, returnTypeOrNull);
    else
        methodName = declType.PartialToFullName[MethodName(simpleMethodName, paramTypes, null)];
    var slot = declType.NameToSlot(methodName);
    var args = [];
    args.push(instance);
    if (paramValues != null) {
        for (var i = 0; i < paramValues.length; i++) {
            if (paramTypes[i].V)
                args.push(AssertNonNull(paramValues[i]).R());
            else
                args.push(paramValues[i]);
        }
    }
    var func = declType.VirtualSlots[slot] === true ? instance.T[slot] : declType[slot];
    if (returnTypeOrNull == null)
        func.apply(null, args);
    else {
        var res = func.apply(null, args);
        if (res === null || res === undefined || !returnTypeOrNull.V)
            return res;
        else
            return NewPointerToValue(res, returnTypeOrNull);
    }
}

// ----------------------------------------------------------------------
// Error helpers
// ----------------------------------------------------------------------

function NSErr(methodName) {
    CreateError("Cannot use '" + methodName + "' since the 'NotSupported' attribute has been applied to it thus preventing its definition from being compiled by the volta compiler.");
}

function NSIErr(origMethodName, newMethodName) {
    CreateError("Method '" + origMethodName + "' cannot be overridden/implemented by '" + newMethodName + "'");
}

function DebugPrintCallStack() {
    try {
        var arrCallStack = new Array();
        var objStartOfCallstack = DebugGetCallingFunction(null);

        DebugBuildCallStack(objStartOfCallstack, arrCallStack);

        return arrCallStack.join("\n");
    }
    catch (e) {
        return "Error retreiving callstack:\n\t" + e.message;
    }
};

function DebugBuildCallStack(objCallingFunction, arrCallStack) {
    if (objCallingFunction && objCallingFunction.callee) {
        var strSource = objCallingFunction.callee.toString().match(new RegExp("function\\s*(.*)\\("))[1];
        if (strSource == null || strSource == "")
            strSource = "[Anonymous function]";
        arrCallStack.push(strSource);
        DebugBuildCallStack(DebugGetCallingFunction(objCallingFunction), arrCallStack);
    }
    else
        arrCallStack.push("<End>");
};

function DebugGetCallingFunction(objFunction) {
    if (objFunction == null)
        return arguments.caller;
    else if (objFunction.caller)
        return objFunction.caller;
    else if (objFunction.arguments && objFunction.arguments.caller)
        return objFunction.arguments.caller;
    else
        return null;
};

function CreateError(error) {
    if ($boe) {
        var dbgMsg = msg + "\n\nCallstack:\n" + DebugPrintCallStack() + "\n\nWould you like to debug?";
        if (confirm(dbgMsg))
            debugger;
    }
    alert(error);
    throw error;
}

// ----------------------------------------------------------------------
// Misc helpers
// ----------------------------------------------------------------------

// "Pop" stack at given index (from bottom of stack)
// (Needed when calling methods with stack-based arguments)
function PopStack(stack, base) {
    return stack.splice(base, 1)[0];
}

// Raise if object is null
// (Inserted before every virtual call)
function AssertNonNull(obj) {
    if (obj === undefined || obj === null)
        throw NullReferenceException(); // Exported from mscorlib
    else
        return obj;
}

// ----------------------------------------------------------------------
// Special types
// ----------------------------------------------------------------------

//
// Object structure
// ~~~~~~~~~~~~~~~~
//
//     <may be an instance of a built-in JavaScript class, or just an object>
//     T : type structure             (* First-kinded type structuer this is an instance of *)
//     Id : int                       (* Unique id for object. Used by GetHashCode and marshalling. Absent in value type instances. *)
//     ComInstance : object           (* If object was returned from a COM-interop call, the underlying result.
//                                       (Such objects typically don't support "expando" fields, so we must wrap them.)
//     <instance field slot> : object (* Value of instance field. Always begins with 'f'. *)
//
// Constructors
// ~~~~~~~~~~~~
//
// A constructor accepts an initialized JavaScript object of the final constructed type, and the constructor arguments (if any).
// It returns either the original instance (mutated appropriately) or a new instance (with fields copied over from the original).
//
//  - For ref types:
//     - If A derives from Object and A's constructor is imported from JavaScript function F:
//          The imported function F is assumed to accept the constructor arguments, and returns
//          a new object of whatever undelying JavaScript type makes sense (eg a DOM type).
//          The constructor we generate must account for this:
//             function ACtor(oldobj, arg1, ..., argn) {
//                 newobj = F(arg1, ..., argn);
//                 InheritProperties(newobj, oldobj);
//                 return newobj;
//             }
//     - If A derives from B and A's constructor is not an imported JavaScript function:
//          function ACtor(obj, arg1, ..., argn) {
//              obj = BCtor(obj, ...);             
//              ... assign fields of obj ...
//              return obj;
//          }
//     - Special ref types are constructed explicitly by the runtime system:
//        - Delegates and represented as a pair of target object and JavaScript function, and are themselves functions.
//        - Pointers are represented as a pair of read/write JavaScript functions.
//        - Arrays are represented as JavaScript arrays.
//  - For value types:
//       The constructor takes a pointer to an initialized value, and may mutate it is as required. It does not return a result.
//          function ACtor(ptr) {
//              ... write to ptr as required ...
//          }
//
// Initobj
// ~~~~~~~
//
// The instruction:
//    initobj A
// with ptr on the stack, is compiled to:
//    ptr.W(typeofA.D()));
// Note that A may be a generic type, and thus may be bound to a reference type at runtime, in which case
// ptr will be left holding null. (The C# compiler depends on this to implement new T() where T is a type parameter.)
//
// Newobj
// ~~~~~~
//
// The instruction:
//    newobj f
// where f is a constructor of A taking n arguments, is compiled to:
//  - If A is a ref type:
//       var obj = typeofA.I(typeofA);
//       obj = f(obj, arg1, ..., argn);
//  - If A is a value type:
//       var obj = typeofA.I(typeofA);
//       f(NewPointerToVariable(... read obj ..., ... write obj ..., typeofA), arg1, ..., argn) 
// where obj holds the expression result.
//

var NextObjectId =
function() {
    var nextObjectId = 1;  // zero is already used by the TypeType
    return function() { return nextObjectId++; };
} ();

function NewObject(type) {
    return { T : type, Id : NextObjectId() };
}

function NewStruct(type) {
    return { T : type };
}

function ImportObject(obj, type) {
    obj.T = type;
    obj.Id = NextObjectId();
}

function InheritProperties(newobj, oldobj) {
    for (var p in oldobj) {
        if (newobj[p] === undefined)
            newobj[p] = oldobj[p];
    }
}

//
// Nullable<T> structure
// ~~~~~~~~~~~~~~~~~~~~~
//
//     T : type structure      (* As for object *)
//     V : object              (* null for nullable 'null', otherwise instance of value type *)
//

function NewNullable(val, elementType) {
    var obj = NewStruct(ResolveNullableType(elementType));
    obj.V = val;
    return obj;
}

// ptr is to a nullable structure, whose value field may be null
function BoxNullable(ptr) {
    var val = ptr.R().V;
    return val == null ? null : NewPointerToValue(val, ptr.T.Arguments[0]);
}

// obj is null or a pointer to a (non-null) value
function ReadNullable(obj, elementType) {
    var val = obj == null ? null : obj.R();
    return NewNullable(val, ResolveNullableType(elementType));
}

// obj is null or a pointer to a (non-null) value
function UnboxNullable(obj, elementType) {
    return NewPointerToValue(ReadNullable(obj, elementType), ResolveNullableType(elementType));
}

//
// Pointer structure
// ~~~~~~~~~~~~~~~~~
//
//     T : type structure      (* As for object *)
//     Id : int                (* As for object *)
//     R : () -> object        (* Read value from pointer *)
//     W : object -> ()        (* Write value to pointer *)
//

function NewPointerToValue(val, type) {
    if (val === undefined || val === null)
        return val;
    else {
        var ptr = NewObject(type);
        ptr.R = function() { return val; };
        ptr.W = function(v) { throw NotSupportedException(); }; ; // Exported from mscorlib
        return ptr;
    }
}

function NewPointerToObjectField(obj, fieldName, fieldType) {
    if (obj === undefined || obj == null)
        return obj;
    else {
        var ptr = NewObject(fieldType);
        ptr.R = function() { return obj[fieldName]; };
        ptr.W = function(v) { obj[fieldName] = v; };
        return ptr;
    }
}

function NewPointerToStaticField(scopeType, fieldName, fieldType) {
    var ptr = NewObject(fieldType);
    ptr.R = function() { return scopeType[fieldName]; };
    ptr.W = function(v) { scopeType[fieldName] = v; };
    return ptr;
}

function NewPointerToArrayElem(arr, idx, elementType) {
    if (arr === undefined || idx === undefined)
        return undefined;
    else if (arr === null || idx === null)
        return null;
    else {
        var ptr = NewObject(elementType);
        ptr.R = function() { return arr[idx]; };
        ptr.W = function(v) { arr[idx] = v; };
        return ptr;
    }
}

function NewPointerToVariable(reader, writer, varType) {
    var ptr = NewObject(varType);
    ptr.R = reader;
    ptr.W = writer;
    return ptr;
}

function IsPointer(ptr) {
    return ptr !== undefined && ptr !== null && ptr.R !== undefined && ptr.W !== undefined;
}

function ReadIfPointer(obj) {
    return IsPointer(obj) ? obj.R() : obj;
}

//
// Delegate structure (deliberately collapsing single- and multi-cast delegates into one representation)
// ~~~~~~~~~~~~~~~~~~ 
//
//     <is a JavaScript function from Invoke arguments to delegate result>
//     T : type structure      (* As for object *)
//     Id : int                (* As for object *)
//     Target : object         (* Undefined if multi-cast delegate. Otherwise target object of instance method, or null if delegate of static method *)
//     Func : arg1 -> ... -> argn -> <method result or void>
//                             (* Undefined if multi-cast delegate. Otherwise method to invoke. If instance method, target will be passed as first argument, and Invoke arguments passed as remainder. *)
//     Multicast : array       (* Undefined if single-cast delegate. Otherwise array (of length >= 2) of single-cast delegates. *)
//

function NewDelegate(target, func, type) {
    var del = function() {
        if (target === null)
            return func.apply(null, arguments);
        else {
            // Expensive! Why can't we just use 'this' instead of passing our own instance?
            var args = new Array(0);
            args.push(target);
            for (var i = 0; i < arguments.length; i++)
                args.push(arguments[i]);
            return func.apply(null, args);
        }
    };
    ImportObject(del, type);
    del.Target = target;
    del.Func = func;
    del.Multicast = undefined;
    return del;
}

function NewMulticastDelegate(multicast, type) {
    var del = function() {
        var res;
        for (var i = 0; i < multicast.length; i++)
            res = multicast[i].apply(null, arguments);
        return res;
    };
    ImportObject(del, type);
    del.Target = undefined;
    del.Func = undefined;
    del.Multicast = multicast;
    return del;
}

function CombineAllDelegates(dels) {
    var type;
    var len = 0;
    for (var i = 0; i < dels.length; i++) {
        if (dels[i] === undefined)
            return undefined;
        if (dels[i] != null) {
            if (type === undefined)
                type = dels[i].T;
            else if (type !== dels[i].T)
                throw InvalidOperationException(); // Exported from mscorlib
            if (dels[i].Multicast === undefined)
                len++;
            else
                len += dels[i].Multicast.length;
        }
    }
    if (len == 0)
        return null;
    else if (len == 1) {
        for (i = 0; i < dels.length; i++) {
            if (dels[i] != null)
                return dels[i];
        }
        throw InvalidOperationException(); // Exported from mscorlib, shouldn't happen
    }
    else {
        multicast = new Array(len);
        var k = 0;
        for (i = 0; i < dels.length; i++) {
            if (dels[i] != null) {
                len = dels[i].Multicast === undefined ? 1 : dels[i].Multicast.length;
                for (var j = 0; j < len; j++)
                    multicast[k++] = dels[i].Multicast === undefined ? dels[i] : dels[i].Multicast[j];
            }
        }
        return NewMulticastDelegate(multicast, type);
    }
}

function CombineDelegates(ldel, rdel) {
    return CombineAllDelegates([ldel, rdel]);
}

function RemoveAllDelegates(ldel, rdel) {
    if (ldel === undefined || rdel === undefined)
        return undefined;
    else if (ldel === null || rdel === null)
        return ldel;
    else if (ldel === rdel)
        return null;
    else if (ldel.T !== rdel.T)
        throw InvalidOperationException(); // Exported from mscorlib
    else if (ldel.Multicast === undefined)
        return ldel;
    else if (rdel.Multicast === undefined) {
        var multicast = new Array(0);
        for (var i = 0; i < ldel.Multicast.length; i++) {
            if (!EqualDelegates(ldel.Multicast[i], rdel))
                multicast.push(ldel.Multicast[i]);
        }
        if (multicast.length == ldel.Multicast.length)
            return ldel;
        else if (multicast.length == 1)
            return multicast[0];
        else
            return NewMulticastDelegate(multicast, ldel.T);
    }
    else if (ldel.Multicast.length < rdel.Multicast.length)
        return ldel;
    else {
        for (var i = ldel.Multicast.length - rdel.Multicast.length; i >= 0; i--) {
            var multicast = new Array(0);
            for (var j = 0; j < ldel.Multicast.length; j++) {
                if (j < i || j >= i + rdel.Multicast.length)
                    multicast.push(ldel.Multicast[j]);
                else if (!EqualDelegates(ldel.Multicast[j], rdel.Multicast[j - i]))
                    break;
            }
            if (j >= ldel.Multicast.length)
                return NewMulticastDelegate(multicast, ldel.T);
        }
        return ldel;
    }
}

function DynamicInvokeDelegate(del, args) {
    if (del === undefined || del === null)
        return del;
    else
        return del.apply(null, args);
}

function EqualDelegates(ldel, rdel) {
    if (ldel === undefined || rdel === undefined)
        return undefined;
    else if (ldel === null || rdel === null)
        return false;
    else {
        var llen = ldel.Multicast === undefined ? 1 : ldel.Multicast.length;
        var rlen = rdel.Multicast === undefined ? 1 : rdel.Multicast.length;
        if (llen != rlen)
            return false;
        else {
            for (var i = 0; i < llen; i++) {
                var ltarget = ldel.Multicast === undefined ? ldel.Target : ldel.Multicast[i].Target;
                var lfunc = ldel.Multicast === undefined ? ldel.Func : ldel.Multicast[i].Func;
                var rtarget = rdel.Multicast === undefined ? rdel.Target : rdel.Multicast[i].Target;
                var rfunc = rdel.Multicast === undefined ? rdel.Func : rdel.Multicast[i].Func;
                if (ltarget != rtarget || lfunc != rfunc)
                    return false;
            }
            return true;
        }
    }
}

function HashDelegate(del) {
    if (del === undefined || del === null)
        return del;
    else {
        // Remarkably, even though equality on delagates in the CLR is structural on target
        // and function pointer, hashing is based on the delegate type and (effectively) length only.
        var res = del.T.Id;
        if (del.Multicast !== undefined)
            res = res ^ (del.Multicast.length * 17);
        return res;
    }
}

//
// Array structure (rank 1 only)
// ~~~~~~~~~~~~~~~
//
//     <is a JavaScript array>
//     T : type structure        (* As for object *)
//     Id : int                  (* As for object *)
//

function NewArray(elementType, size) {
    var arr = new Array(size);
    if (elementType.V) {
        // WARNING: Don't outline the construction of the default value since structs must be created afresh for each element!
        for (var i = 0; i < arr.length; i++)
            arr[i] = elementType.D();
    }
    else {
        var d = elementType.D();
        for (var i = 0; i < arr.length; i++)
            arr[i] = d;
    }
    ImportObject(arr, ResolveArrayType(elementType, 1));
    return arr;
}

function GetArrayValue(arr, index) {
    if (arr === undefined || arr === null)
        throw NullReferenceException(); // Exported from mscorlib
    else if (index < 0 || index > arr.length)
        throw IndexOutOfRangeException(); // Exported from mscorlib
    else
        return arr[index];
}

// System.Array::SetValue and the CLR stelem* family don't agree on their covariant check exceptions, hence the extra boolean flag.
function SetArrayValue(arr, index, value, shouldThrowCastException) {
    if (arr === undefined || arr === null)
        throw NullReferenceException(); // Exported from mscorlib
    else if (!arr.T.Arguments[0].V && value !== null && value !== undefined && !IsAssignableTo(value.T, arr.T.Arguments[0])) {
        // Arrays are only contravariant over ref types
        throw shouldThrowCastException ? InvalidCastException() : ArrayTypeMismatchException(); // Exported from mscorlib
    }
    else if (index < 0 || index > arr.length)
        throw IndexOutOfRangeException(); // Exported from mscorlib
    else
        arr[index] = value;
}

// Copy raw bytes from a constant array of bytes into destination array which may be of any primitive type
function InitializeArray(dstarr, srcarr) {
    var dstelemtype = dstarr.T.Arguments[0];
    if (dstelemtype.Assembly == MSCorLib) {
        if (dstelemtype.Name == "System.Byte") {
            for (var i = 0; i < srcarr.length; i++)
                dstarr[i] = srcarr[i];
        }
        else if (dstelemtype.Name == "System.Char") {
            for (var i = 0; i < srcarr.length; i += 2)
                dstarr[i / 2] = 256 * srcarr[i] + srcarr[i + 1];
        }
        else if (dstelemtype.Name == "System.Int32") {
            for (var i = 0; i < srcarr.length; i += 4)
                dstarr[i / 4] = srcarr[i] + 256 * (srcarr[i + 1] + 256 * (srcarr[i + 2] + 256 * srcarr[i + 3]));
        }
        else
            NSErr("InitializeArray");
    }
    else
        NSErr("InitializeArray");
}


        public SharedBindings<T> Fork(NameSupply newNameSupply)
        {
            var res = new SharedBindings<T>(newNameSupply);
            // Child sees all the bindings of the parent
            foreach (var t in bindingOrder)
            {
                res.bindingOrder.Add(t);
                res.cache.Add(t, cache[t]);
            }
            return res;
        }



// ----------------------------------------------------------------------
// Error helpers
// ----------------------------------------------------------------------

function DebugPrintCallStack() {
    try {
        var arrCallStack = new Array();
        var objStartOfCallstack = DebugGetCallingFunction(null);

        DebugBuildCallStack(objStartOfCallstack, arrCallStack);

        return arrCallStack.join("\n");
    }
    catch (e) {
        return "Error retreiving callstack:\n\t" + e.message;
    }
}

function DebugBuildCallStack(objCallingFunction, arrCallStack) {
    if (objCallingFunction && objCallingFunction.callee) {
        var strSource = objCallingFunction.callee.toString().match(new RegExp("function\\s*(.*)\\("))[1];
        if (strSource == null || strSource == "")
            strSource = "[Anonymous function]";
        arrCallStack.push(strSource);
        DebugBuildCallStack(DebugGetCallingFunction(objCallingFunction), arrCallStack);
    }
    else
        arrCallStack.push("<End>");
}

function DebugGetCallingFunction(objFunction) {
    if (objFunction == null)
        return arguments.caller;
    else if (objFunction.caller)
        return objFunction.caller;
    else if (objFunction.arguments && objFunction.arguments.caller)
        return objFunction.arguments.caller;
    else
        return null;
}

            invalidChars = Path.GetInvalidPathChars();

            expandSymbols = new Dictionary<char, string>();
            expandSymbols.Add('+', "_plus_");
            expandSymbols.Add('=', "_equals_");
            expandSymbols.Add('!', "_bang_");
            expandSymbols.Add('@', "_at_");
            expandSymbols.Add('#', "_hash_");
            expandSymbols.Add('$', "_dollar_");
            expandSymbols.Add('%', "_percent_");
            expandSymbols.Add('^', "_caret_");
            expandSymbols.Add('&', "_ampersand_");
            expandSymbols.Add('*', "_asterisk_");
            expandSymbols.Add('(', "_lparen_");
            expandSymbols.Add(')', "_rparen_");
            expandSymbols.Add('_', "_underscore_");
            expandSymbols.Add('-', "_minus_");
            expandSymbols.Add('|', "_bar_");
            expandSymbols.Add('\\', "_backslash_");
            expandSymbols.Add('"', "_dblquote_");
            expandSymbols.Add('\'', "_quote_");
            expandSymbols.Add('~', "_tilde_");
            expandSymbols.Add('`', "_backtick_");
            expandSymbols.Add('[', "_lbracket_");
            expandSymbols.Add(']', "_rbracket_");
            expandSymbols.Add('{', "_lbrace_");
            expandSymbols.Add('}', "_rbrace_");
            expandSymbols.Add(',', "_comma_");
            expandSymbols.Add('.', "_period_");
            expandSymbols.Add('?', "_question_");
            expandSymbols.Add('/', "_slash_");
            expandSymbols.Add('<', "_langle_");
            expandSymbols.Add('>', "_rangle_");
            expandSymbols.Add('0', "_zero_");
            expandSymbols.Add('1', "_one_");
            expandSymbols.Add('2', "_two_");
            expandSymbols.Add('3', "_three_");
            expandSymbols.Add('4', "_four_");
            expandSymbols.Add('5', "_five_");
            expandSymbols.Add('6', "_six_");
            expandSymbols.Add('7', "_seven_");
            expandSymbols.Add('8', "_eight_");
            expandSymbols.Add('9', "_nine_");



        // Impose an (arbitrary) total order on method definitions from the same declaring type
        public static int CompareMethodDefsInSameType(Method l, Method r)
        {
            // First on method name
            var i = l.Name.Name.CompareTo(r.Name.Name);
            if (i != 0)
                return i;
            else
            {
                // Second on method return type
                i = TypeHelpers.CompareTypes(l.ReturnType, r.ReturnType);
                if (i != 0)
                    return i;
                else
                {
                    // Third on method parameter arities
                    var lpar = l.Parameters;
                    var rpar = r.Parameters;
                    i = lpar.Count.CompareTo(rpar.Count);
                    if (i != 0)
                        return i;
                    else
                    {
                        // Fourth pairwise on method parameters
                        for (var j = 0; j < lpar.Count; j++)
                        {
                            i = MethodParameter.CompareMethodParameters(MethodParameter.FromParameter(lpar[i]), MethodParameter.FromParameter(rpar[i]));
                            if (i != 0)
                                return i;
                        }
                        return 0;
                    }
                }
            }
        }


        // Impose an (arbitrary) total order on field definitions within the same declaring type
        public static int CompareFieldDefsInSameType(Field l, Field r)
        {
            // First on field name
            var i = l.Name.Name.CompareTo(r.Name.Name);
            if (i != 0)
                return i;
            else
                // Second on field type
                return TypeHelpers.CompareTypes(l.Type, r.Type);
        }



        public static int CompareMethodParameters(MethodParameter l, MethodParameter r)
        {
            // First on index
            var i = l.Index.CompareTo(r.Index);
            if (i != 0)
                return i;
            else
            {
                // Second on semantics
                i = ((int)l.Semantics).CompareTo((int)r.Semantics);
                if (i != 0)
                    return i;
                else
                    // Third on underlying type
                    return TypeHelpers.CompareTypes(l.Type, r.Type);
            }
        }



        // Impose an (arbitrary) total order on all types
        public static int CompareTypes(TypeNode l, TypeNode r)
        {
            // First on applicand type structure
            var lapp = TypeHelpers.Applicand(l);
            var rapp = TypeHelpers.Applicand(r);
            var lflavor = Classify(lapp);
            var rflavor = Classify(rapp);
            var i = ((int)lflavor).CompareTo((int)rflavor);
            if (i != 0)
                return i;
            else
            {
                switch (lflavor)
                {
                    case TypeFlavor.Application:
                        throw new InvalidOperationException("Curried type application");
                    case TypeFlavor.Array:
                        // Second on rank
                        i = Rank(l).CompareTo(Rank(r));
                        if (i != 0)
                            return i;
                        else
                            // Third on array element type
                            return CompareTypes(Arguments(l)[0], Arguments(r)[0]);
                    case TypeFlavor.Nullable:
                        // Second on element type
                        return CompareTypes(Arguments(l)[0], Arguments(r)[0]);
                    case TypeFlavor.Pointer:
                        // Second on underlying type
                        return CompareTypes(Arguments(l)[0], Arguments(r)[0]);
                    case TypeFlavor.String:
                    case TypeFlavor.Boolean:
                    case TypeFlavor.Void:
                        // Equal
                        return 0;
                    case TypeFlavor.Number:
                    case TypeFlavor.Enum:
                        // Second on type name
                        return l.Name.Name.CompareTo(r.Name.Name);
                    case TypeFlavor.Struct:
                    case TypeFlavor.Delegate:
                    case TypeFlavor.Class:
                    case TypeFlavor.Interface:
                        // Second on applicand type name
                        i = lapp.Name.Name.CompareTo(rapp.Name.Name);
                        if (i != 0)
                            return i;
                        else
                        {
                            // Third on type argument length
                            var largs = TypeHelpers.Arguments(l);
                            var rargs = TypeHelpers.Arguments(r);
                            i = largs.Count.CompareTo(rargs.Count);
                            if (i != 0)
                                return i;
                            else
                            {
                                // Fourth pairwise on type arguments (if any)
                                for (var j = 0; j < largs.Count; j++)
                                {
                                    i = CompareTypes(largs[j], rargs[j]);
                                    if (i != 0)
                                        return i;
                                }
                                return 0;
                            }
                        }
                    case TypeFlavor.Parameter:
                        // Second on parameter index.
                        // If method parameters types, may be parameters from different methods, but we'll compare them anyway
                        return ParameterNumber(l).CompareTo(ParameterNumber(r));
                    default:
                        throw new InvalidOperationException("Unrecognised type flavor");
                }
            }
        }



        // Impose an (arbitrary) total order on event definitions within the same declaring type
        public static int CompareEventDefsInSameType(Event l, Event r)
        {
            // First on event name
            var i = l.Name.Name.CompareTo(r.Name.Name);
            if (i != 0)
                return i;
            else
                // Second on event handler type
                return TypeHelpers.CompareTypes(l.HandlerType, r.HandlerType);
        }



// Inherited virtual methods
// ~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Given:
//
//    class B<T> { virtual void M() { ... } }
//    class D<T> : B<T> { }
//
// then from above we know B<T> has binding:
//
//    m = function(p) { ... }
//
// and D<T> must inherit that. Easiest is to copy over on first application:
//
//    m = function(p) {
//            var a = (* type D`1 *)
//            var q = (* type B`1 *)
//            var f = q.m;
//            a.m = f;
//            return f(p);
//        }
// Now all instantiations of M, whether via B`1 or D`1, will be cached in B`1.
//
// However, given:
//
//    class B { virtual void M(int i) { ... } }
//    class D : B { }
//
// then from above we know B has binding:
//
//    m = function(i) { ... }
//
// and D must inherit that, including any caching by B. Easiest is to re-copy
// method from B after the first call via D:
//
//    m = function(i) {
//            var a = (* type D *)
//            var q = (* type B *)
//            var res = q.m(i);
//            a.m = q.m;
//            return res;
//        }
//
// Since all type lookups of base types are protected by a lambda, we are free to bind these methods
// even before a type is at phase 3.
//
// Interface methods
// ~~~~~~~~~~~~~~~~~
//
// Interface methods can only be bound at phase 3, since the interface method slot names may depend on
// other types. However the bodies of interface methods are free to use the same caching tricks as for
// inherited virtual methods above.
//



//
// Higher-kinded type structure
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//     <is a JavaScript function from array of first-kinded type structures to first-kinded type structure>
//     T : <type structure>                       (* As for object *)
//     Id : int                                   (* As for object *)
//     Assembly : <assembly structure>            (* Containing assembly *)
//     Name : string                              (* Type name *)
//
// First-kinded type structure (whether declared as such or constructed by type application)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//     T : <type structure>                       (* As for object *)
//     Id : int                                   (* As for object *)
//     Assembly : <assembly structure>            (* Containing assembly. Undefined for array types. *)
//     Name : string                              (* Type name *)
//     InitializeTypeSlots : () -> ()             (* Initialize all the method and static field slots of this type. Reset to undefined before called for first time. *)
//     FinalizeTypeSlots : () -> ()               (* Clear all the static field slots of this type. We leave the method slots alone. *)
//     InvokeStaticConstructor : () -> ()         (* Call the static constructor (if any) for this type. Reset to undefined before called for first time. *)
//     Applicand : <type structure>               (* If instance of (non built-in array) higher-kinded type, the higher-kinded type. Otherwise undefined. *)
//     Arguments : [<type structure>]             (* If instance of higher-kinded type or built-in array type, the type arguments for that type. Otherwise undefined. *)
//     Rank : int                                 (* If instance of array type, the array rank, otherwise undefined *)
//     Supertypes : string |-> bool               (* Map from qualified type names to 'true' if immediate base type, 'false' if super-type but not immediate base type *)
//     AssignableToCache : int |-> bool           (* Map from type id to 'true' if current type is assignable to the types id., 'false' if not. This map is built dynamically at runtime. *)
//     ArrayCache : int |-> <type structure>      (* Map from rank numbers to array types over this type of that rank *)
//     NullableCache : <type structure>           (* Cached application of Nullable to this type, or undefined *)
//     RegisterExports : object -> ()             (* Add exported instance methods of type to given object *)
//     DynamicTypeMarshaller : object -> string   (* If type has a type marshaller: a function that given an instance, returns the qualified name of the instance's type. Otherwise: undefined *)
//     DefaultConstructor : () -> object          (* If type has a default constructor, yield new instance. Otherwise undefined. *)
//     C : object -> object                       (* Clone - see below *)
//     I : <type structure> -> object             (* Instance initializer - see below *)
//     R : object -> object                       (* Read if value type - see below *)
//     U : object -> object                       (* Unbox if value type - see below *)
//     B : object -> object                       (* Box if value type - see below *)
//     A : object -> object                       (* Unbox any - see below *)
//     D : () -> object                           (* Make default value - see below *)
//     O : object -> object                       (* Dereference if not value type - see below *)
//     V : bool                                   (* True if a value type - see below *)
//
//     (* Only bound after loading reflection data *)
//     NameToSlot : string |-> string             (* Map each field and method name (possibly with free type variables) to corresponding slot name. Events and properties have no slots. *)
//     PartialToFullName : string |-> string      (* Map each method name (possibly with free type variables) with return type forced to be void to actual method name. *)
//     SimpleToFullName : string |-> string       (* Map each simple member name (including events and properties) to the corresponding actual member name (possibly with free type variables), or null if multiple members share the same simple name.
//     VirtualSlots : string |-> bool             (* Map each slot name corresponding to a virtual method to 'true' *)
//     ReflectionTypeName : string                (* Name as to be returned by public reflection api *)
//     ReflectionTypeNamespace : string           (* Namespace as to be returned by public reflection api *)
//     ReflectionTypeFullName : () -> string      (* Function that will take type arguments and return the full name as to be returned by the public reflection api.
//
//     (* Only bound after invoking InitializeTypeSlots (ie in phase 2 or later) *)
//     <method slot> : function                   (* Slot for non-interface method implementation. *)
//     <interface method slot> : function         (* Slot for interface method implementation. *)
//     <static field slot> : object               (* Slot for static field. *)
//




    // aka "ResolveType"
    root.T = function(assembly, hkTypeName, phase, typeArgs) {
        if (assembly === undefined && hkTypeName == "[]")
            return root.ResolveArrayType(typeArgs[0], 1);
        else if (assembly === root.MSCorLib && hkTypeName == "System.Nullable`1" &&
                 typeArgs !== undefined && typeArgs.length == 1)
            return root.ResolveNullableType(typeArgs[0]);
        else {
            var typeArgQNames;
            if (typeArgs !== null && typeArgs !== undefined) {
                typeArgQNames = [];
                for (var i = 0; i < typeArgs.length; i++)
                    typeArgQNames.push(root.MakeQualifiedTypeName(typeArgs[i].Assembly, typeArgs[i].Name));
            }
            var fkTypeName = root.MakeTypeName(hkTypeName, typeArgQNames);
            // Have we already loaded the (possibly higher-kinded) type and applied it to the given
            // type arguments (if any)?
            var fkType = assembly.TypeCache[fkTypeName];
            if (fkType !== undefined) {
                // Take this type from it's current phase to the requested phase
                while (root.CurrentTypePhase(fkType) < phase) {
                    var f = fkType.InitializeTypeSlots;
                    if (f !== undefined) {
                        fkType.InitializeTypeSlots = undefined;
                        f();
                    }
                    else {
                        f = fkType.InvokeStaticConstructor;
                        if (f !== undefined) {
                            fkType.InvokeStaticConstructor = undefined;
                            f();
                        }
                        else
                            throw root.InvalidOperationExceptionWithMessage("invalid state of type: " + fkType.Name);
                    }
                }
                return fkType;
            }
            else {
                // Have we already loaded the higher-kinded type, even if we haven't applied it to these
                //  particular type arguments?
                var hkType = assembly.TypeCache[hkTypeName];
                if (hkType !== undefined) {
                    // Thus typeArgs must have entries
                    fkType = hkType.apply(null, typeArgs);
                    fkType.Applicand = hkType;
                    assembly.TypeCache[fkTypeName] = fkType;
                    // Go around again to ensure initialization to correct phase
                    return root.T(assembly, hkTypeName, phase, typeArgs);
                }
                else {
                    // Actually load the (possibly higher-kinded) type and try again
                    if (roo.FilesAreRemote)
                        root.LoadCode(root.ServerPrefix + "?a=" + encodeURIComponent(assembly.Name) + "&t=" +
                                      encodeURIComponent(hkTypeName));
                    else {
                        root.PrepareAssemblyForMapping(assembly);
                        var fileName = assembly.TypeNameToFileName[hkTypeName];
                        if (fileName === undefined)
                            throw root.InvalidOperationExceptionWithMessage("no file for type: " + hkTypeName);
                        else
                            root.LoadCode(root.AssemblyNameToFileName(assembly.Name) + "/Types/" + fileName + ".js");
                    }
                    hkType = assembly.TypeCache[hkTypeName];
                    if (hkType === undefined)
                        throw root.InvalidOperationExceptionWithMessage("unable to load type: " + hkTypeName);
                    else {
                        // Go around again to (possibly) apply the freshly loaded type to type arguments (if any) and
                        //  initialize to correct phase
                        return root.T(assembly, hkTypeName, phase, typeArgs);
                    }
                }
            }
        }
    };


    // Return name of array over element type with given rank (typically 1).
    root.ArrayTypeName = function(elementType, rank) {
        var sb = [];
        root.AppendQualifiedTypeName(sb, elementType.Assembly, elementType.Name);
        sb.push("[");
        while (--rank > 0)
            sb.push(",");
        sb.push("]");
        return sb.join("");
    };

        public static bool CanBeCachedInAssembly(TypeNode typeNode)
        {
            switch (TypeHelpers.Classify(typeNode))
            {
                case TypeFlavor.Application:
                case TypeFlavor.Array:
                case TypeFlavor.Pointer:
                case TypeFlavor.Parameter:
                    return false;

                case TypeFlavor.Void:
                case TypeFlavor.String:
                case TypeFlavor.Boolean:
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                case TypeFlavor.Struct:
                case TypeFlavor.Delegate:
                case TypeFlavor.Class:
                case TypeFlavor.Interface:
                case TypeFlavor.Nullable:
                    return IsAddressableType(typeNode);
                default:
                    throw new InvalidOperationException();
            }
        }




        public CLR.TypeNode OriginalDefinition(CLR.TypeNode typeNode)
        {
            var nrOfConsolidatedArguments = typeNode.ConsolidatedTemplateArguments == null ? 0 : typeNode.ConsolidatedTemplateArguments.Count;
            var nrOfArguments = typeNode.TemplateArguments == null ? 0 : typeNode.TemplateArguments.Count;
            
            if (nrOfConsolidatedArguments == 0)
            {
                return typeNode;
            }
            
            var baseType = typeNode;
            while (baseType.Template != null)
            {
                baseType = baseType.Template;
            }

            if (nrOfConsolidatedArguments == nrOfArguments)
            {
                return baseType;
            }
            else
            {
                var originalDeclaringType = OriginalDefinition(typeNode.DeclaringType);
                var nested = from member in originalDeclaringType.Members.ToEnumerable()
                             where member is CLR.TypeNode &&
                                   member.Name.Name.Equals(baseType.Name.Name, StringComparison.Ordinal)
                             select member as CLR.TypeNode;
                var node = nested.FirstOrDefault();
                return node;
            }
        }





        private JST.Expression PrimMethodToExpression(JST.Expression targetType, CLR.Method method, bool forInvocation)
        {
            var msg = forInvocation ? utils.ValidateMethod(method, scope) : null;
            if (msg != null)
                return NotSupported(msg);
            else
            {
                // The method is either a statically-known identifier or a dynamically-constructed interface method name
                var methodId = env.GlobalMapping.ResolveMethodToIdentifier(method);
                var func = default(JST.Expression);
                if (method.DeclaringType is CLR.Interface)
                {
                    var interfaceTypeArgs = TypeHelpers.Arguments(method.DeclaringType);
                    if (interfaceTypeArgs.Count > 0)
                    {
                        // The method identifier is formed from the method id (now as a string) concatenated with the run-time ids of any interface type arguments
                        var methodExp = default(JST.Expression);
                        var first = true;
                        foreach (var n in interfaceTypeArgs)
                        {
                            if (first)
                            {
                                methodExp = new JST.StringLiteral(methodId.Value + "_");
                                first = false;
                            }
                            else
                                methodExp = new JST.BinaryExpression(methodExp, new JST.Plus(), new JST.StringLiteral("_"));
                            methodExp = new JST.BinaryExpression(methodExp, new JST.Plus(), new JST.IndexExpression(ResolveTypeToIdentifier(n, TypePhase.Names), Constants.ObjectId));
                        }
                        func = new JST.IndexExpression(targetType, methodExp);
                    }
                    else
                        func = new JST.IndexExpression(targetType, methodId);
                }
                else
                    func = new JST.IndexExpression(targetType, methodId);

                // The method may require type arguments
                var typeArgNodes = MethodHelpers.TypeArguments(method);
                if (typeArgNodes.Count > 0)
                {
                    var typeArgExps = new List<JST.Expression>();
                    foreach (var n in typeArgNodes)
                        typeArgExps.Add(new JST.IdentifierExpression(ResolveTypeToIdentifier(n, TypePhase.Constructed)));
                    func = new JST.CallExpression(func, typeArgExps);
                }

                return func;
            }
        }

        public JST.Expression MethodToExpression(JST.Expression targetType, CLR.Method method)
        {
            return PrimMethodToExpression(targetType, method, true);
        }

        public JST.Expression MethodToExpression(CLR.Method method)
        {
            return PrimMethodToExpression(new JST.IdentifierExpression(ResolveTypeToIdentifier(method.DeclaringType, TypePhase.Constructed)), method, true);
        }

        public JST.Expression MethodToSlotExpression(JST.Expression targetType, CLR.Method method)
        {
            return PrimMethodToExpression(targetType, method, false);
        }

        public JST.Expression MethodToSlotExpression(CLR.Method method)
        {
            return PrimMethodToExpression(new JST.IdentifierExpression(ResolveTypeToIdentifier(method.DeclaringType, TypePhase.Slots)), method, false);
        }




        // ----------------------------------------------------------------------
        // Type names
        // ----------------------------------------------------------------------

        // ####################
        // Does type reference refer to the type currently under definition?
        // If hkTypeNode resolves to a first-kinded type definition, return if fkTypeNode and hkTypeNode are the same.
        // If hkTypeNode resolves to a higher-kinded type definition such as:
        //     class C<T, U> { ... }
        // return true if fkTypeNode is C<T, U> or C.
        private static bool IsSelfInstance(CLR.TypeNode fkTypeNode, CLR.TypeNode hkTypeNode)
        {
            if (hkTypeNode == null)
                return false;
            else if (fkTypeNode == hkTypeNode)
                return true;
            else
            {
                var parms = TypeHelpers.Parameters(hkTypeNode);
                var args = TypeHelpers.Arguments(fkTypeNode);
                if (parms != null && parms.Count == args.Count)
                {
                    if (TypeHelpers.Applicand(fkTypeNode) == hkTypeNode)
                    {
                        for (var i = 0; i < parms.Count; i++)
                        {
                            if (parms[i] != args[i])
                                return false;
                        }
                        return true;
                    }
                    else
                        return false;
                }
                else
                    return false;
            }
        }

        // The expression which yields the name or qualified name of type, according to spec in loader.js
        public JST.Expression ResolveTypeToName(CLR.TypeNode typeNode, bool isQualified)
        {
            if (IsSelfInstance(typeNode, TypeScope()))
            {
                var unqual = new JST.IndexExpression(currentTypeId, Constants.TypeName);
                if (isQualified)
                    return new JST.CallExpression(Constants.MakeQualifiedTypeName, new JST.IdentifierExpression(currentAssemblyId), unqual);
                else
                    return unqual;
            }
            else
            {
                switch (TypeHelpers.Classify(typeNode))
                {
                    case TypeFlavor.Void:
                    case TypeFlavor.String:
                    case TypeFlavor.Boolean:
                    case TypeFlavor.Number:
                    case TypeFlavor.Enum:
                    case TypeFlavor.Struct:
                    case TypeFlavor.Nullable:
                    case TypeFlavor.Delegate:
                    case TypeFlavor.Class:
                    case TypeFlavor.Interface:
                        return new JST.StringLiteral(isQualified ? TypeHelpers.QualifiedName(typeNode) : TypeHelpers.Name(typeNode));
                    case TypeFlavor.Application:
                        return ResolveTypeApplicationToName(TypeHelpers.Applicand(typeNode), TypeHelpers.Arguments(typeNode), isQualified);
                    case TypeFlavor.Array:
                    case TypeFlavor.Pointer:
                        throw new InvalidOperationException();
                    case TypeFlavor.Parameter:
                        {
                            var p = new JST.IdentifierExpression(boundTypeVarIds[typeNode]);
                            if (isQualified)
                                return new JST.CallExpression(Constants.MakeQualifiedTypeName, new JST.IndexExpression(p, Constants.TypeAssembly), new JST.IndexExpression(p, Constants.TypeName));
                            else
                                return new JST.CallExpression(Constants.MakeTypeName, new JST.IndexExpression(p, Constants.TypeName));
                        }
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }

        // As above, but with applicand and arguments made explicit.
        public JST.Expression ResolveTypeApplicationToName(CLR.TypeNode applicand, IList<CLR.TypeNode> arguments, bool isQualified)
        {
            if (arguments == null || arguments.Count == 0)
                return ResolveTypeToName(applicand, isQualified);
            else
            {
                switch (TypeHelpers.Classify(applicand))
                {
                    case TypeFlavor.Array:
                        return new JST.BinaryExpression(ResolveTypeToName(arguments[0], true), new JST.Plus(), new JST.StringLiteral("[]"));
                    case TypeFlavor.Pointer:
                        return new JST.BinaryExpression(ResolveTypeToName(arguments[0], true), new JST.Plus(), new JST.StringLiteral("*"));
                    default:
                        {
                            var args = new JST.ArrayLiteral();
                            foreach (var n in arguments)
                                args.Elements.Add(ResolveTypeToName(n, true));
                            if (isQualified)
                                return new JST.CallExpression(Constants.MakeQualifiedTypeName,
                                                              new JST.IdentifierExpression(ResolveAssemblyToIdentifier(applicand.DeclaringModule.ContainingAssembly)),
                                                              ResolveTypeToName(applicand, false),
                                                              args);
                            else
                                return new JST.CallExpression(Constants.MakeTypeName, ResolveTypeToName(applicand, false), args);
                        }
                }
            }
        }



               else if (!env.MethodEnv.IsInterface(methodRef.Definition) && !utils.HasImportAttribute(methodRef.Definition) &&
                         (methodRef.Definition.IsExtern || MethodHelpers.IsNotSupportedSignature(methodRef.Definition)))
                {
                    // ERROR CASE: No implementation to call.
                    logger.NoAugmentationToReplaceCallToNativeMethod(loc, MethodHelpers.QualifiedName(methodRef.Definition));
                    stackManager.ReplaceLinearWithStatements(
                        statements, methodArity, (stmts, _) => {
                            stmts.Add(new JST.ThrowStatement(new JST.CallExpression(Id(localEnv.RootId), Constants.RootNotSupportedExceptionWithMessage, new JST.StringLiteral(env.MethodEnv.QualifiedName(method)))));
)
                    while (methodArity-- > 0)
                        stackManager.PopAndEval(statements);
                    statements.Add(
                    if (MethodHelpers.ReturnsValue(methodRef.Definition))
                        stackManager.Push(jstHelpers.DefaultExpressionForType(method.ReturnType), false);
                }

         // If type definition is of the form class C<X, Y> { ... }, return the type C<X, Y> (which of course
        // is only well-defined within the scope of the definition of C).
        public CLR.TypeNode ToSelf(CLR.TypeNode typeDefn)
        {
            if (!IsDefinition(typeDefn))
                throw new InvalidOperationException("type is not a definition");
            var ps = Parameters(typeDefn);
            if (ps.Count > 0)
            {
                var args = new CLR.TypeNode[ps.Count];
                for (var i = 0; i < ps.Count; i++)
                    args[i] = ps[i];
                return typeDefn.GetTemplateInstance(typeDefn.DeclaringModule, args);
            }
            else
                return typeDefn;
        }



        private void EmitTypeCacheBindings(JST.Statements statements)
        {
            var types = AssemblyHelpers.Types(assembly);
            types.Sort(TypeHelpers.Comparer);

            foreach (var type in types)
            {
                if (TypeHelpers.CanBeCachedInAssembly(type))
                {
                    var localNameSupply = nameSupply.Fork();
                    var typeFieldId = globalMapping.ResolveTypeToFieldId(type);
                    var typeId = localNameSupply.GenSym();
                    var resolveFunction = new JST.FunctionExpression();
                    resolveFunction.Body.Add(new JST.VariableStatement(typeId, new JST.CallExpression(Constants.ResolveType, new JST.IdentifierExpression(currentAssemblyId), stringBindings.For(TypeHelpers.Name(type)), LocalEnv.PhaseExpression(TypePhase.Constructed))));
                    resolveFunction.Body.Add(JST.Statement.Assignment(currentAssemblyId, typeFieldId, new JST.FunctionExpression(new JST.ReturnStatement(new JST.IdentifierExpression(typeId)))));
                    resolveFunction.Body.Add(new JST.ReturnStatement(new JST.IdentifierExpression(typeId)));
                    statements.Add(new JST.CommentStatement(TypeHelpers.Name(type)));
                    statements.Add(JST.Statement.Assignment(currentAssemblyId, typeFieldId, resolveFunction));
                }
            }
        }




            AssemblyLoader =
                serviceProvider.GetService(
                    () => new AssemblyLoader(serviceProvider, true, FrameworkFlavor.Silverlight));
            Logger = serviceProvider.GetService(() => new NullLogger());
            MetaDataManager = serviceProvider.HasService<NodeMetaDataManager>()
                                  ? serviceProvider.GetService<NodeMetaDataManager>()
                                  : null;
            OutputManager = serviceProvider.HasService<OutputManager>()
                                ? serviceProvider.GetService<OutputManager>()
                                : null;
            InteropValidator = new JSInteropValidator(serviceProvider);
            var redistTypes = serviceProvider.GetService(() => new RedistTypes(serviceProvider));
            InteropInfoProvider = new JSInteropInfoProvider(serviceProvider, redistTypes);
            Dependencies = serviceProvider.HasService<Dependencies>()
                               ? serviceProvider.GetService<Dependencies>()
                               : null;


            // ####################
            InteropAssembly = AssemblyLoader.GetAssembly("Interop.dll", Options.DebugMode);
            if (InteropAssembly == null)
                throw new InvalidOperationException("Unable to load interop assembly");



                    return Templates.Expression
                        (nameSupply.Fork(),
                         @"function(obj) {
                                                      var val = obj == null ? null : obj.R();
                                                      if (obj != null && obj.T.Id != $0.Id)
                                                          throw InvalidCastException();
                                                      return NewNullable(val, $1);
                                                  }",
                         new JST.IdentifierExpression(typeBindings.BoundTypeParameters[0]),
                         new JST.IdentifierExpression(currentTypeId));



                var sbId = localEnv.NameSupply.Fork().GenSym();

                Action<JST.Expression> append =
                    expr =>
                    statements.Add
                        (new JST.ExpressionStatement(JST.Expression.DotCall(sbId.ToIE(), Constants.push, expr)));

                // Pull out type's FullName so as to follow .Net reflection naming convention
                statements.Add
                    (JST.Statement.Var(sbId, new JST.ArrayLiteral( + "["))));

                for (var i = 0; i < localEnv.TypeBindings.Count; i++)
                {
                    var typeId = localEnv.TypeBindings[i];
                    if (i > 0)
                        append(new JST.StringLiteral(","));
                    statements.Add
                        (new JST.ExpressionStatement
                             (JST.Expression.DotCall
                                  (localEnv.RootId.ToIE(), Constants.RootPrepareTypeForReflection, typeId.ToIE())));
                    append(new JST.StringLiteral("["));
                    append(JST.Expression.DotCall(typeId.ToIE(), Constants.TypeReflectionFullName));
                    append(new JST.StringLiteral(", "));
                    append(JST.Expression.Dot(typeId.ToIE(), Constants.TypeAssembly, Constants.AssemblyName));
                    append(new JST.StringLiteral("]"));
                }
                append(new JST.StringLiteral("]"));
                return JST.Expression.DotCall(sbId.ToIE(), Constants.join, new JST.StringLiteral(""));


//
// We'll refer to built-in JavaScript objects such as numbers and strings as "atomic objects". We'll assume these
// objects won't be mutated by JavaScript code, and may be made to look like managed objects by setting
// fields in their constructor's prototype. (Obviously JavaScript strings can be mutated, however it would be
// to expensive to represent CLR strings as anything other than JavaScript strings, and we herewith brush this
// issue under the carpet).
//
//
// Our interop allows managed and unmanaged objects to coexist within the runtime, for methods on unmanaged
// objects to be invoked from the managed environment, for methods on managed objects to be invoked from the
// unmanaged environment, and for unmanaged objects to be extended with managed fields and methods.
//
//
// Every supported CLR type is either "normal" or "imported" according to the following rules:
//
//  - the number types and System.String are imported
//  - if T is declared imported and all of its imported methods are over imported types, then T is imported
//  - if T is imported then T[] is imported
//  - if T and U are imported then a delegate from T to U is imported (and similarly for actions and
//    other arities).
//  - if T<_> and U are imported then T<U> is imported (and similarly for other type constructor arities)
//  - all other types are normal
//
//
// Whenever an unmanaged object crosses into managed JavaScript we "wrap" the object according to the
// static type of the crossover point. For example, the result of an imported method is wrapped according
// to the method result type. The argument to an exported method or managed delegate is wrapped according
// to argument type.
//
// Conversely, whenever a managed object crosses into unmanaged JavaScipt we "unwrap" the object
// according to its dynamic type. This occurs for arguments of imported methods, and result of exported
// methods and unmanaged delegates.
//
// We define "wrap" and "unwrap" as follows:


// The root data structure
var LLDT = {};
LLDTMakeRoot(LLDT);



                        {
                            // If invoking C<T, U>::M then the target type will have a slot holding the cached
                            // function M called m<slot for M>, and we may call it directly
                            var slotExpr = new JST.StringLiteral(Constants.TypeCachedMethodSlot(slot));
                            return new JST.IndexExpression(targetType, slotExpr);
                        }


        RETIRED pending replacement for CCI

        // All the inherited virtual and interface methods of type. Inherited virtuals are represented by a
        // method reference to the definition which has not been overridden in the (possibly instantiated)
        // base type. Interface methods are represented by a method references to the definition in the
        // (possibly instantiated) interface type.
        //
        // NOTE: It's possible for an interface method to be inherited from a base type even if no definition
        //       implements that interface in the derived type.
        //
        //     interface IA { void A(); }
        //     interface IB { void B(); }
        //     class C : IA, IB { void A() { } void B() { } }
        //     class D : C { new void A() { } }  (* IB::B is inherited from C::B *)
        //
        // NOTE:
        //
        //     interface I<T> { void A(T t); }
        //     class C : I<int> { void A(int t); }
        //     class D : C, I<bool> { void A(bool t); }
        //        
        //
        // BUG: Given
        //     class B<T> { virtual void M() }
        //     casss D<U, V> : B<V> { override void M() }
        // CCI reports the "Overridden" for D<_, _>::M as B<T>::M instead of B<V>::M.
        // We workaround by tracking all members using the original definitions.
        public IList<CLR.Method> InheritedMethods(CLR.TypeNode typeDefn)
        {
            if (!IsDefinition(typeDefn))
                throw new InvalidOperationException("type is not a definition");

            var res = new List<CLR.Method>();
            // Methods known not to shine through
            //  - For interface methods, on interface 
            var shadowed = new HashSet<CLR.Method>(env.MethodEnv.Comparer);

            // Elliminate methods of supertypes shadowed by methods with definitions in this type
            foreach (var member in typeDefn.Members)
            {
                var method = member as CLR.Method;
                if (method != null)
                {
                    if (method.HiddenMethod != null)
                        
                    ShadowedClosure(shadowed, method);
                }
            }

            // Walk up the base-type chain. Base type may be a type application, in which case the methods
            // we find here are similarly instantiated
            for (var baseType = typeDefn.BaseType; baseType != null; baseType = baseType.BaseType)
            {
                // Include non-shadowed methods, and make sure they shadow methods higher up
                foreach (var member in baseType.Members)
                {
                    var method = member as CLR.Method;
                    if (method != null)
                    {
                        if (method.IsVirtual && !shadowed.Contains(MethodDefn(method)))
                        {
                            res.Add(method);
                        }
                        ShadowedClosure(shadowed, method);
                    }
                }
            }
            return res;
        }




        private static void ShadowedClosure(HashSet<CLR.Method> shadowed, CLR.Method method)
        {
            var hm = method.HiddenMethod;
            if (hm != null)
            {
                shadowed.Add(MethodDefn(hm));
                ShadowedClosure(shadowed, hm);
            }
            var om = method.OverriddenMethod;
            if (om != null)
            {
                shadowed.Add(MethodDefn(om));
                ShadowedClosure(shadowed, om);
            }
        }





            if (method.DeclaringType == type)
            {
                // This method is implemented by this type. Compile it's body now.
                var methodCompiler = new MethodCompiler
                    (serviceProvider,
                     stringBindings,
                     globalMapping,
                     localNameSupply,
                     localTypeBindings,
                     method,
                     currentAssemblyId,
                     currentTypeId);
                impl = methodCompiler.Compile();
            }
            else
                // This virtual method is implemented by a super-type and inherited by this type.
                impl = localTypeBindings.MethodToSlotExpression(method);

            var callables = MethodHelpers.CallableAs(method);
            if (callables.Count != 1)
            {
                // Share the function definition amongst all the slots it is callable as
                var id = localNameSupply.GenSym(); // bound below
                if (serviceProvider.Settings.DebugMode)
                    func.Body.Add(new JST.CommentStatement(MethodHelpers.QualifiedName(method)));
                func.Body.Add(new JST.VariableStatement(id, impl));
                impl = new JST.IdentifierExpression(id);
            }
            // Bind function to all it's slots
            foreach (var callable in callables)
            {
                if (serviceProvider.Settings.DebugMode)
                    func.Body.Add(new JST.CommentStatement(MethodHelpers.QualifiedName(callable)));
                func.Body.Add
                    (JST.Statement.Assignment
                         (localTypeBindings.MethodToSlotExpression
                              (new JST.IdentifierExpression(currentTypeId), callable),
                          impl));
            }


        public static JST.FunctionExpression EtaExpand
            (LocalEnv localEnv,
             Func<IList<JST.Expression>, JST.Statements, JST.Expression> makeCall,
             bool returnsValue,
             IList<JST.Expression> initialArguments,
             int remainingArity)
        {
            var argIds = new List<JST.Identifier>();
            for (var i = 0; i < remainingArity; i++)
                argConstants.Add(localEnv.NameSupply.GenSym());
            var args = new List<JST.Expression>();
            if (initialArguments != null)
            {
                foreach (var a in initialArguments)
                    args.Add(a);
            }
            foreach (var id in argIds)
                args.Add(id.ToIE());
            var func = new JST.FunctionExpression();
            foreach (var id in argIds)
                func.Parameters.Add(id);
            var call = makeCall(args, func.Body);
            if (returnsValue)
                func.Body.Add(new JST.ReturnStatement(call));
            else
                func.Body.Add(new JST.ExpressionStatement(call));
            return func;
        }




        // ----------------------------------------------------------------------
        // Instantiating higher-kinded type at type arguments
        // ----------------------------------------------------------------------

        private JST.Expression InstantiateFunction()
        {
            var nestedLocalEnv = LocalEnv.TypeLocalEnv(localEnv);
            var function = new JST.FunctionExpression();
            foreach (var p in nestedLocalEnv.TypeBindings)
                function.Parameters.Add(p);

            function.Body.Add
                (JST.Statement.Var
                     (nestedLocalEnv.TypeId,
                      JST.Expression.DotCall
                          (nestedLocalEnv.RootId.ToIE(),
                           Constants.RootNewObject,
                           JST.Expression.Dot(nestedLocalEnv.RootId.ToIE(), Constants.RootTypeType))));

            var lhs = nestedLocalEnv.TypeId.ToIE();
            var parent = nestedLocalEnv.TypeConstructorId.ToIE();

            // Assembly
            function.Body.Add(JST.Statement.DotAssignment(lhs, Constants.TypeAssembly, nestedLocalEnv.AssemblyId.ToIE()));

            // Name
            var argQNames = new JST.ArrayLiteral();
            foreach (var p in nestedLocalEnv.TypeBindings)
                argQNames.Add(JST.Expression.Dot(p.ToIE(), Constants.TypeName));
            function.Body.Add
                (JST.Statement.DotAssignment
                     (lhs,
                      Constants.TypeName,
                      JST.Expression.DotCall
                          (nestedLocalEnv.RootId.ToIE(),
                           Constants.RootTypeName,
                           JST.Expression.Dot(parent, Constants.TypeName),
                           argQNames)));



            // ######################################################################

            return function;
        }



        // ----------------------------------------------------------------------
        // Collecting fields, events and methods ready for subsequent compilation (we don't add them till later)
        // ----------------------------------------------------------------------

        private void CollectField(CLR.Field field)
        {
            if (utils.HasNotSupportedAttribute(field))
            {
                if (metaDataManager != null)
                    metaDataManager.MemberMetaData[field].AddNotSupportedDetails(NotSupportedDetails.UserDefined);
            }
            else if (FieldHelpers.IsNotSupported(field))
            {
                if (metaDataManager != null)
                    metaDataManager.MemberMetaData[field].AddNotSupportedDetails(NotSupportedDetails.UnsafeCode);
            }
            else if (field.IsStatic)
                staticFields.Add(field);
            else
                instanceFields.Add(field);
        }

        private void CollectEvent(CLR.Event evnt)
        {
            if (utils.HasNotSupportedAttribute(evnt))
            {
                if (metaDataManager != null)
                    metaDataManager.MemberMetaData[evnt].AddNotSupportedDetails(NotSupportedDetails.UserDefined);
            }
            else if (EventHelpers.IsNotSupported(evnt))
            {
                if (metaDataManager != null)
                    metaDataManager.MemberMetaData[evnt].AddNotSupportedDetails(NotSupportedDetails.UnsafeCode);
            }
            else if (evnt.IsStatic)
                staticEvents.Add(evnt);
            else
                instanceEvents.Add(evnt);
        }

        private void CollectProperty(CLR.Property prop)
        {
            if (utils.HasNotSupportedAttribute(prop))
            {
                if (metaDataManager != null)
                    metaDataManager.MemberMetaData[prop].AddNotSupportedDetails(NotSupportedDetails.UserDefined);
            }
            else if (PropertyHelpers.IsNotSupported(prop))
            {
                if (metaDataManager != null)
                    metaDataManager.MemberMetaData[prop].AddNotSupportedDetails(NotSupportedDetails.UnsafeCode);
            }
            else if (prop.IsStatic)
                staticProperties.Add(prop);
            else
                instanceProperties.Add(prop);
        }

        private void CollectMethod(CLR.Method method)
        {
            if (!(type is CLR.Interface))
            {
                if (method.IsAbstract || (method.Flags & CLR.MethodFlags.PInvokeImpl) != 0)
                {
                    // Ignore
                }
                else if (utils.HasNotSupportedAttribute(method))
                {
                    if (metaDataManager != null)
                        metaDataManager.MemberMetaData[method].AddNotSupportedDetails(NotSupportedDetails.UserDefined);
                }
                else
                {
                    if (!utils.HasImportAttribute(method) && (MethodHelpers.IsNotSupportedSignature(method) || MethodHelpers.IsNotSupportedBody(method)))
                    {
                        if (metaDataManager != null)
                            metaDataManager.MemberMetaData[method].AddNotSupportedDetails(NotSupportedDetails.Unverifiable);
                    }
                    else if (!utils.HasImportAttribute(method) && !(method.DeclaringType is CLR.DelegateNode) && method.IsExtern)
                    {
                        if (metaDataManager != null && !metaDataManager.MemberMetaData[method].IsNotSupported)
                            metaDataManager.MemberMetaData[method].AddNotSupportedDetails(NotSupportedDetails.External);
                    }
                    else
                    {
                        if (MethodHelpers.IsStaticConstructor(method))
                            staticInitializer = (CLR.StaticInitializer)method;
                        else if (MethodHelpers.IsDefaultConstructor(method))
                            defaultConstructor = (CLR.InstanceInitializer)method;
                        methods.Add(method);
                    }
                }
            }
        }

        // ----------------------------------------------------------------------
        // Type helper methods in type structure
        // ----------------------------------------------------------------------

        private JST.Expression InitializeTypeSlotsFunction()
        {
            return MakeFunction(
                (localNameSupply, localTypeBindings, func) =>
                {
                    // All types needed here are only needed to phase 2 (and their type arguments to phase 1)

                    // Static fields are set to the default value of their type or their static initialized value
                    foreach (var field in staticFields)
                        func.Body.Add(JST.Statement.Assignment(localTypeBindings.StaticFieldToSlot(field), DefaultFieldValue(localNameSupply, localTypeBindings, field)));

                    // Methods are defined and bound to their slots
                    foreach (var method in methods)
                    {
                        var impl = default(JST.Expression);
                        if (method.DeclaringType == type)
                        {
                            // This method is implemented by this type. Compile it's body now.
                            var methodCompiler = new MethodCompiler(serviceProvider, stringBindings, globalMapping, localNameSupply, localTypeBindings, method, currentAssemblyId, currentTypeId);
                            impl = methodCompiler.Compile();
                        }
                        else
                            // This virtual method is implemented by a super-type and inherited by this type.
                            impl = localTypeBindings.MethodToSlotExpression(method);

                        var callables = MethodHelpers.CallableAs(method);
                        if (callables.Count != 1)
                        {
                            // Share the function definition amongst all the slots it is callable as
                            var id = localNameSupply.GenSym(); // bound below
                            if (serviceProvider.Settings.DebugMode)
                                func.Body.Add(new JST.CommentStatement(MethodHelpers.QualifiedName(method)));
                            func.Body.Add(new JST.VariableStatement(id, impl));
                            impl = new JST.IdentifierExpression(id);
                        }
                        // Bind function to all it's slots
                        foreach (var callable in callables)
                        {
                            if (serviceProvider.Settings.DebugMode)
                                func.Body.Add(new JST.CommentStatement(MethodHelpers.QualifiedName(callable)));
                            func.Body.Add(JST.Statement.Assignment(localTypeBindings.MethodToSlotExpression(new JST.IdentifierExpression(currentTypeId), callable), impl));
                        }
                    }
                });
        }

        private JST.Expression FinalizeTypeSlotsFunction()
        {
            return MakeFunction(
                (localNameSupply, localTypeBindings, func) =>
                {
                    // Reset all static fields to null (even those of value type)
                    foreach (var field in staticFields)
                        func.Body.Add(JST.Statement.Assignment(localTypeBindings.StaticFieldToSlot(field), new JST.Null()));
                });
        }

        private JST.Expression InvokeStaticConstructorFunction()
        {
            return MakeFunction(
                (localNameSupply, localTypeBindings, func) =>
                {
                    if (staticInitializer != null)
                        func.Body.Add(new JST.ExpressionStatement(new JST.CallExpression(localTypeBindings.MethodToExpression(staticInitializer))));
                });
        }

        private static void AddSupertypes(HashSet<CLR.TypeNode> supertypes, CLR.TypeNode thisType)
        {
            if (!supertypes.Contains(thisType))
            {
                supertypes.Add(thisType);
                if (thisType.BaseType != null)
                    AddSupertypes(supertypes, thisType.BaseType);
                var ifaces = thisType.Interfaces;
                if (ifaces != null)
                {
                    foreach (var iface in ifaces)
                        AddSupertypes(supertypes, iface);

                }
            }
        }

        private JST.Expression EmitSupertypes(JST.Statements statements)
        {
            var supertypes = new HashSet<CLR.TypeNode>(TypeHelpers.Comparer);
            AddSupertypes(supertypes, type);
            var id = nameSupply.GenSym(); // bound below
            var exp = new JST.IdentifierExpression(id);
            statements.Add(new JST.VariableStatement(id, new JST.ObjectLiteral()));
            foreach (var n in supertypes)
                statements.Add(JST.Statement.Assignment(exp, typeBindings.ResolveTypeToName(n, true), new JST.BooleanLiteral(n == type.BaseType)));
            return new JST.IdentifierExpression(id);
        }

        // Build a function which will add (redirections to) exported instance methods into given instance
        private JST.Expression RegisterExports()
        {
            return MakeFunction(
                (localNameSupply, localTypeBindings, func) =>
                {
                    var localAstHelpers = new JSTHelpers(serviceProvider, localTypeBindings, localNameSupply);
                    var instanceId = localNameSupply.GenSym(); // bound by function
                    func.Parameters.Add(instanceId);

                    if (interopInfoProvider.IsExported(type))
                    {
                        var exporter = new Exporter(serviceProvider);
                        exporter.ExportMethods(
                            type,
                            (nestedType, method, exportDetails) =>
                            {
                                if (nestedType == type)
                                {
                                    // If export instance method F, it will expect arguments (instance, arg1, ... argn) but
                                    // will be invoked in JavaScript as instance.F(arg1, ..., argn). So we must construct
                                    // a redirection function.
                                    var redirectFunc = localAstHelpers.EtaExpand((args, _) => new JST.CallExpression(localTypeBindings.MethodToExpression(method), args),
                                                                                 MethodHelpers.ReturnsValue(method),
                                                                                 new List<JST.Expression>() { new JST.This() },
                                                                                 method.Parameters.Count);
                                    func.Body.Add(JST.Statement.Assignment(instanceId, new JST.Identifier(exportDetails.Name), redirectFunc));
                                }
                                // else: this is a method of a nested type, so ignore
                            },
                            delegate { },
                            delegate { });
                    }
                });
        }

        private JST.Expression DynamicTypeMarshaller()
        {
            return utils.GetDynamicTypeMarshallerDetails(type, false);
        }

        private JST.Expression DefaultConstructorFunction()
        {
            if (defaultConstructor == null)
                return new JST.IdentifierExpression(Constants.undefined);
            else
                return MakeFunction(
                    (localNameSupply, localTypeBindings, func) =>
                    {
                        var localAstHelpers = new JSTHelpers(serviceProvider, localTypeBindings, localNameSupply);
                        func.Body.Add(new JST.ReturnStatement(localAstHelpers.ConstructorExpression(func.Body, defaultConstructor, null)));
                    });
        }


        // ----------------------------------------------------------------------
        // Object helper methods in type structure
        // ----------------------------------------------------------------------

        // See loader.js for explanation of these generated functions

        private void AddCloneFields(JST.Statements statements, NameSupply localNameSupply, LocalEnv localTypeBindings, IList<CLR.Field> fields, JST.Expression oldobj, JST.Expression newobj)
        {
            var localAstHelpers = new JSTHelpers(serviceProvider, localTypeBindings, localNameSupply);
            foreach (var field in fields)
            {
                var oldFieldProp = localTypeBindings.InstanceFieldToExpression(oldobj, field);
                var newFieldProp = localTypeBindings.InstanceFieldToExpression(newobj, field);
                statements.Add(JST.Statement.Assignment(newFieldProp, localAstHelpers.CloneExpressionForType(field.Type, oldFieldProp)));
            }
        }

        private JST.Expression CloneFunction()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new NotSupportedException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new NotSupportedException("Pointer type constructor has no definition");
                case TypeFlavor.String:
                case TypeFlavor.Boolean:
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                case TypeFlavor.Delegate:
                case TypeFlavor.Class:
                case TypeFlavor.Interface:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.ReturnStatement(new JST.IdentifierExpression(objId)));
                    });
                case TypeFlavor.Struct:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var oldobjId = localNameSupply.GenSym(); // bound by function
                        var oldobj = new JST.IdentifierExpression(oldobjId);
                        func.Parameters.Add(oldobjId);
                        var newobjId = localNameSupply.GenSym(); // bound below
                        var newobj = new JST.IdentifierExpression(newobjId);
                        func.Body.Add(new JST.VariableStatement(newobjId, new JST.CallExpression(Constants.NewStruct, new JST.IdentifierExpression(currentTypeId))));
                        AddCloneFields(func.Body, localNameSupply, localTypeBindings, instanceFields, oldobj, newobj);
                        func.Body.Add(new JST.ReturnStatement(newobj));
                    });
                case TypeFlavor.Nullable:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var oldobjId = localNameSupply.GenSym();
                        func.Parameters.Add(oldobjId); // bound by function
                        func.Body.Add(
                            new JST.ReturnStatement(new JST.CallExpression(Constants.NewNullable,
                                                                           new JST.IndexExpression(oldobjId, Constants.NullableValue),
                                                                           new JST.IdentifierExpression(currentTypeId))));
                    });
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type flavor");
        }

        private JST.Expression ExpressionForValue(object item, CLR.TypeNode itemType)
        {
            if (item == null)
                return new JST.Null();
            else
            {
                switch (TypeHelpers.Classify(TypeHelpers.Applicand(itemType)))
                {
                    case TypeFlavor.Void:
                        throw new InvalidOperationException("Void is not a type");
                    case TypeFlavor.Application:
                        throw new NotSupportedException("Curried type application");
                    case TypeFlavor.Array:
                        {
                            var arr = (Array)item;
                            var res = new JST.ArrayLiteral();
                            var elemType = TypeHelpers.Arguments(itemType)[0];
                            foreach (var elem in arr)
                                res.Elements.Add(ExpressionForValue(elem, elemType));
                            return res;
                        }
                    case TypeFlavor.String:
                        return stringBindings.For((string)item);
                    case TypeFlavor.Class:
                        throw new NotSupportedException("Class literals");
                    case TypeFlavor.Delegate:
                        throw new NotSupportedException("Delegate literals");
                    case TypeFlavor.Enum:
                        return ExpressionForValue(item, TypeHelpers.Representation(itemType));
                    case TypeFlavor.Interface:
                        throw new InvalidOperationException("Interfaces have no values");
                    case TypeFlavor.Boolean:
                        return new JST.BooleanLiteral((bool)item);
                    case TypeFlavor.Number:
                        {
                            switch (itemType.Name.Name)
                            {
                                case "Int64":
                                    return new JST.NumericLiteral((long)item);
                                case "Int32":
                                    return new JST.NumericLiteral((int)item);
                                case "Int16":
                                    return new JST.NumericLiteral((short)item);
                                case "SByte":
                                    return new JST.NumericLiteral((sbyte)item);
                                case "UInt64":
                                    return new JST.NumericLiteral((ulong)item);
                                case "UInt32":
                                    return new JST.NumericLiteral((uint)item);
                                case "UInt16":
                                    return new JST.NumericLiteral((ushort)item);
                                case "Byte":
                                    return new JST.NumericLiteral((byte)item);
                                case "Double":
                                    return new JST.NumericLiteral((double)item);
                                case "Single":
                                    return new JST.NumericLiteral((float)item);
                                case "Char":
                                    return new JST.NumericLiteral((int)((char)item));
                                default:
                                    throw new NotSupportedException("Unsupported literal type '" + TypeHelpers.QualifiedName(itemType) + "' for  item '" + item.ToString() + "'");
                            }
                        }
                    case TypeFlavor.Pointer:
                        throw new InvalidOperationException("Pointer literal");
                    case TypeFlavor.Parameter:
                        throw new InvalidOperationException("Type parameters have no values");
                    case TypeFlavor.Struct:
                    case TypeFlavor.Nullable:
                        throw new NotSupportedException("Structure literals");
                }
                throw new NotImplementedException("Unrecognised type flavor");
            }
        }

        private JST.Expression DefaultFieldValue(NameSupply localNameSupply, LocalEnv localTypeBindings, CLR.Field field)
        {
            if (field.DefaultValue != null)
                return ExpressionForValue(field.DefaultValue.Value, field.Type);
            else
            {
                var localAstHelpers = new JSTHelpers(serviceProvider, localTypeBindings, localNameSupply);
                return localAstHelpers.DefaultExpressionForType(field.Type);
            }
        }

        private void EmitInstanceFieldInitializers(JST.Statements statements, NameSupply localNameSupply, LocalEnv localTypeBindings, IList<CLR.Field> fields, JST.Expression objBody)
        {
            foreach (var field in fields)
                statements.Add(JST.Statement.Assignment(localTypeBindings.InstanceFieldToExpression(objBody, field), DefaultFieldValue(localNameSupply, localTypeBindings, field)));
        }

        private JST.Expression InitializeInstanceSlotsFunction()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new InvalidOperationException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new InvalidOperationException("Pointer type onstructor has no definition");
                case TypeFlavor.Delegate:
                    return new JST.IdentifierExpression(Constants.NewObject);
                case TypeFlavor.String:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var typeId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(typeId);
                        func.Body.Add(new JST.ReturnStatement(new JST.StringLiteral("")));
                    });
                case TypeFlavor.Boolean:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var typeId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(typeId);
                        func.Body.Add(new JST.ReturnStatement(new JST.NumericLiteral(0)));
                    });
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var typeId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(typeId);
                        func.Body.Add(new JST.ReturnStatement(new JST.NumericLiteral(0)));
                    });
                case TypeFlavor.Struct:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var typeId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(typeId);
                        var objId = localNameSupply.GenSym(); // bound below
                        func.Body.Add(new JST.VariableStatement(objId, new JST.CallExpression(Constants.NewStruct, new JST.IdentifierExpression(typeId))));
                        var objBody = new JST.IdentifierExpression(objId);
                        EmitInstanceFieldInitializers(func.Body, localNameSupply, localTypeBindings, instanceFields, objBody);
                        func.Body.Add(new JST.ReturnStatement(objBody));
                    });
                case TypeFlavor.Interface:
                    return new JST.Null();
                case TypeFlavor.Class:
                    if (type.BaseType == null)
                        // Note that if you change this, there is a direct optimized call for the call to Object.ctor() from other objects that bypasses this below.
                        return new JST.IdentifierExpression(Constants.NewObject);
                    else
                        return MakeFunction((localNameSupply, localTypeBindings, func) =>
                        {
                            var typeId = localNameSupply.GenSym(); // bound by function
                            func.Parameters.Add(typeId);
                            var objId = localNameSupply.GenSym(); // bound below
                            if (type.BaseType == CLR.SystemTypes.Object)
                            {
                                // Note that if you update the logic in this block, don't forgoet to update the type.BaseType == null case above after "case TypeFlavor.Class"
                                func.Body.Add(new JST.VariableStatement(objId, new JST.CallExpression(Constants.NewObject, new JST.IdentifierExpression(typeId))));
                            }
                            else
                            {
                                func.Body.Add(new JST.VariableStatement(objId,
                                                                        new JST.CallExpression(
                                                                            new JST.IdentifierExpression(localTypeBindings.ResolveTypeToIdentifier(type.BaseType, TypePhase.Names)),
                                                                            Constants.TypeInitializeInstanceSlots,
                                                                            new JST.IdentifierExpression(typeId))));
                            }
                            var objBody = new JST.IdentifierExpression(objId);
                            EmitInstanceFieldInitializers(func.Body, localNameSupply, localTypeBindings, instanceFields, objBody);
                            func.Body.Add(new JST.ReturnStatement(objBody));
                        });
                case TypeFlavor.Nullable:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var typeId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(typeId);
                        func.Body.Add(new JST.ReturnStatement(new JST.CallExpression(Constants.NewNullable, new JST.Null(), new JST.IdentifierExpression(currentTypeId))));
                    });
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type category");
        }

        private JST.Expression ReadFunction()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new NotSupportedException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new InvalidOperationException("Pointer type onstructor has no definition");
                case TypeFlavor.Boolean:
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                case TypeFlavor.Struct:
                case TypeFlavor.Nullable:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.ReturnStatement(new JST.CallExpression(new JST.IdentifierExpression(objId), Constants.PointerRead)));
                    });
                case TypeFlavor.String:
                case TypeFlavor.Delegate:
                case TypeFlavor.Class:
                case TypeFlavor.Interface:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.ReturnStatement(new JST.IdentifierExpression(objId)));
                    });
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type flavor");
        }


        private JST.Expression UnboxFunction()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new NotSupportedException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new InvalidOperationException("Pointer type onstructor has no definition");
                case TypeFlavor.Boolean:
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                case TypeFlavor.Struct:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym();
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.IfStatement(new JST.BinaryExpression(new JST.IdentifierExpression(objId), new JST.Equals(), new JST.Null()),
                                                          new JST.ThrowStatement(new JST.CallExpression(Constants.NullReferenceException))));
                        func.Body.Add(
                            new JST.IfStatement(
                                new JST.BinaryExpression(new JST.IndexExpression(new JST.IndexExpression(objId, Constants.ObjectType), Constants.ObjectId),
                                                         new JST.NotEquals(),
                                                         new JST.IndexExpression(currentTypeId, Constants.ObjectId)),
                                new JST.ThrowStatement(new JST.CallExpression(Constants.InvalidCastException))));
                        func.Body.Add(new JST.ReturnStatement(new JST.IdentifierExpression(objId)));
                    });
                case TypeFlavor.Nullable:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym();
                        var valId = localNameSupply.GenSym();
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.VariableStatement(valId,
                                                                new JST.ConditionalExpression(
                                                                    new JST.BinaryExpression(new JST.IdentifierExpression(objId), new JST.Equals(), new JST.Null()),
                                                                    new JST.Null(),
                                                                    new JST.CallExpression(new JST.IdentifierExpression(objId), Constants.PointerRead))));
                        func.Body.Add(
                            new JST.IfStatement(
                                new JST.BinaryExpression(new JST.BinaryExpression(new JST.IdentifierExpression(objId), new JST.NotEquals(), new JST.Null()),
                                                         new JST.LogicalAND(),
                                                         new JST.BinaryExpression(new JST.IndexExpression(new JST.IndexExpression(objId, Constants.ObjectType), Constants.ObjectId),
                                                                                  new JST.NotEquals(),
                                                                                  new JST.IndexExpression(typeBindings.BoundTypeParameters[0], Constants.ObjectId))),
                                new JST.ThrowStatement(new JST.CallExpression(Constants.InvalidCastException))));
                        func.Body.Add(
                            new JST.ReturnStatement(new JST.CallExpression(Constants.NewPointerToValue,
                                                                           new JST.CallExpression(Constants.NewNullable,
                                                                                                  new JST.IdentifierExpression(valId),
                                                                                                  new JST.IdentifierExpression(currentTypeId)),
                                                                           new JST.IdentifierExpression(currentTypeId))));
                    });
                case TypeFlavor.String:
                case TypeFlavor.Delegate:
                case TypeFlavor.Class:
                case TypeFlavor.Interface:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym();
                        func.Parameters.Add(objId);
                        // No-op rather than throw, since we may be unboxing a object of type parameter type
                        func.Body.Add(new JST.ReturnStatement(new JST.IdentifierExpression(objId)));
                    });
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type flavor");
        }

        private JST.Expression BoxFunction()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new NotSupportedException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new InvalidOperationException("Pointer type onstructor has no definition");
                case TypeFlavor.Boolean:
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                case TypeFlavor.Struct:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym();
                        func.Parameters.Add(objId);
                        func.Body.Add(
                            new JST.ReturnStatement(new JST.CallExpression(Constants.NewPointerToValue,
                                                                                    new JST.IdentifierExpression(objId),
                                                                                    new JST.IdentifierExpression(currentTypeId))));
                    });
                case TypeFlavor.String:
                case TypeFlavor.Delegate:
                case TypeFlavor.Class:
                case TypeFlavor.Interface:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym();
                        func.Parameters.Add(objId);
                        // No-op rather than throw, since we may be boxing a object of type parameter type
                        func.Body.Add(new JST.ReturnStatement(new JST.IdentifierExpression(objId)));
                    });
                case TypeFlavor.Nullable:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym();
                        var valId = localNameSupply.GenSym();
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.VariableStatement(valId, new JST.IndexExpression(objId, Constants.NullableValue)));
                        func.Body.Add(
                            new JST.ReturnStatement(new JST.ConditionalExpression(new JST.BinaryExpression(new JST.IdentifierExpression(valId), new JST.Equals(), new JST.Null()),
                                                                                  new JST.Null(),
                                                                                  new JST.CallExpression(Constants.NewPointerToValue,
                                                                                                         new JST.IdentifierExpression(valId),
                                                                                                         new JST.IdentifierExpression(typeBindings.BoundTypeParameters[0])))));
                    });
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type flavor");
        }

        private JST.Expression UnboxAnyFunction()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new NotSupportedException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new InvalidOperationException("Pointer type onstructor has no definition");
                case TypeFlavor.Boolean:
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                case TypeFlavor.Struct:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym();
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.IfStatement(new JST.BinaryExpression(new JST.IdentifierExpression(objId), new JST.Equals(), new JST.Null()),
                                                          new JST.ThrowStatement(new JST.CallExpression(Constants.NullReferenceException))));
                        func.Body.Add(
                            new JST.IfStatement(
                                new JST.BinaryExpression(new JST.IndexExpression(new JST.IndexExpression(objId, Constants.ObjectType), Constants.ObjectId),
                                                         new JST.NotEquals(),
                                                         new JST.IndexExpression(currentTypeId, Constants.ObjectId)),
                                new JST.ThrowStatement(new JST.CallExpression(Constants.InvalidCastException))));
                        func.Body.Add(new JST.ReturnStatement(new JST.CallExpression(new JST.IdentifierExpression(objId), Constants.PointerRead)));
                    });
                case TypeFlavor.Nullable:
                    return Templates.Expression(nameSupply.Fork(),
                                                @"function(obj) {
                                                      var val = obj == null ? null : obj.R();
                                                      if (obj != null && obj.T.Id != $0.Id)
                                                          throw InvalidCastException();
                                                      return NewNullable(val, $1);
                                                  }",
                                                new JST.IdentifierExpression(typeBindings.BoundTypeParameters[0]),
                                                new JST.IdentifierExpression(currentTypeId));
#if false
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                                        {
                                            var objId = localNameSupply.GenSym();
                                            var valId = localNameSupply.GenSym();
                                            func.Parameters.Add(objId);
                                            func.Body.Add(new JST.VariableStatement(valId,
                                                                                    new JST.ConditionalExpression(
                                                                                        new JST.BinaryExpression(new JST.IdentifierExpression(objId), new JST.Equals(), new JST.Null()),
                                                                                        new JST.Null(),
                                                                                        new JST.CallExpression(new JST.IdentifierExpression(objId), Constants.PointerRead))));
                                            func.Body.Add(
                                                new JST.IfStatement(
                                                    new JST.BinaryExpression(new JST.BinaryExpression(new JST.IdentifierExpression(objId), new JST.NotEquals(), new JST.Null()),
                                                                             new JST.LogicalAND(),
                                                                             new JST.BinaryExpression(new JST.IndexExpression(new JST.IndexExpression(objId, Constants.ObjectType), Constants.ObjectId),
                                                                                                      new JST.NotEquals(),
                                                                                                      new JST.IndexExpression(typeBindings.BoundTypeParameters[0], Constants.ObjectId))),
                                                    new JST.ThrowStatement(new JST.CallExpression(Constants.InvalidCastException))));
                                            func.Body.Add(
                                                new JST.ReturnStatement(
                                                    new JST.CallExpression(Constants.NewNullable,
                                                                           new JST.IdentifierExpression(valId),
                                                                           new JST.IdentifierExpression(currentTypeId))));
                                        });
#endif
                case TypeFlavor.String:
                case TypeFlavor.Delegate:
                case TypeFlavor.Class:
                case TypeFlavor.Interface:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym();
                        func.Parameters.Add(objId);
                        func.Body.Add(
                            new JST.ReturnStatement(new JST.CallExpression(Constants.CastClass, new JST.IdentifierExpression(currentTypeId), new JST.IdentifierExpression(objId))));
                    });
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type flavor");
        }

        private JST.Expression DefaultValueFunction()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new InvalidOperationException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new InvalidOperationException("Pointer type onstructor has no definition");
                case TypeFlavor.Boolean:
                    return MakeFunction((localNameSupply, localTypeBindings, func) => func.Body.Add(new JST.ReturnStatement(new JST.NumericLiteral(0))));
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                    return MakeFunction((localNameSupply, localTypeBindings, func) => func.Body.Add(new JST.ReturnStatement(new JST.NumericLiteral(0))));
                case TypeFlavor.Struct:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym(); // bound below
                        func.Body.Add(new JST.VariableStatement(objId, new JST.CallExpression(Constants.NewStruct, new JST.IdentifierExpression(currentTypeId))));
                        var objBody = new JST.IdentifierExpression(objId);
                        EmitInstanceFieldInitializers(func.Body, localNameSupply, localTypeBindings, instanceFields, objBody);
                        func.Body.Add(new JST.ReturnStatement(objBody));
                    });
                case TypeFlavor.Nullable:
                    return
                        MakeFunction(
                            (localNameSupply, localTypeBindings, func) =>
                            func.Body.Add(new JST.ReturnStatement(new JST.CallExpression(Constants.NewNullable, new JST.Null(), new JST.IdentifierExpression(currentTypeId)))));
                case TypeFlavor.String:
                case TypeFlavor.Interface:
                case TypeFlavor.Class:
                case TypeFlavor.Delegate:
                    return MakeFunction((localNameSupply, localTypeBindings, func) => func.Body.Add(new JST.ReturnStatement(new JST.Null())));
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type category");
        }

        private JST.Expression ConstrainedFunction()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new InvalidOperationException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new InvalidOperationException("Pointer type onstructor has no definition");
                case TypeFlavor.Boolean:
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                case TypeFlavor.Struct:
                case TypeFlavor.Nullable:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.ReturnStatement(new JST.IdentifierExpression(objId)));
                    });
                case TypeFlavor.String:
                case TypeFlavor.Interface:
                case TypeFlavor.Class:
                case TypeFlavor.Delegate:
                    return MakeFunction((localNameSupply, localTypeBindings, func) =>
                    {
                        var objId = localNameSupply.GenSym(); // bound by function
                        func.Parameters.Add(objId);
                        func.Body.Add(new JST.ReturnStatement(new JST.CallExpression(new JST.IdentifierExpression(objId), Constants.PointerRead)));
                    });
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type category");
        }

        private JST.Expression IsValueTypeExpression()
        {
            switch (TypeHelpers.Classify(type))
            {
                case TypeFlavor.Void:
                    return new JST.Null();
                case TypeFlavor.Application:
                    throw new InvalidOperationException("Type applications have no definition");
                case TypeFlavor.Array:
                    throw new InvalidOperationException("Array type constructor has no definition");
                case TypeFlavor.Pointer:
                    throw new InvalidOperationException("Pointer type onstructor has no definition");
                case TypeFlavor.Boolean:
                case TypeFlavor.Number:
                case TypeFlavor.Enum:
                case TypeFlavor.Struct:
                case TypeFlavor.Nullable:
                    return new JST.BooleanLiteral(true);
                case TypeFlavor.String:
                case TypeFlavor.Interface:
                case TypeFlavor.Class:
                case TypeFlavor.Delegate:
                    return new JST.BooleanLiteral(false);
                case TypeFlavor.Parameter:
                    throw new InvalidOperationException("Type parameters have no definition");
            }
            throw new NotImplementedException("Unrecognised type category");
        }

        // ----------------------------------------------------------------------
        // Reflection data (if this is a higher-kinded type, emitted names may contain free type variables)
        // ----------------------------------------------------------------------

        private JST.Expression NameToSlotExpression()
        {
            var obj = new JST.ObjectLiteral();
            foreach (var method in methods)
                obj.Add(new JST.StringLiteral(MethodHelpers.Name(method)), new JST.StringLiteral(globalMapping.ResolveMethodToIdentifier(method).Value));
            foreach (var field in staticFields)
                obj.Add(new JST.StringLiteral(FieldHelpers.Name(field)), new JST.StringLiteral(globalMapping.ResolveFieldToIdentifier(field).Value));
            foreach (var field in instanceFields)
                obj.Add(new JST.StringLiteral(FieldHelpers.Name(field)), new JST.StringLiteral(globalMapping.ResolveFieldToIdentifier(field).Value));
            // Exclude events and properties
            return obj;
        }

        private JST.Expression PartialToFullNameExpression()
        {
            var obj = new JST.ObjectLiteral();
            foreach (var method in methods)
            {
                var partialName = new JST.StringLiteral(MethodHelpers.NameWithoutReturnType(method));
                if (obj.Contains(partialName))
                {
                    obj.Remove(partialName);
                    obj.Add(partialName, new JST.Null());
                }
                else
                {
                    var fullName = new JST.StringLiteral(MethodHelpers.Name(method));
                    obj.Add(partialName, fullName);
                }
            }
            return obj;
        }

        private JST.Expression SimpleToFullNameExpression()
        {
            var overloads = new Dictionary<string, CLR.Member>(StringComparer.Ordinal);
            Action<CLR.Member> add =
                member =>
                {
                    if (overloads.ContainsKey(member.Name.Name))
                        overloads[member.Name.Name] = null;
                    else
                        overloads.Add(member.Name.Name, member);
                };

            foreach (var method in methods)
                add(method);
            foreach (var field in staticFields)
                add(field);
            foreach (var field in instanceFields)
                add(field);
            foreach (var evnt in staticEvents)
                add(evnt);
            foreach (var evnt in instanceEvents)
                add(evnt);
            // This is the only place we care about properties
            foreach (var prop in staticProperties)
                add(prop);
            foreach (var prop in instanceProperties)
                add(prop);

            var obj = new JST.ObjectLiteral();
            foreach (var kv in overloads)
            {
                var member = kv.Value;
                var key = new JST.StringLiteral(kv.Key);
                if (member == null)
                    obj.Add(key, new JST.Null());
                else
                    obj.Add(key, new JST.StringLiteral(MemberHelpers.Name(member)));
            }

            return obj;
        }

        private JST.Expression VirtualSlotsExpression()
        {
            var obj = new JST.ObjectLiteral();
            foreach (var method in methods)
            {
                if (method.IsVirtual)
                    obj.Add(new JST.StringLiteral(globalMapping.ResolveMethodToIdentifier(method).Value), new JST.BooleanLiteral(true));
            }
            return obj;
        }

        private JST.Expression ReflectionTypeFullNameExpression(NameSupply namesupply)
        {
            var localNameSupply = nameSupply.Fork();
            var func = new JST.FunctionExpression();
            var parameters = TypeHelpers.Parameters(type);
            var nrOfTypeParameters = parameters != null ? parameters.Count : 0;

            if (nrOfTypeParameters == 0)
            {
                func.Body.Add(new JST.ReturnStatement(new JST.StringLiteral(type.FullName)));
            }
            else
            {
                var sbIdentifier = localNameSupply.GenSym();

                Action<JST.Statements, JST.Expression> generatePush = (statements, expr) =>
                    statements.Add(new JST.ExpressionStatement(new JST.CallExpression(new JST.IndexExpression(sbIdentifier, Constants.push), expr)));

                func.Body.Add(new JST.VariableStatement(sbIdentifier, new JST.ArrayLiteral()));
                generatePush(func.Body, new JST.StringLiteral(type.FullName));
                generatePush(func.Body, new JST.StringLiteral("["));

                var argumentIdentifier = localNameSupply.GenSym();
                func.Body.Add(new JST.VariableStatement(argumentIdentifier));

                for (int currentArgument = 0; currentArgument < nrOfTypeParameters; currentArgument++)
                {
                    func.Body.Add(new JST.ExpressionStatement(new JST.BinaryExpression(
                        new JST.IdentifierExpression(argumentIdentifier),
                        new JST.Assignment(),
                        new JST.IndexExpression(
                            new JST.IndexExpression(currentTypeId, Constants.TypeArguments),
                            new JST.NumericLiteral(currentArgument)))));

                    if (currentArgument > 0)
                    {
                        generatePush(func.Body, new JST.StringLiteral(","));
                    }

                    func.Body.Add(new JST.ExpressionStatement(new JST.CallExpression(Constants.PrepareTypeForReflection, new JST.IdentifierExpression(argumentIdentifier))));
                    generatePush(func.Body, new JST.StringLiteral("["));
                    generatePush(func.Body, new JST.CallExpression(new JST.IndexExpression(argumentIdentifier, Constants.ReflectionTypeFullName)));
                    generatePush(func.Body, new JST.StringLiteral(", "));
                    generatePush(func.Body, new JST.IndexExpression(new JST.IndexExpression(argumentIdentifier, Constants.TypeAssembly), Constants.AssemblyName));
                    generatePush(func.Body, new JST.StringLiteral("]"));
                }
                generatePush(func.Body, new JST.StringLiteral("]"));
                func.Body.Add(new JST.ReturnStatement(new JST.CallExpression(new JST.IndexExpression(sbIdentifier, Constants.join), new JST.StringLiteral(""))));
            }
            return func;
        }


        private JST.Expression ReflectionTypeNamespaceExpression()
        {
            var currentType = type;
            while (currentType.Namespace != null && currentType.DeclaringType != null)
            {
                currentType = currentType.DeclaringType;
            }
            var namespaceName = currentType.Namespace.Name;

            return new JST.StringLiteral(namespaceName);
        }

        private void EmitReflectionBindings()
        {
            var env = localEnv.Env;
            var function = new JST.FunctionExpression();
            function.Parameters.Add(localEnv.RootId);

            function.Body.Add
                (JST.Statement.Var
                     (localEnv.AssemblyId,
                      JST.Expression.DotCall
                          (localEnv.RootId.ToIE(),
                           Constants.RootResolveAssembly,
                           new JST.StringLiteral(env.AssemblyEnv.Name(env.TypeEnv.Assembly(typeDefn))))));
            var slot = env.GlobalMapping.ResolveTypeDefinitionToSlot(typeDefn);
            if (env.TypeEnv.Arity(typeDefn) > 0)
            {
                var slotId = new JST.Identifier(Constants.AssemblyTypeConstructorBuilderSlot(slot))
                function.Body.Add
                    (JST.Statement.Var
                         (localEnv.TypeConstructorId, JST.Expression.DotCall(localEnv.AssemblyId.ToIE(), slotId)));
            }
            else
            {
                var slotId = new JST.Identifier(Constants.AssemblyTypeBuilderSlot(slot));
                function.Body.Add
                    (JST.Statement.Var
                         (localEnv.TypeConstructorId,
                          JST.Expression.DotCall
                              (localEnv.AssemblyId.ToIE(), slotId, LocalEnv.PhaseExpression(TypePhase.Names))));
            }

            var lhs = localEnv.TypeConstructorId.ToIE();
            function.Body.Add
                (JST.Statement.DotAssignment
                     (lhs, Constants.TypeReflectionTypeName, new JST.StringLiteral(typeDefn.Name.Name)));
            function.Body.Add
                (JST.Statement.DotAssignment
                     (lhs, Constants.TypeReflectionTypeNamespace, ReflectionTypeNamespaceExpression()));
            function.Body.Add
                (JST.Statement.DotAssignment
                     (lhs, Constants.TypeReflectionTypeFullName, ReflectionTypeFullNameExpression(localNameSupply)));
            function.Body.Add(JST.Statement.DotAssignment(lhs, Constants.TypeNameToSlot, NameToSlotExpression()));
            function.Body.Add
                (JST.Statement.DotAssignment(lhs, Constants.TypePartialToFullName, PartialToFullNameExpression()));
            function.Body.Add
                (JST.Statement.DotAssignment(lhs, Constants.TypeSimpleToFullName, SimpleToFullNameExpression()));
            function.Body.Add(JST.Statement.DotAssignment(lhs, Constants.TypeVirtualSlots, VirtualSlotsExpression()));


            var program = new JST.Program();
            program.Body.Add(JST.Statement.Assignment(Constants.It, function));
            program.ToFile(ReflectionFileName(), env.Options.DebugMode);
        }


//    Export(method : Method) : JavaScript =
//        let x = JavaScriptApplicand(method, method.Name) in
//        let t = <type structure for method.DeclaringType> in
//        let at1 = <type structure for method argument 1> in
//        ...
//        let rt = <type structure for method result> in
//        let f = <compiled method> in
//        if member.IsStatic then
//            "x = function(a1, ..., an) { return rt.Export(f(at1.Import(a1), ..., atn.Import(an))); }"
//        else
//            "x = function(a1, ..., an) { return rt.Export(f(t.Import(this), at1.Import(a1), ..., atn.Import(an))); }"




//            let doadd = if adder.AddEvent != null then
//                            let f = JavaScriptApplicand(adder.DeclaringEvent, adder.DeclaringEvent.AddEvent) in
//                            "f(target, function(y1, ..., ym) { return target.slot(y1, ..., ym); })"
//                        else
//                            let x = JavaScriptApplicand(adder.DeclaringEvent, adder.DeclaringEvent.Script) in
//                            "target.x = function(y1, ..., ym) { return target.slot(y1, ..., ym); }" in
//            "if (target.slot == null) {
//                 target.slot = a0;
//                 doadd;
//             }
//             else
//                 target.slot = root.CombineDelegates(target.slot, a0)"



//            (* if remover.IsStatic then i should be the type
//            let target = if i == null && remover.IsStatic then
//                             <type structure for remover.DeclaringType>
//                         else i != null && !remover.IsStatic then
//                             i
//                         else
//                             INVALID in
//            if remover.RemoveEvent != null then
//                let f = JavaScriptApplicand(remover.DeclaringEvent,
//                                            remover.DeclaringEvent.RemoveEvent) in
//                "if (target.slot == null)
//                     throw root.InvalidOperationException();
//                 else {
//                     target.slot = root.RemoveAllDelegates(target.slot, a0);
//                     if (target.slot == null)
//                         f(target, null)
//                 }"
//            else
//                let x = JavaScriptApplicand(remover.DeclaringEvent, remover.DeclaringEvent.Script) in
//                "if (target.x == null)
//                     throw root.InvalidOperationException();
//                 else
//                     target.x = root.RemoveAllDelegates(target.x, a0);"
//


    Import(getter : PropertyGetter) : Expression =
        if scope of ImportAttribute of getter is 'Property' then
            let n = <arity of getter> in
            if n == 0 then
                let f = JavaScriptApplicand(getter.DeclaringProperty, getter.DeclaringProperty.Script) in
                if getter.IsStatic then
                    getter.Script := "function () { return f; }";
                else
                    getter.Script := "function (i) { return i.f; }";
            else if n == 1 && getter.Script == null && !getter.IsStatic then
                getter.Script := function (i, x) { return i[x]; }";
        Import((Method)getter);


        if scope of ImportAttribute of getter is 'PropertyGetter' then
            Import((Method)getter)
        else
            let n = <arity of getter> in
            let at1 = <type structure of getter argument 1 type> in
            ...
            let atn = <type structure of getter argument n type> in
            let rt = <type structure of getter return type> in
            let t = <type structure of getter.DeclaringType> in
            if n == 0 then
                let f = JavaScriptApplicand(getter.DeclaringProperty, getter.DeclaringProperty.Script) in
                if getter.IsStatic then
                    "function () { return rt.Import(f); }"
                else
                    "function (i) { return rt.Import(t.Export(i).f); }"
            else if n == 1 && getter.Script == null && !getter.IsStatic then
                "function (i, x1) { return rt.Import(t.Export(i)[at1.Export(x1)]); }"
            else
                INVALID


    Import(setter : PropertySetter) : Expression =
        if scope of ImportAttribute of setter is 'PropertySetter' then
            Import((Method)setter)
        else
            let n = <arity of setter> in
            let at1 = <type structure of getter argument 1 type> in
            ...
            let atn = <type structure of getter argument n type> in
            let rt = <type structure of getter return type> in
            let t = <type structure of getter.DeclaringType> in
            if n == 1 then
                let f = JavaScriptApplicand(setter.DeclaringProperty, setter.DeclaringProperty.Script) in
                if setter.IsStatic then
                    "function(x1) { f = at1.Export(x); }"
                else
                    "function(i, x1) { t.Export(i).f = at1.Export(x1); }"
            else if n == 2 && setter.Script == null && !setter.IsStatic then
                "function(i, x1, x2) { t.Export(i)[at1.Export(x1)] = at2.Export(x2); }"
            else
                INVALID


        // ----------------------------------------------------------------------
        // Properties
        // ----------------------------------------------------------------------

        public bool IsSupported(CLR.Property prop)
        {
            return (prop.Getter == null || FindAttribute(prop.Getter, IsNotSupportedAttribute) == null) &&
                   (prop.Setter == null || FindAttribute(prop.Setter, IsNotSupportedAttribute) == null);
        }

        public bool IsGetterImported(CLR.Property prop)
        {
            if (prop.Getter == null)
                return false;
            else
            {
                var node = FindGetterAttribute(prop, IsImportAttribute);
                if (node == (CLR.Node)prop.Getter || node == (CLR.Node)prop)
                    return true;
                else if (node != null)
                    return prop.Getter.IsExtern;
                else
                    return false;
            }
        }

        public bool IsSetterImported(CLR.Property prop)
        {
            if (prop.Setter == null)
                return false;
            else
            {
                var node = FindSetterAttribute(prop, IsImportAttribute);
                if (node == (CLR.Node)prop.Setter || node == (CLR.Node)prop)
                    return true;
                else if (node != null)
                    return prop.Setter.IsExtern;
                else
                    return false;
            }
        }

        public JST.Expression ImportedGetterFunction(LocalEnv localEnv, CLR.Property prop)
        {
            if (prop.Getter == null)
                throw new ArgumentException();
            return MethodImportedFunction
                (localEnv,
                 prop.Getter,
                 GetterImportScript(localEnv, FindGetterAttribute(prop, IsImportAttribute), prop));
        }

        public JST.Expression ImportedSetterFunction(LocalEnv localEnv, CLR.Property prop)
        {
            if (prop.Setter == null)
                throw new ArgumentException();
            return MethodImportedFunction
                (localEnv,
                 prop.Setter,
                 SetterImportScript(localEnv, FindSetterAttribute(prop, IsImportAttribute), prop));
        }

        public bool IsGetterExported(CLR.Property prop)
        {
            var node = FindGetterAttribute(prop, IsExportAttribute);
            if (node == (CLR.Node)prop.Getter || node == (CLR.Node)prop)
                return true;
            else if (node != null)
                return !prop.Getter.IsExtern;
            else
                return false;
        }

        public bool IsSetterExported(CLR.Property prop)
        {
            var node = FindSetterAttribute(prop, IsExportAttribute);
            if (node == (CLR.Node)prop.Setter || node == (CLR.Node)prop)
                return true;
            else if (node != null)
                return !prop.Setter.IsExtern;
            else
                return false;
        }

        public JST.Expression BindExportGetterFunction(LocalEnv localEnv, CLR.Property prop)
        {
            var node = FindGetterAttribute(prop, IsImportAttribute);
            return MethodExportedFunction(localEnv, prop.Getter, GetterExportScript(localEnv, node, prop));
        }

        public JST.Expression BindExportSetterFunction(LocalEnv localEnv, CLR.Property prop)
        {
            var node = FindSetterAttribute(prop, IsImportAttribute);
            return MethodExportedFunction(localEnv, prop.Setter, SetterExportScript(localEnv, node, prop));
        }

        // ----------------------------------------------------------------------
        // Events
        // ----------------------------------------------------------------------

        public bool IsSupported(CLR.Event evnt)
        {
            return FindAttribute(evnt, IsNotSupportedAttribute) == null;
        }

        public bool IsAdderImported(CLR.Event evnt)
        {
            var node = FindAttribute(evnt, IsImportAttribute);
            if (node == (CLR.Node)evnt)
                return true;
            else if (node != null)
                return evnt.HandlerAdder.IsExtern;
            else
                return false;
        }

        public bool IsRemoverImported(CLR.Event evnt)
        {
            var node = FindAttribute(evnt, IsImportAttribute);
            if (node == (CLR.Node)evnt)
                return true;
            else if (node != null)
                return evnt.HandlerRemover.IsExtern;
            else
                return false;
        }

        public JST.Expression ImportedAdderFunction(CLR.Event evnt)
        {
            throw new NotImplementedException();
        }

        public JST.Expression ImportedRemoverFunction(CLR.Event evnt)
        {
            throw new NotImplementedException();
        }

        public bool IsAdderExported(CLR.Event evnt)
        {
            var node = FindAttribute(evnt, IsExportAttribute);
            if (node == (CLR.Node)evnt)
                return true;
            else if (node != null)
                return !evnt.HandlerAdder.IsExtern;
            else
                return false;
        }

        public bool IsRemoverExported(CLR.Event evnt)
        {
            var node = FindAttribute(evnt, IsExportAttribute);
            if (node == (CLR.Node)evnt)
                return true;
            else if (node != null)
                return !evnt.HandlerRemover.IsExtern;
            else
                return false;
        }

        public JST.Expression BindExportAdderFunction(CLR.Event evnt)
        {
            throw new NotImplementedException();
        }

        public JST.Expression BindExportRemoverFunction(CLR.Event evnt)
        {
            throw new NotImplementedException();
        }



        // ----------------------------------------------------------------------
        // Special method bodies
        // ----------------------------------------------------------------------

        private JST.Expression NativeMethodCall
            (CLR.Method methodCorrespondingToScript,
             JSImportInfo importInfo,
             JST.Expression instance,
             IList<JST.Expression> arguments,
             IList<JST.Expression> typeArguments)
        {
            Debug.Assert
                (importInfo.ScriptType == CLR.NodeType.Method ||
                 importInfo.ScriptType == CLR.NodeType.InstanceInitializer);

            var allArgs = new List<JST.Expression>();

            // parse the script and create the script call
            var scriptMethod = utils.ParseCall
                (methodCorrespondingToScript, importInfo.Script, importInfo.PassInstanceAsArgument);

            // If the import indicates that type parameters also should be passed then append the type arguments.
            if (importInfo.PassTypeParametersAsArguments && typeArguments != null)
            {
                foreach (var typeArg in typeArguments)
                    allArgs.Add(typeArg);
            }

            // If an instance exists, then either pass it to the script method as the first non-type
            // parameter argument or qualify the script method with the instance.
            if (instance != null)
            {
                if (importInfo.PassInstanceAsArgument)
                    allArgs.Add(instance);
                else
                {
                    // qualify the script method with the instance
                    var scriptMethodName = ((JST.IdentifierExpression)scriptMethod).Identifier;
                    scriptMethod = new JST.IndexExpression(instance, scriptMethodName);
                }
            }

            // append the normal arguments
            if (arguments != null)
            {
                foreach (var arg in arguments)
                    allArgs.Add(arg);
            }

            return new JST.CallExpression(scriptMethod, allArgs);
        }

        private JST.Expression GetNativeThisInstance()
        {
            if (MethodDefn.IsStatic)
                return null;
            else if (utils.IsComClass(MethodDefn.DeclaringType))
                return new JST.IndexExpression(function.Parameters[0], Constants.ObjectComInstance);
            else
                return Id(function.Parameters[0]);
        }

        private IList<JST.Expression> CreateTypeArgumentsListForNativeCall(JSImportInfo importInfo)
        {
            var typeArguments = default(List<JST.Expression>);
            // If the import indicates that type parameters also should be passed
            // then append the type parameters of the containing type and the method
            // as normal arguments for the script method.
            if (importInfo.PassTypeParametersAsArguments)
            {
                var type = MethodDefn.DeclaringType;

                var tps = TypeHelpers.Parameters(type);
                var mps = MethodHelpers.TypeParameters(MethodDefn);
                if (tps != null)
                {
                    typeArguments = new List<JST.Expression>();
                    foreach (var tp in tps)
                        typeArguments.Add(Id(localEnv.ResolveTypeToIdentifier(tp, TypePhase.Constructed)));
                }
                if (mps != null)
                {
                    if (typeArguments == null)
                        typeArguments = new List<JST.Expression>();
                    foreach (var tp in mps)
                        typeArguments.Add(Id(localEnv.ResolveTypeToIdentifier(tp, TypePhase.Constructed)));
                }
            }
            return typeArguments;
        }

        private IList<JST.Expression> CreateArgumentsListForNativeCall()
        {
            var arguments = default(List<JST.Expression>);

            if (MethodDefn.Parameters.Count > 0)
            {
                arguments = new List<JST.Expression>();
                // For instance methods, the normal params start at 1 since the the 0th param is the
                // instance for the script method generated for the managed callee method.
                int startParamIndex = MethodDefn.IsStatic ? 0 : 1;
                for (int i = startParamIndex; i < function.Parameters.Count; i++)
                {
                    if (utils.IsComClass(MethodDefn.Parameters[i - startParamIndex].Type))
                        arguments.Add(jstHelpers.ComUnwrap(Id(function.Parameters[i])));
                    else
                        arguments.Add(Id(function.Parameters[i]));
                }
            }
            return arguments;
        }

        private void EmitNativePropertySetterBody(JSImportInfo importInfo)
        {
            if (importInfo.ScriptType == CLR.NodeType.Method)
            {
                // If the 'Import' is on the property accessor itself, then the script maps to
                // a script method and hence treat the accessor as a normal method and generate
                // the call to the script method.
                EmitNativeFunctionBody(importInfo);
            }
            else
            {
                // create the script property reference
                var instance = GetNativeThisInstance();
                var scriptProperty = utils.ParseCall(MethodDefn, importInfo.Script, false);

                if (instance != null)
                    // qualify the script property with the instance
                    scriptProperty = new JST.IndexExpression
                        (instance, ((JST.IdentifierExpression)scriptProperty).Identifier);

                // create the expression that represents the "value" that is passed in
                // to the set.

                // For static methods, "value" is the first parameter of the callee script method
                // generate for the managed setter represented by method. For instance method,
                // it is the second parameter of the callee script method since the first
                // parameter is the instance.
                //
                var value =
                    (JST.Expression)Id(MethodDefn.IsStatic ? function.Parameters[0] : function.Parameters[1]);

                // If the "value" is of a comclass type, then unwrap to access the actual
                // script value
                if (utils.IsComClass(MethodDefn.Parameters[0].Type))
                    value = jstHelpers.ComUnwrap(value);

                // create the assignment to the script property
                function.Body.Add(JST.Statement.Assignment(scriptProperty, value));
            }
        }

        private static JST.Expression ReturnTypeCheck(JST.Identifier retId, bool nullCheck)
        {
            var typeProperty = new JST.IndexExpression(retId, Constants.ObjectType);
            var typeNull = new JST.BinaryExpression(typeProperty, new JST.Equals(), new JST.Null());
            if (nullCheck)
            {
                var rvNotNull = new JST.BinaryExpression(Id(retId), new JST.NotEquals(), new JST.Null());
                return new JST.BinaryExpression(rvNotNull, new JST.LogicalAND(), typeNull);
            }
            else
                return typeNull;
        }

        private void EmitNativePropertyGetterBody(JSImportInfo importInfo)
        {
            if (importInfo.ScriptType == CLR.NodeType.Method)
                // If the 'Import' is on the property accessor itself, then the script maps to
                // a script method and hence treat the accessor as a normal method and generate
                // the call to the script method.
                EmitNativeFunctionBody(importInfo);
            else
            {
                // generate the reference to the script property

                var instance = GetNativeThisInstance();
                var scriptProperty = utils.ParseCall(MethodDefn, importInfo.Script, false);

                if (instance != null)
                    // qualify the script property with the instance
                    scriptProperty = new JST.IndexExpression
                        (instance, ((JST.IdentifierExpression)scriptProperty).Identifier);

                EmitNativeExpressionWithTypeSetter(scriptProperty);
            }
        }

        private void EmitNativeExpressionWithTypeSetter(JST.Expression expression)
        {
            var returnType = MethodDefn.ReturnType;
            if (utils.IsComClass(returnType))
            {
                expression = jstHelpers.EmitComWrap(function.Body, expression, MethodDefn.ReturnType);
            }

            var hasDynamicTypeMarshaller = utils.HasDynamicTypeMarshaller(MethodDefn, true);
            var returnTypeFlavor = TypeHelpers.Classify(MethodDefn.ReturnType);
            if (!hasDynamicTypeMarshaller &&
                (returnTypeFlavor == TypeFlavor.Boolean || returnTypeFlavor == TypeFlavor.Number ||
                 returnTypeFlavor == TypeFlavor.String))
            {
                function.Body.Add(new JST.ReturnStatement(expression));
            }
            else
            {
                var retId = nameSupply.GenSym();
                function.Body.Add(new JST.VariableStatement(retId, expression));

                var then = new JST.Statements();
                function.Body.Add(new JST.IfStatement(ReturnTypeCheck(retId, true), then));

                if (!hasDynamicTypeMarshaller)
                {
                    var localTypeBindings = localEnv.Fork(this.nameSupply, MethodDefn);
                    var typeIdentifier = localTypeBindings.ResolveTypeToIdentifier
                        (MethodDefn.ReturnType, TypePhase.Constructed);

                    localTypeBindings.Emit(then);

                    then.Add(JST.Statement.Assignment(retId, Constants.ObjectType, Id(typeIdentifier)));
                }
                else
                {
                    var dynamicTypeCall = default(JST.Expression);
                    var dymamicTypeDetails = utils.GetDynamicTypeMarshallerDetails(MethodDefn);
                    var arguments = new List<JST.Expression>();
                    arguments.Add(Id(retId));
                    dynamicTypeCall = new JST.CallExpression(dymamicTypeDetails, arguments);

                    var tmpId = nameSupply.GenSym();
                    then.Add
                        (new JST.VariableStatement
                             (tmpId, new JST.CallExpression(Constants.ResolveQualifiedType, dynamicTypeCall)));
                    then.Add
                        (new JST.IfStatement
                             (new JST.BinaryExpression(Id(tmpId), new JST.NotEquals(), new JST.Null()),
                              JST.Statement.Assignment(retId, Constants.ObjectType, Id(tmpId))));
                }
                function.Body.Add(new JST.ReturnStatement(Id(retId)));
            }
        }

        private void EmitNativeEventAdderBody(CLR.Event eventNode, JSImportInfo importInfo)
        {
            // We need to add a level of indirection here since a .Net event delegate can
            // be grown/shrunk whilst a JavaScript event function cannot. So the template is:
            //
            //     function add_eventName(instance, delegate) // instance events
            //     function add_eventName(delegate)           // static events
            //     {
            //         if (<instance/type>.eventName == null)
            //         {
            //             <instance/type>.eventName = delegate;
            //             instance.ScriptEventName =
            //                 function(param1, ..., paramn) {
            //                     if (<instance/type>.eventName == null)
            //                         return null;
            //                     return <instance/type>.eventName(param1, ..., paramn);
            //                 };
            //         }
            //         else
            //             <instance/type>.eventName = CombineDelegates(<instance/type>.eventName, delegate);
            //     }
            //

            Debug.Assert(importInfo != null);

            // Collect arguments and event field
            var scriptInstanceExpression = default(JST.Expression);
            var eventField = default(JST.Expression);
            var delegateValue = default(JST.Expression);
            if (eventNode.IsStatic)
            {
                eventField = localEnv.StaticEventToExpression(eventNode);
                delegateValue = Id(function.Parameters[0]);
            }
            else
            {
                scriptInstanceExpression = GetNativeThisInstance();
                eventField = localEnv.InstanceEventToExpression(Id(function.Parameters[0]), eventNode);
                delegateValue = Id(function.Parameters[1]);
            }

            var then = new JST.Statements();
            then.Add(JST.Statement.Assignment(eventField, delegateValue));

            var wrapperFunction = new JST.FunctionExpression();
            var wrapperArguments = new List<JST.Expression>();
            var dele = (CLR.DelegateNode)eventNode.HandlerType;
            for (var i = 0; i < dele.Parameters.Count; i++)
            {
                var parameterId = nameSupply.GenSym();
                wrapperArguments.Add(Id(parameterId));
                wrapperFunction.Parameters.Add(parameterId);
            }
            wrapperFunction.Body.Add
                (new JST.IfStatement
                     (new JST.BinaryExpression(eventField, new JST.Equals(), new JST.Null()),
                      new JST.ReturnStatement(new JST.Null())));
            wrapperFunction.Body.Add(new JST.ReturnStatement(new JST.CallExpression(eventField, wrapperArguments)));

            if (importInfo.ScriptType == CLR.NodeType.Event)
            {
                // construct the statement that assigns the wrapper function to the script event field
                var scriptEvent = utils.ParseCall(MethodDefn, importInfo.Script, false);
                if (scriptInstanceExpression != null)
                    scriptEvent = new JST.IndexExpression
                        (scriptInstanceExpression, ((JST.IdentifierExpression)scriptEvent).Identifier);
                then.Add(JST.Statement.Assignment(scriptEvent, wrapperFunction));
            }
            else
            {
                Debug.Assert(importInfo.ScriptType == CLR.NodeType.Method);
                // create the expression to invoke the script attached method passing in the wrapper function
                var attachCall = NativeMethodCall
                    (MethodDefn,
                     importInfo,
                     scriptInstanceExpression,
                     new List<JST.Expression> { wrapperFunction },
                     CreateTypeArgumentsListForNativeCall(importInfo));
                then.Add(new JST.ExpressionStatement(attachCall));
            }

            var @else = new JST.Statements();
            @else.Add
                (JST.Statement.Assignment
                     (eventField, new JST.CallExpression(Constants.CombineDelegates, eventField, delegateValue)));

            function.Body.Add
                (new JST.IfStatement
                     (new JST.BinaryExpression(eventField, new JST.Equals(), new JST.Null()), then, @else));
        }

        private void EmitNativeEventRemoverBody(CLR.Event eventNode, JSImportInfo importInfo)
        {
            // As above, need to account for level of indirection. Template:
            //
            //     function remove_eventName(instance, delegate)   // instance event
            //     function remove_eventName(delegate)             // static event
            //     {
            //         if (<instance/type>.eventName != null)
            //         {
            //             <instance/type>.eventName = RemoveAllDelegates(<instance/type>.eventName, delegate);
            //             if (<instance/type>.eventName == null)
            //                 instance.ScriptEventName = null;
            //         }
            //     }
            //

            Debug.Assert(importInfo != null);

            // Collect arguments and event field
            var scriptInstanceExpression = default(JST.Expression);
            var eventField = default(JST.Expression);
            var delegateValue = default(JST.Expression);

            if (eventNode.IsStatic)
            {
                eventField = localEnv.StaticEventToExpression(eventNode);
                delegateValue = Id(function.Parameters[0]);
            }
            else
            {
                scriptInstanceExpression = GetNativeThisInstance();
                eventField = localEnv.InstanceEventToExpression(Id(function.Parameters[0]), eventNode);
                delegateValue = Id(function.Parameters[1]);
            }

            var then = new JST.Statements();
            then.Add
                (JST.Statement.Assignment
                     (eventField, new JST.CallExpression(Constants.RemoveAllDelegates, eventField, delegateValue)));

            var eventNullThen = new JST.Statements();
            if (importInfo.ScriptType == CLR.NodeType.Event)
            {
                // create the statement to assign "null" to the actual script event and add this statement
                // to the inner "then" block
                var scriptEvent = utils.ParseCall(MethodDefn, importInfo.Script, false);
                if (scriptInstanceExpression != null)
                    scriptEvent = new JST.IndexExpression
                        (scriptInstanceExpression, ((JST.IdentifierExpression)scriptEvent).Identifier);
                eventNullThen.Add(JST.Statement.Assignment(scriptEvent, new JST.Null()));
            }
            else
            {
                Debug.Assert(importInfo.ScriptType == CLR.NodeType.Method);

                // create the expression to invoke the script detach method passing in a "null" value
                var detachCall = NativeMethodCall
                    (MethodDefn,
                     importInfo,
                     scriptInstanceExpression,
                     new List<JST.Expression> { new JST.Null() },
                     CreateTypeArgumentsListForNativeCall(importInfo));
                eventNullThen.Add(new JST.ExpressionStatement(detachCall));
            }

            then.Add
                (new JST.IfStatement
                     (new JST.BinaryExpression(eventField, new JST.Equals(), new JST.Null()), eventNullThen));
            function.Body.Add
                (new JST.IfStatement
                     (new JST.BinaryExpression(eventField, new JST.NotEquals(), new JST.Null()), then));
        }


        private void EmitNativeFunctionBody(JSImportInfo importInfo)
        {
            Debug.Assert
                (importInfo.ScriptType == CLR.NodeType.Method ||
                 importInfo.ScriptType == CLR.NodeType.InstanceInitializer);

            if (MethodHelpers.IsConstructor(MethodDefn))
            {
                // instance constructor

                // Create the call expression to invoke the script method
                var callExpression = NativeMethodCall
                    (MethodDefn,
                     importInfo,
                     null,
                     // instance is not passed in to the corresponding script method for a constructors since the
                     // the instance itself is being constructed using the script method
                     CreateArgumentsListForNativeCall(),
                     CreateTypeArgumentsListForNativeCall(importInfo));

                var currentType = MethodDefn.DeclaringType;
                var isExported = interopInfoProvider.IsExported(currentType);

                var instance = Id(function.Parameters[0]);
                if (utils.IsComClass(currentType))
                {
                    // if this is a comclass, then set the returned script object
                    // as member of the current instance rather than modifying
                    // it by setting the type on the script object directly.
                    function.Body.Add(JST.Statement.Assignment(instance, Constants.ObjectComInstance, callExpression));
                    if (isExported)
                        function.Body.Add(RegisterExportsCall(currentType, function.Parameters[0]));
                    function.Body.Add(new JST.ReturnStatement(instance));
                }
                else
                {
                    // copy props from the original instance into the new object and return it
                    // as the actual new instance instead of the original instance passed in.
                    var newInstId = nameSupply.GenSym();
                    function.Body.Add(new JST.VariableStatement(newInstId, callExpression));
                    function.Body.Add
                        (new JST.ExpressionStatement
                             (new JST.CallExpression(Constants.InheritProperties, Id(newInstId), instance)));
                    if (isExported)
                        function.Body.Add(RegisterExportsCall(currentType, newInstId));
                    function.Body.Add(new JST.ReturnStatement(Id(newInstId)));
                }
            }
            else
            {
                // all other methods

                var callExpression = NativeMethodCall
                    (MethodDefn,
                     importInfo,
                     GetNativeThisInstance(),
                     CreateArgumentsListForNativeCall(),
                     CreateTypeArgumentsListForNativeCall(importInfo));

                if (MethodHelpers.ReturnsValue(MethodDefn))
                {
                    EmitNativeExpressionWithTypeSetter(callExpression);
                }
                else
                {
                    function.Body.Add(new JST.ExpressionStatement(callExpression));
                }
            }
        }

        private void EmitNativeMethodBody()
        {
            // If there are 'Import' errors, Validate report the errors and returns false.
            // If there are any errors, don't generate the script implementation.
            if (interopValidator.Validate(MethodDefn))
            {
                var importInfo = interopInfoProvider.GetImportInfo(MethodDefn);
                Debug.Assert(importInfo != null);

                if (MethodDefn.DeclaringMember != null)
                {
                    if (MethodDefn.DeclaringMember is CLR.Property)
                    {
                        var property = (CLR.Property)MethodDefn.DeclaringMember;
                        if (MethodDefn == property.Setter)
                            EmitNativePropertySetterBody(importInfo);
                        else if (MethodDefn == property.Getter)
                            EmitNativePropertyGetterBody(importInfo);
                        else
                            throw new InvalidOperationException
                                ("'Import' attribute unexpected on property accessor " +
                                 MethodHelpers.QualifiedName(MethodDefn));
                    }
                    else if (MethodDefn.DeclaringMember is CLR.Event)
                    {
                        var evnt = (CLR.Event)MethodDefn.DeclaringMember;
                        if (MethodDefn == evnt.HandlerAdder)
                            EmitNativeEventAdderBody(evnt, importInfo);
                        else if (MethodDefn == evnt.HandlerRemover)
                            EmitNativeEventRemoverBody(evnt, importInfo);
                        else
                            throw new InvalidOperationException
                                ("'Import' attribute unexpected on event accessor " +
                                 MethodHelpers.QualifiedName(MethodDefn));
                    }
                    else
                        EmitNativeFunctionBody(importInfo);
                }
                else
                    EmitNativeFunctionBody(importInfo);
            }
        }



        // ----------------------------------------------------------------------
        // Extra info about types
        // ----------------------------------------------------------------------

        private class TypeInfo {
            // For each getter/setter/adder/remover, the containing property/event
            public Dictionary<CLR.Method, CLR.Member> specialParents;
            // Which property is key, or null
            public CLR.Property keyProperty;
        }

        private TypeInfo GetInfo(CLR.TypeNode typeDefn)
        {
            var info = default(TypeInfo);
            if (!typeInfoCache.TryGetValue(typeDefn, out info))
            {
                info = new TypeInfo();
                info.specialParents = new Dictionary<CLR.Method, CLR.Member>(env.MethodEnv.Comparer);
                info.keyProperty = null;
                
                foreach (var prop in env.TypeEnv.Properties(typeDefn))
                {
                    if (prop.Getter != null)
                        info.specialParents.Add(prop.Getter, prop);
                    if (prop.Setter != null)
                        info.specialParents.Add(prop.Setter, prop);
                    if (HasAttribute(prop.Attributes, keyImportName))
                    {
                        if (info.keyProperty == null)
                            info.keyProperty = prop;
                        else
                            throw new ArgumentException();
                    }
                }

                foreach (var evnt in env.TypeEnv.Events(typeDefn))
                {
                    if (evnt.HandlerAdder != null)
                        info.specialParents.Add(evnt.HandlerAdder, evnt);
                    if (evnt.HandlerRemover != null)
                        info.specialParents.Add(evnt.HandlerRemover, evnt);
                }

                typeInfoCache.Add(typeDefn, info);
            }
            return info;
        }





    // Called by user code to add exported functions of assembly into root
    root.RegisterExports = function(assemblyName) {
        var assembly = root.A(assemblyName);
        var f = assembly.RegisterExports;
        // Register exports at most once
        if (f != null) {
            assembly.RegisterExports = undefined;
            f(); // >>> May trigger resolution of more assemblies, types and methods <<<
        }
    };



                         if (!env.MethodEnv.IsStatic(methodDefn))
                             throw new InvalidOperationException("instance methods cannot be exported");
                         if (env.MethodEnv.IsStaticConstructor(methodDefn))
                             throw new InvalidOperationException("static constructors cannot be exported");
                         if (env.MethodEnv.TypeArity(methodDefn) > 0)
                             throw new InvalidOperationException("polymorphic methods cannot be exported");
                         var declType = env.MethodEnv.DeclaringType(methodDefn);
                         if (env.TypeEnv.Arity(declType) > 0)
                             throw new InvalidOperationException
                                 ("methods of higher-kinded types cannot be exported");
                         var methodSlot = env.GlobalMapping.ResolveMethodDefinitionToSlot(methodDefn);
                         var methodSlotId = env.MethodEnv.IsConstructor(methodDefn)
                                                ? new JST.Identifier
                                                      (Constants.TypeExportedConstructorBuilderSlot(methodSlot))
                                                : new JST.Identifier(Constants.TypeMethodBuilderSlot(methodSlot));
                         var typeSlotId = new JST.Identifier
                             (Constants.AssemblyTypeBuilderSlot(env.GlobalMapping.ResolveTypeDefinitionToSlot(declType)));
                         var typeExp = JST.Expression.DotCall
                             (localEnv.AssemblyId.ToE(),
                              typeSlotId,
                              LocalEnv.PhaseExpression(TypePhase.Constructed));
                         var globalId = new JST.Identifier(env.InteropManager.ExportName(methodDefn));
                         function.Body.Add
                             (JST.Statement.DotAssignment
                                  (localEnv.RootId.ToE(), globalId, JST.Expression.DotCall(typeExp, methodSlotId)));


################################### COMPLEX INTEROP #######################################



    CreateArray : int -> object                (* Create an array over this type of given size *)
    ExportArray : object -> object
    ImportArray : object -> object
    GetArrayElement : object -> int -> object  (* Lookup item at index in array over this type *)
    SetArrayElement : object -> int -> object -> ()
                                               (* Set item at index to given value in array over this type *)





Array structure (rank 1 only)
~~~~~~~~~~~~~~~

Arrays are either 'normal' or 'proxies':

Normal arrays are JavaScript arrays with object fields, and a flag to signal that array access may require
import/export:

{
    <is a JavaScript array>
    T : <type structure>      (* As for object, always an instance of the built-in array type constructor *)
    Id : int                  (* As for object *)
    Unmanaged : bool          (* True if array came from unmanaged side and is known to contain elements which need
                                 to be imported/exported on access. *) 
}

Proxy arrays use the representation for 'Open', 'Closed' or 'Keyed' types described below.

Interop between "Managed" and "Unmanaged" JavaScript
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the following we'll call JavaScript outside of our control as "unmanaged", and JavaScript emitted by the
compiler w.r.t. our runtime system as "managed". We wish to allow:
 - Objects created by unmanaged JavaScript to be accessible to the managed world.
 - Objects created by managed JavaScript to be accessible to the unmanaged world.
 - Managed JavaScript to extend the objects of unmanaged JavaScript with additional fields.
To support this, we will "import" objects when they cross from unmanaged to managed so that they may peacefully
coexist with other managed objects in the runtime. Dually, we will "export" objects when they go the other
direction so that unmanaged JavaScript will see them as it expects.

With the above in place, we can import unmanaged JavaScript functions as managed methods, and export managed
methods so that they can be invoked from unmanaged JavaScript.

There are four sources of unmanaged objects:
 - JavaScript proxies for COM-like entities in the host environment, such as XmlHttpRequest. These objects
   generally do not allow additional field bindings. We call these "closed" unmanaged obects.
 - JavaScript objects created and manipulated by third-party JavaScript or the host environment itself.
   The layout of these objects is outside of our control. Fields may be bound within them, but at the risk
   of field name collision. We call these "open" unmanaged objects.
 - JavaScript objects created and manipulated by a combination of mananged and unmanaged code. In this
   case the developer may choose unmanaged field names to avoid collision with managed field names
   and the fields used by the managed runtime system. We call these "merged" objects.
 - JavaScript primitive objects, such as numbers, strings and functions. These objects have no fields by
   default, and generally do not allow any to be added. However they do allow fields to be bound within
   their constructor function prototypes.

When objects cross the mananged/unmanaged boundary we'd like as many of the following properties to hold as
feasible:

 - State 1
     If managed x crosses into unmanaged, clearly the unmanaged fields of x must be preserved.
     However, when it crosses back the managed fields of x must also be preserved:
         forall managed and unmanaged field names f . import(export(x)).f === x.f  (in managed)
         forall unmanaged field names f . export(x).f === x.f     (where lhs is in unmanaged and rhs in managed)

 - State 2
     An unmanaged object should not have its fields extended or altered by managed code:
         forall strings s . x[s] === export(import(x))[s]                          (in unmanaged)
         forall strings s . x[s] === import(export(x))[s]                          (in managed)

 - Reference equality 1
     Reference equality on managed objects should agree with referece equality on unmanaged objects:
         forall managed objects x, y : x === y ==> export(x) === export(y)
         forall unmanaged objects x, y : x === y ==> import(x) === import(y)

 - Reference equality 2
     Reference equality should be preserved over the boundary:
         forall managed objects x . import(export(x)) === x
         forall unmanaged objects x . export(import(x)) === x

 - Strong Subtyping
     Subtyping must be respected over the boundary:
        forall managed objects x .
          if x is instance of T and T is a subtype of U and U is non-normal then
          import(U)(export(T)(x)) === x

 - Weak Subtyping
     Subtyping must be respected over the boundary, but only between types which have the same interop style:
        forall managed objects x .
          if x is instance of T and T is a subtype of U and U and T are both style P (where P is not 'Normal') then
          import(U)(export(T)(x)) === x

Some CLR definitions are clearly inappropriate in the JavaScript world. We allow any assembly, type,
method, field, event or property may be marked as "not supported", which effectively makes those
definitions invisible to programs compiled to JavaScript. Not-supportedness is poisonous: if A
(statically) depends on B and B is not supported then A is not supported. In what follows we assume
not supported definitions have already been removed, and the resulting program is still type correct.

CLR value types are more discriminating than unmanaged JavaScript 'value' types. For example, int has 3
representations in the CLR but only one in JavaScript:

    CLR Type    CLR Value              JavaScript Value
    ----------  ---------              ----------------
    int         i                      i
    int         (exception)            null
    object      boxed i                i
    object      null                   null
    int?        nullable with value i  i
    int?        no-value nullable      null

To support this, we allow import and export to implicitly convert between value, boxed and nullable representations.

CLR arrays require special handling. The CLR ensures arrays over value types are invariant, and thus we never
have to worry about boxing/nullable conversion on array access in the managed world. However, we cannot enfore
this restriction on unmanaged code, and thus when an array crosses from unmanaged to managed we must check if its
elements are consistent with its static type. Furthermore, we wish to extend the above confusion of values, 
nullable values and boxed values to array elements. We will support this using a notion of array proxy.

All types fall into one of five categories:
 - Normal:      Instances are ordinary managed objects, and cross the boundary as themselves (possibly with
                boxing/unboxing and nullable/non-nullable conversions, see below). Instances may only be created
                from the managed side.
 - Merged:      Instances contain both managed and unmanaged fields, and the end developer takes responsibility
                for ensuring unmanaged fields do not clash with fields used by the managed runtime. Instances
                cross the boundary as themselves. Instances may be created from the unmanaged side then passed
                back to the managed side, where they will be completed with default values for managed fields.
 - Keyed:       Instances consist of a managed wrapper around the unmanaged instance. The latter has a designated
                "primary key" field whose value is unique over all unmanaged instances of the type which specified
                the 'Keyed' style (but not necessarily unique over all unmanaged instances in the runtime.)
                Export pulls out the unmanaged instance, while import attempts to find the existing wrapper
                in a global key-to-object map, or construct a new wrapper. If the type implements IDisposable,
                then disposing a managed object also clears any entry for it from the global map.
 - Open:        Instances consist of a managed wrapper around the unmanaged instance, and the latter has
                a single backpointer field to the wrapper. Export pulls out the unmanaged instance, while
                import attempts to find the existing wrapper or construct a new one.
 - Closed:      As for open, but the unmanaged instance does not contain a backpointer. Referential equality
                of managed instances must be decided by referential equality on their contained unmanaged instances.

We have the following validity rules:
 - No type may be declared 'Normal', that is determined by the classification rules below.
 - A type declared P (for P in { 'Merged', 'Keyed', 'Open' }) may derive from a type declared P or 'Normal'.
 - A type declared 'Closed' cannot contain fields, and must either derive from object or have a dynamic
   type function. (It may of course contain imported and exported methods.)
 - Fields may not be imported or exported (however properties, since they are implemented as methods,
   may be imported and exported).
 - Any type may appear in the argument and result types of imported and exported methods, constructors,
   properties and events.
 - Any type may contain imported methods, properties and events.
 - A 'Normal' type cannot contain an imported constructor.
 - Only 'Merged', 'Keyed' and 'Open' types can contain exported instance methods, instance properties
   and instance events.
 - If T has an imported constructor and U is a supertype of T then U must either have an imported constructor
   or contain no fields (either from U or U's supertypes).

We have the following classification rules:
 - All value types, including structs and Nullable<_>, are 'Normal'. Thus structs cannot have unmanaged components.
 - Delegates are 'Open', regardless of their argument and return type (if any).
 - If T is 'Keyed' then T[] is 'Open'. If T is P (for P not 'Keyed') ten T[] is P.
 - If C<_> is P for P in { 'Merged', 'Keyed', 'Open', 'Closed' } then C<T> is P for all types T.
   (Thus builtin arrays have the opposite classification convention than all other higher-kinded types.)
 - If U is P, P is not 'Normal', and T derives from U, then T is P.
 - If T is not covered by above and is annotated as P (for P in { 'Merged', 'Keyed', 'Open', 'Closed' }) then T is P.
 - All other types are 'Normal'. In particular, System.Object and System.String are 'Normal'.

Some CLR types must be handled specially:

 - Nullable<T>: Nullable is special because we must identify "null" with the "no-value" nullable. Export takes
                the "no value" nullable to the "null" JavaScript object, or exports the internal
                value. Import does the converse. T may be any value type other than Nullable<_>, just like
                in the CLR.

 - T[]:         Arrays are special because T[] must use the same managed/unmanaged representation as for T
                (the opposite convention as for all other type constructors).

                If T is 'Normal' or 'Merged' then T[] will be represented by a JavaScript array. On import we
                tag the array itself with a type if not already done so. We also check if the array elements are
                consistent with a managed array. If so, array access can be as for any other CLR array. If not,
                array access must interpose an import/export of the array element. In particular, an array 
                with elements requiring value/nullable/boxed conversions will always be accessed via import/export.
                On export we just return the array unchanged. 
 
                If T is any other style of type then T[] is represented by an unmanaged JavaScript array of
                unmanaged objects on the unmanaged side, and by a array proxy object on the managed side, with
                the managed/unmanaged connection as per T's style. Import creates a new proxy, and export returns
                the underlying array. Array access is always via import/export of the array elements.

                Both of the above managed array representations derive from System.Array. Because 'T' may
	            be a type parameter, we may not know at compile time which representation to use for T[].
	            Thus the type structure for 'T' itself provides the core array methods NewArray, ImportArray,
                ExportArray, GetArrayElement, and SetArrayElement.

 - Delegates:   Delegates are special because we wish to structurally coerce them between their managed and
                unmanaged versions. Export builds a new delegate which imports arguments, invokes the original
                delegate, and exports the result (if any). Import does the converse. Imported/exported wrappers
                keep a pointer to their original to avoid redundant work, using the same field name convention
                as for 'Open' types. Thus delegates appear to be 'Open' types.

We now describe the Import and Export operations for all types. Note that objects are imported and exported
based on their static type and not their dynamic type. For example, an object whose dynamic type is 'Open' may
be exported as object, in which case the managed wrapper is passed to the unmanaged world. In this case, the
object must be imported back as object also.

  - SPECIAL CASE: For Nullable<T>:

     (* XREF1223 *)
     function Import(x) {
         var u = <type structure of Nullable<T>>;
	     var t = <type structure of T>;
	     // The inner import will check x has a known, appropriate type
         return root.NewNullable(x == null ? null : t.Import(x), u);
     }

     (* XREF1229 *)
	 function Export(x) {
	     var t = <type structure of T>;
	     return x.V == null ? null : t.Export(x.V);
     }

 - SPECIAL CASE: For T[], we must redirect to the type structure for T:

     function Import(x) {
         var t = <type structure for T>;
         return t.ImportArray(x);
     }

     function Export(x) {
         var t = <type structure for T>;
         return t.ExportArray(x);
     }

 - SPECIAL CASE: For delegate types (assuming w.l.o.g. single argument and non-void result):

     (* XREF1039 *)
     function Import(f) {
	     var t = <type structure of delegate argument>;
	     var u = <type structure of delegate result>;
         var d = <type structure of delegate>;
         if (f == null)
	         return null;
         if (f._lldt == null)
             f._lldt = root.NewDelegate(null, function(x) { return u.Import(f(t.Export(x))) }, d);
         f._lldt.Instance = f;
         return f._lldt;
     }

     (* XREF1049 *)
     function Export(f) {
	     var t = <type structure of delegate argument>;
	     var u = <type structure of delegate result>;
         var d = <type structure of delegate>;
         if (f == null)
             return null;
         if (f.Instance == null)
             f.Instance = root.NewDelegate(null, function(x) { return u.Export(f(t.Import(x))) }, d);
         f.Instance._lldt = f;
         return f.Instance;
     }

 - For 'Normal' types (other than _[] and Nullable<_>): 

     (* XREF1009 *)
     function Import(x) {
         var t = <type structure of type>;
         // Value types cannot be imported from null
         if (x == null && t.V)
             throw root.NullReferenceException();
         if (x != null) {
             // Must have a type
             if (x.T == null)
                 throw root.InvalidOperationException();
             // Must be appropriately typed
             if (!root.IsAssignableTo(x.T, t))
                 throw root.InvalidCastException();
             // May require boxing
             if (x.T.V && !t.V)
                 x = x.T.B(x);
         }
         return x;
     }

     (* XREF1013 *)
     function Export(x) {
         var t = <type structure of type>;
	     // May require unboxing
         if (x != null && x.T.V && !t.V) 
             x = x.T.A(x);
         return x;
     }

     (* XREF1231 *)
     function ImportArray(x) {
	     var u = <type structure of array of type>;
	     var t = <type structure of type>;
         if (x == null)
             return null;
	     // Must be an array
         if (x.length == null)
             throw root.InvalidCastException();
         // Unlike for other 'Normal' types, assign a type if it is missing
         if (x.T == null)
             x.T = u;
         // If array already had a type then we can check it as per CLR covariance rules
         else if (!root.IsAssignableTo(x.T, u))
             throw root.InvalidCastException();
	     // Unlike for other 'Normal' types, assign an id if it is missing
         if (x.Id == null)
             x.Id = root.NextObjectId++;
         // We can treat array as managed only if it's elements obey the stronger CLR typing rules
         x.Unmanaged = false;
         for (var i = 0; i < x.length; i++) {
             var item = x[i];
             // CLR arrays of value type can't have null entries
             if (t.V && item == null)
	             x.Unmanaged = true;
             else if (item != null) {
                 // Element must have a known type
	             if (item.T == null)
	                 x.Unmanaged = true;
                 // CLR arrays of value type are invariant
                 else if ((item.T.V || t.V) && item.T.Id != t.Id)
                     x.Unmanaged = true;
                 // CLR arrays of reference types are covariant
                 else if (!item.T.V && !t.V && !root.IsAssignableTo(item.T, x.T.Arguments[0]))
	                 x.Unmanaged = true;
             }
         }
	     return x;
     }

     (* XREF1237 *)
     function ExportArray(x) {
         return x;
     }

	 function CreateArray(size) {
         var u = <type structure for array of type>;
         var t = <type structure for type>;
         var arr = new Array(size);
         if (t.V) {
             for (var i = 0; i < size; i++)
                 arr[i] = t.D();
         }
         else {
             var d = t.D();
             for (var i = 0; i < size; i++)
                 arr[i] = d;
         }
         arr.T = u;
         arr.Id = root.NextObjectId++;
  	     arr.Unmanaged = false;
         return arr;
     }

     function GetArrayElement(arr, i) { 
         var t = <type structure for type>;
         // Index must be in range
         if (i < 0 || i >= arr.length)
             throw root.IndexOutOfRangeException();
         return arr.Unmanaged ? t.Import(arr[i]) : arr[i];
     }

     function SetArrayElement(arr, i, item) {
	     var t = <type structure for type>;
         // Index must be in range
	     if (i < 0 || i >= arr.length)
            throw root.IndexOutOfRangeException();
         var expType = arr.T.Argument[0];
         // Arrays of reference type are covariant, so assignment must be valid w.r.t. run-time type
         // Arrays of value type are invariant, so nothing to check
         if (item != null && !expType.V && !root.IsAssignableTo(item.T, expType))
             throw root.ArrayTypeMismatchException();
         if (arr.Unmanaged)
             item = t.Export(item);
         arr[i] = item;
     }



 - For 'Merged' types (other than _[]):

     (* XREF1021 *)
     function Import(x) {
         var t = <type structure of type>;
         if (x != null) {
             // Complete object with type and managed fields initialized to default values
             if (x.T == null) {
                 if (t.DynamicTypeMarshaller != null)
                     x.T = root.ResolveQualifiedType(t.DynamicTypeMarshaller(x));
                 else
                     x.T = t;
                 root.InheritProperties(x, x.T.I(x.T));
             }
             // Must be appropriately typed
             else if (!root.IsAssignableTo(x.T, t))
                 throw root.InvalidCastException();
         }
         return x;
     }

     (* XREF1019 *)
     function Export(x) {
         return x;
     }

 - For 'Keyed' types:

     (* XREF1093 *)
     function Import(x) {
         var t = <type structure of type>;
         var u = <type structure of root type which introduced 'Keyed' style>;
	     var key = <name of key field>;
         if (x == null)
	         return null;
         if (x[key] == null) {
             // Give object a unique key, pair it with a new managed object with fields initialized to default values
             var y = t.I(t);
             y.Instance = x;
             x[key] = y.Id;
             var k = root.QualifiedTypeName(u.Assembly, u.Name) + "::" + x[key];
             root.KeyedObjects[k] = y;
         }
         else {
             // Try to retrieve paired object
             var k = root.QualifiedTypeName(u.Assembly, u.Name) + "::" + x[key];
             var y = root.KeyedObjects[k];
             if (y == null)
             {
	             // Pair with new managed object with fields initialized to default values
                 y = t.I(t);
                 y.Instance = x;
                 root.KeyedObjects[k] = y;
             }
             // Managed object must be appropriately typed
	         else if (!root.IsAssignableTo(y.T, t))
                     throw root.InvalidCastException();
         }
         return y;
     }

     (* XREF1097 *)
     function Export(x) {
         // Object must have been previously imported
	     if (x == null || x.Instance == null)
             throw root.InvalidOperationException();
         return x.Instance;
     }

 - For 'Open' types (other than _[] and delegates):

     (* XREF1033 *)
     function Import(x) {
         var t = <type structure of type>;
         if (x == null)
             return null;
         // Object may need to be paired with new managed object with default field values
         if (x._lldt == null) {
             var u = t;
             if (t.DynamicTypeMarshaller != null)
                 u = root.ResolveQualifiedType(t.DynamicTypeMarshaller(x));
             x._lldt = u.I(u);
         }
         // Managed object should be appropriately typed
         else if (!root.IsAssignableTo(x._lltd.T, t))
             throw root.InvalidCastException();
         x._lldt.Instance = x;
         return x._lldt;
     }

     (* XREF1031 *)
     function Export(x) {
         if (x == null)
             return null;
         // Make sure managed object is paired with an unmanaged object
         if (x.Instance == null) {
             var y = {};
             y._lldt = x;
             x.Instance = y;
         }
         return x.Instance;
     }

 - For 'Closed' types (other than _[]):

     (* XREF1051 *)
     function Import(x) {
         var t = <type structure of type>;
         if (x == null)
             return null;
         // Determine type
         var u = t;
         if (t.DynamicTypeMarshaller != null)
             u = root.ResolveQualifiedType(t.DynamicTypeMarshaller(x));
         // Pair with new managed object (which must not have any fields)
         var y = root.NewObject(u);
         y.Instance = x;
         return y;
     }

     (* XREF1061 *)
     function Export(x) {
	     if (x == null)
	         return null;
         // Make sure managed object is paired with an unmanaged object
         if (x.Instance == null)
             x.Instance = {};
         return x.Instance;
     }


######################################################################


     function GetItem(proxy, i) { 
         var arr = proxy.Instance;
         if (arr == null)
             throw root.NullReferenceException;
         // Index must be in range
         if (i < 0 || i >= arr.length)
             throw root.IndexOutOfRangeException();
         return proxy.T.Argument[0].Import(arr[i]);
     }

     function SetItem(proxy, i, item) {
	     var arr = proxy.Instance;
         if (arr == null)
             throw root.NullReferenceException;
         // Index must be in range
	     if (i < 0 || i >= arr.length)
            throw root.IndexOutOfRangeException();
	     var expType = proxy.T.Argument[0];
	     // Item must be subtype of actual array element type
	     if (item != null && !root.IsAssignableTo(item.T, expType))
             throw root.ArrayTypeMismatchException();
         arr[i] = expType.Export(item);
     }



######################################################################

Given the above we can revisit the desired properties:

                             Normal      Merged      Keyed (5)   Open        Closed
                             ----------  ----------  ----------  ----------  ----------
  State 1                    holds       holds       holds       holds       holds
  State 2                    holds       fails (1)   holds       fails (2)   holds
  Reference equality 1       holds       holds       holds       holds (4)   fails (3)
  Reference equality 2       holds       holds       holds       holds (4)   fails (3)
  Strong subtyping                                     (6)
  Weak subtyping             holds       holds       holds       holds       holds

  Notes: (1) Exporting then importing yields object with same fields.
         (2) We insert a new field into unmanaged object.
         (3) Import always creates a fresh wrapper.
         (4) Except for open delegates.
         (5) However, suffers from potential memory leak.
         (6) Always fails

Methods (static or instance) and constructors (which resemble static methods) are imported and
exported as if they were delegates of the appropriate type. Given this, we can see we reject
imported constructors on normal types because the Import call will always throw.

Interop Attributes
~~~~~~~~~~~~~~~~~~

Custom attributes on declarations influence how the managed and unmanaged JavaScript worlds may interoperate.

The following fragment of JavaScript is accepted as legal scripts in imports:

    FunctionExpression    ::= <as per JavaScript grammar>
    Identifier            ::= <as per JavaScript grammar>
    StringLiteral         ::= <as per JavaScript grammar>
    DottedExpression      ::= PropertyName
                            | DottedExpression '.' Identifier
                            | DottedExpression '[' NumericLiteral ']'
                            | DottedExpression '[' StringLiteral ']'
    Script                ::= <empty>
                            | DottedExpression
                            | FunctionExpression

The custom attributes understood by the compiler are as follows:

    InteropAttributes     ::= ('[' InteropAttribute ']')*
    InteropAttribute      ::= InteropTypeAttribute
                            | ImportAttribute
                            | ExportAttribute
                            | NotSupportedAttribute
                            | DynamicTypeAttribute
                            | NotExportedAttribute

    InteropTypeAttribute  ::= 'InteropType' '(' (InteropTypeProperty (',' InteropTypeProperty)*)? ')'
    NamingAttribute       ::= 'Naming' '(' (NamingProperty (',' NamingProperty)*)? ')'
    ImportAttribute       ::= ('Import' | 'GetImport' | 'SetImport' | 'AddImport' | 'RemoveImport' | 'KeyImport')
                              '(' (ImportProperty (',' ImportProperty)*)? ')'
    ExportAttribute       ::= ('Export' | 'GetExport' | 'SetExport' | 'AddExport' | 'RemoveExport')
                              '(' (ExportProperty (',' ExportProperty)*)? ')'
    NotSupportedAttribute ::= 'NotSupported' '(' (NotSupportedProperty, (',' NotSupportedProperty)*)? ')'
    DynamicTypeAttribute  ::= 'DynamicType' '(' (DynamicTypeProperty, (',' DynamicTypeProperty)*)? ')'
    NotExportedAttribute  ::= 'NotExported'

    NamingProperty        ::= 'JavaScriptNamespace' '=' NamingConvention
                            | 'ScriptNamespaceCasing' '=' Casing
                            | 'ScriptTypeNameCasing' '=' Casing
                            | 'ScriptPrefixNameCasing' '=' Casing
                            | 'ScriptMemberNameCasing' '=' Casing
                            | 'RemoveAccessorUnderscore' '=' bool
    InteropTypeProperty   ::= 'Style' '=' Style
    ImportProperty        ::= 'Script' '=' Script
                            | 'PassRootAsArgument' '=' bool
                            | 'PassInstanceAsArgument' '='  bool
                            | 'ObjectInitialization' '=' ObjectInitialization
                            | NamingProperty
    NotSupportedProperty  ::= 'Reason' '=' string
    ExportProperty        ::= 'Script' '=' DottedExpression
                            | 'PassRootAsArgument' '=' bool
                            | NamingProperty
    DynamicTypeProoperty  ::= 'Script' '=' Script

    (* Determines how managed and unmaneged objects are correlated at runtime. See the previous section. *)
    Style                 ::= 'Normal'
                            | 'Keyed'
                            | 'Merged'
                            | 'Open'
                            | 'Closed'
    (* Determines the body of an imported constructor when it does not specify a Script *)
    ObjectInitialization  ::= 'ConstructorCall'
                            | 'ObjectLiteral'
                            | 'ArrayLiteral'
    (* Indicates how the first letter of the various components of CLR-derived names should be capitalized. *)
    Casing                ::= 'Exact'
                            | 'Camel'     (* lower *)
                            | 'Pascal'    (* upper *)
    (* Indicates how the names of static members should be further qualified *)
    NamingConvention      ::= 'FullyQualifed'
                            | 'TypeNameOnly'
                            | 'Global'
    (* Captures why a member cannot be supported when targetting JavaScript *)
    Reason                ::= 'UserDefined'
                            | 'UnsafeCode'
                            | 'UsesMultiDimArray'
                            | 'External'
                            | 'Unverifiable'
                            | 'UsesNotSupportedMember'
                            | 'UsesNotSupportedType'
                            | 'UsesNotSupportedAssembly'

If a attribute has positional arguments, they are considered equivalent to the following property binding forms:

  InteropType(s, ...)    ==> InteropStyle(Style = s, ...)
  Import(str, ...)       ==> Import(Script = str, ...) (* similarly for the other import names *)
  Export(str, ...)       ==> Export(Script = str, ...) (* similarly for the other export names *)
  NotSupported(str, ...) ==> NotSupported(Reason = str, ...)
  DynamicType(str, ...)  ==> DynamicType(Script = str, ...)

InteropAttributes may be declared at any of the following CLR scopes:
 - Assembly
 - Member, which includes the specialized scopes:
    - Type
    - Property
    - Event
    - Method, which includes the specialized scopes:
       - InstanceInitializer
       - PropertyGetter
       - PropertySetter
       - EventAdder
       - EventRemover

Properties have some special cases for convenience:

    [Import]extern int this[int i] { get; set; }
        ==> implement as index into unmanaged JavaScript object

    [Import]extern int G { get; set; }
        ==> use "G" (after name adjustment) as name of field on unmanaged object
            (similarly for static properties)

    extern int G { [Import]get; [Import]set;}
 == [GetImport][SetImport]extern int G { get; set; }
        ==> use imported "get_G" and "set_G" functions (after name adjustment) to implement property

    [Import(Script = "g")]extern int G { get; set; }
        ==> use "g" as name of field on unmanaged object
            (similarly for static properties)

    extern int G { [Import(Script = "get")]get; [Import(Script = "set")]set; }
 == [GetImport(Script = "get")][SetImport(Script = "set")]extern int G { get; set; }
        ==> use imported "get" and "set" functions to implement property
            (similarly for static properties)

    [Export]int G { get; set; }
    int G { [Export]get; [Export]set;}
 == [GetExport][SetExport]int G { get; set; }
        ==> export as "get_G" and "set_G" (after name adjustment)
            (similarly for static properties)

    [Export(Script = "h.g")]int G { get; set; }
        ==> export as "h.get_g" and "h.set_g" (possibly without underscore)
            (similarly for static properties)

    int G { [Export(Script = "get")]get; [Export(Script = "set")]set; }
 == [GetExport(Script = "get")][SetExport(Script = "set")]int G { get; set; }
        ==> export as "get" and "set"
            (similarly for static properties)

Similarly, events have some special cases:

    [Import]extern event T E { add; remove; }
        ==> use "E" (after name adjustment) as name of field holding event handler in unmanaged object
            (similarly for static events)

    [Import(Script = "e")]extern event T E { add; remove; }
        ==> use "e" as name of field holding event handler in unmanaged object
            (similarly for static events)

    [AddImport][RemoveImport]extern event T E { add; remove; }
        ==> use "add_E" and"remove_E" functions (after name adjustment) to install and uninstall
            event handler in unmanaged object
            (similarly for static events)

    [AddImport(Script = "add")][RemoveImport(Script = "remove")]extern event T E { add; remove; }
        ==> use "add" and"remove" functions to install and uninstall event handler in unmanaged object
            (similarly for static events)

    [Export]event T E { add; remove; }
        ==> export as "add_E" and "remove_E" (after name adjustment)
            (similarly for static events)

    [Export Script="h.e"]event T E { add; remove; }
        ==> export as "h.add_e" and "h.remove_e" (possibly without underscore)
            (similarly for static events)

    [AddExport][RemoveExport]event T E { add; remove; }
        ==> export as "add_E" and "remove_E" (after name adjustment)
            (similarly for static events)

    [AddExport(Script = "add")][RemoveExport(Script = "remove")]event T E { add; remove; }
        ==> export as "add" and "remove"
            (similarly for static events)

In the following we assume attributes and properties have been simplified according to these rules:

 - An 'Import' or 'Export' attribute on a PropertyGetter (PropertySetter) is replaced by a 'GetImport' or 'GetExport'
   ('SetImport' or 'SetExport') attribute on the containing Property, with the same properties.

Attributes are subject to the following restrictions:
 - If a node has attributes A and A', then A must not be a sub attribute of A'.
 - 'InteropType' may only appear at Assembly and Type scope.
 - 'KeyImport' may only appear:
     - at Property scope, and;
     - on exactly once such Property per type, and;
     - within types of 'Keyed' style whose base type is not 'Keyed'.
 - 'SetImport', 'GetImport', 'SetExport' and 'GetImport' may only appear at Property scope.
 - 'AddImport', 'RemoveImport', 'AddExport', 'RemoveExport' may only appear at Event scope.

Properties are subject to the following restrictions:
 - 'Script' cannot be bound to a FunctionExpression:
    - on 'Import' attributes at Method scope if the method is virtual.
    - on 'Import' or 'KeyImport' attributes at Property scope (but ok to be a FunctionExpression on 'Import'
      attributes at 'PropertyGetter' and 'PropertySetter' scope, and ok on 'GetImport' and 'SetImport'
      attributes at Property scope).
    - on 'Import' attributes at Events scope (but ok to be a FunctionExpression on 'Import' attributes at
      'EventAdder' and 'EventRemover' scope, and ok on 'AddImport' and 'RemoveImport' attributes at
      Event scope).
 - 'Style' is subject to the constraints discussed in the previous section.

Only monomorphic methods may be exported. However, it is ok for monomorphic methods of higher-kinded types
to be exported, and for polymorphic methods (of higher-kinded or first-kinded types) to be imported. However,
the type arguments of polymorphic methods are not available to their imported unmanaged JavaScript implementations.

We say the the parent of:
 - a top-level Type is its containing Assembly
 - a nested Type is its containing Assembly (and not its declaring Type)
 - an overridding Method is its overridden Method, provided the overridden method is imported
 - a Method (not covered by above), InstanceInitializer, StaticInitializer, Property or Event is its declaring Type
 - a PropertyGetter or PropertySetter is its declaring Property
 - an EventAdder, EventRemover or EventCaller is its declaring Event

The 'sub attribute' relationship is defined as:
 - 'GetImport', 'SetImport', 'AddImport', 'RemoveImport' and 'KeyImport' are sub attributes of 'Import'.
 - similarly for the export attribute family.
 - 'Import' and 'Export' are sub attributes of 'Naming'.
 - plus reflexivity and transitivity.

We say node N has attribute A, written N.IsA, iff
 - N has an attribute A', where A' is a sub attribute of A.
 - otherwise, if N has a parent M, then M has attribute A.
 - otherwise, false.

We say the value of property P of attribute A on node N, written N.A::P, is:
 - the value of P as declared on an attribute A' of node N, where A' is a sub attribute of A.
 - otherwise, if N has a parent M, then the value of property P of attribute A on node M.
 - otherwise the default value for P given by the following table:

    Property                    Value
    --------------------------  ------------------
	Style                       Normal
    Script                      null
    PassRootAsArgument          false
    PassInstanceAsArgument      true
    ObjectInitialization        ConstructorCall
    JavaScriptNamespace         Global
    ScriptNamespaceCasing       Pascal
    ScriptTypeNameCasing        Pascal
    ScriptPrefixNameCasing      Camel
    ScriptMemberNameCasing      Camel
    RemoveAccessorUnderscore    false
    Reason                      null

Often the names of imported JavaScript definitions can be systematically derived from the CLR name
representing them. The 'JavaScriptNamespace', 'ScriptNamespaceCasing', 'ScriptTypeNameCasing',
'ScriptPrefixNameCasing', 'ScriptMemberNameCasing' and 'RemoveAccessorUnderscore' properties allow this
derivation to be controlled.

    Recase(string str, c : Casing) : string =
        if c == 'ExactMatch" then str
        else if c == 'Pascal' then UppercaseFirstChar(str)
        else (* c == 'Camel' *) LowercaseFirstChar(str)

    RecaseMember(member : Member) : DottedIdentifier =
        Recase(member.Name, member.Naming::ScriptMemberNameCasing)

    RecaseType(member : Member) : DottedIdentifier =
        Recase(member.DeclaringType.Name, member.Naming::ScriptTypeNameCasing)

    RecaseProperty(getter : PropertyGetter) : DottedIdentifier =
        Recase(getter.DeclaringProperty.Name, getter.Naming::ScriptMemberNameCasing)

    RecaseProperty(setter : PropertySetter) : DottedIdentifier =
        Recase(setter.DeclaringProperty.Name, setter.Naming::ScriptMemberNameCasing)

    RecaseEvent(adder : EventAdder) : DottedIdentifier =
        Recase(adder.DeclaringEvent.Name, adder.Naming::ScriptMemberNameCasing)

    RecaseEvent(remover : EventRemover) : DottedIdentifier =
        Recase(remover.DeclaringEvent.Name, remover.Naming::ScriptMemberNameCasing)

    ReprefixName(member : Member, prefix : string, id : string) : DottedIdentfier =
        let id' = if id begins with (prefix + "_") then id without initial (prefix + "_") else id in
        return Recase(prefix, member.Naming::ScriptPrefixNameCasing) +
               (member.Naming::RemoveAccessorUnderscore ? "" : "_") +
               Recase(id', member.Naming::ScriptMemberNameCasing)

    ExpandedName(member : Member, prefix : string, d : DottedIdentifier) =
        let id1 '.' ... '.' idn = d in
        let idn' = Recase(prefix, member.Naming::ScriptPrefixNameCasing +
                   (member.Naming::RemoveAccessorUndescore ? "" : "_" ) +
                   idn in
        id1 '.' ... '.' idn-1 '.' idn'

    QualifiedName(member : Member, script : Script) : Script =
        if script is DottedIdentifier && member.IsStatic then
            let t = member.DeclaringType in
            let nc = member.Naming::JavaScriptNamespace in
            if nc == 'Global' then script
            else if nc =='TypeNameOnly' then Recase(t.Name, member.Naming::ScriptTypeNameCasing) '.' script
            else (* nc == 'FullyQualified' *) Recase(t.Namespace, member.Naming::ScriptNamespaceCasing) '.'
                                              Recase(t.Name, member.Naming::ScriptTypeNameCasing) '.' script
        else
            script

We may then define the underlying script representing each imported or exported member:

	FinalImportScript(method : Method, script : Expression) : Expression =
	    if method.Import::PassRootAsArgument then
            let n = <arity of method> in
            "function (x1, ..., xn) { return script(root, x1, ..., xn); }"
        else
            script

    (* XREF1153 *)
    ImportScript(method : Method) : Expression =
        let f = QualifiedName(method, method.Import::Script ?? RecaseMember(method)) in
        if method.IsStatic || f is FunctionExpression || method.Import::PassInstanceAsArgument then
	        FinalImportScript(method, f)
        else
            let n = <arity of method> in
            if method.Import::PassRootAsArgument then
    	        "function (x1, x2, ..., xn) { return x1.f(root, x2, ..., xn); }"
            else
    	        "function (x1, x2, ..., xn) { return x1.f(x2, ..., xn); }"

    FinalExportScript(method : Method, script : Expression) : Expression =
        if script is FunctionExpression then
            if method.Export::PassRootAsArgument then
                if method.IsStatic then
                    "function (v) { script(root, v); }"
                else
                    "function (i, v) { script(root, i, v); }"
            else
                script
        else
            if method.IsStatic then
                "function(v) { script = v; }"
            else
                "function(i, v) { i.script = v; }"

    (* XREF1163 *)
    ExportScript(method : Method) : Expression =
	    FinalExportScript(method, QualifiedName(method, method.Export::Script ?? RecaseMember(method)))

    (* XREF1171 *)
    ImportScript(init : InstanceInitializer) : Expression =
        let n = <arity of init> in
        if init.Import::Script == null then
            let oi = init.Import::ObjectInitialization in
            if oi == 'ArrayLiteral' then
                "function(x2, ..., xn) { return [x2, ..., xn]; }"
            else if oi == 'ObjectLiteral' then
                if n > 1 then
                    undefined
                else
                    "function () { return {}; }"
            else (* oi == 'ConstructorCall' *)
                let f = QualifiedName(init, RecaseType(init)) in
                "function (x2, ..., xn) { return new f(x2, ..., xn); }"
        else if init.Import::Script is a DottedExpression then
            let f = QualifiedName(init, init.Import::Script) in
            "function(x2, ..., xn) { return new f(x2, ..., xn); }"
        else
	        FinalImportScript(init, init.Import::Script)

    (* XREF1181 *)
    ExportScript(init : InstanceInitializer) : Expression =
        let f = QualifiedName(init, init.Export::Script ?? RecaseMember(init)) in
	    if f is FunctionExpression then
            if init.Export::PassRootAsArgument then
                "function (v) { f(root, v); }"
            else
                f
        else
            "function(v) { f = v; }"

    (* XREF1187 *)
    ImportScript(getter : PropertyGetter) : Expression =
        if getter.IsGetImport then
	        FinalImportScript(getter, QualifiedName(getter, getter.Import::Script ?? ReprefixName(getter, "get", getter.Name)))
        else if getter.Import::Script == null && getter.Arity == 2 && !getter.IsStatic then
            "function (i, x) { return i[x]; }"
        else
            let f = QualifiedName(getter, getter.Import::Script ?? RecaseProperty(getter)) in
            if getter.IsStatic && n == 0 then
                "function () { return f; }"
            else if !getter.IsStatic && n == 1 then
                "function (i) { return i.f; }"
            else
                undefined

    ImportScript(setter : PropertySetter) : Expression =
        if setter.IsSetImport then
	        FinalImportScript(setter, QualifiedName(setter, setter.Import::Script ?? ReprefixName(setter, "set", setter.Name)))
        else if setter.Import::Script == null && setter.Arity == 3 && !setter.IsStatic then
            "function (i, x, v) { i[x] = v; }"
        else
            let f = QualifiedName(setter, setter.Import::Script ?? RecaseProperty(setter)) in
            if setter.IsStatic && n == 1 then
                "function (v) { f = v; }"
            else if !setter.IsStatic && n == 2 then
                "function (i, v) { return i.f = v; }"
            else
                undefined

    (* XREF1193 *)
    ExportScript(getter : PropertyGetter) : Expression =
        if getter.IsGetExport then
	        FinalExportScript(getter, QualifiedName(getter, getter.Export::Script ?? ReprefixName(getter, "get", getter.Name)))
        else
	        FinalExportScript(getter, QualifiedName(getter, ExpandedName(getter, "get", getter.Export::Script ?? RecaseProperty(getter))))

    ExportScript(setter : PropertySetter) : Expression =
        if setter.IsSetExport then
            FinalExportScript(setter, QualifiedName(setter, setter.Export::Script ?? ReprefixName(setter, "set", setter.Name)))
        else
	        FinalExportScript(setter, QualifiedName(setter, ExpandedName(setter, "set", setter.Export::Script ?? RecaseProperty(setter))))

    (* XREF1201 *)
    ImportScript(adder : EventAdder) : Expression =
        if adder.IsAddImport then
            FinalImportScript(adder, QualifiedName(adder, adder.Import::Script ?? ReprefixName(adder, "add", adder.Name)))
        else
            let f = QualifiedName(adder, adder.Import::Script ?? RecaseEvent(adder)) in
            if adder.IsStatic then
                "function(d) { f = d; }"
            else
                "function(i, d) { i.f = d; }

    ImportScript(remover : EventRemover) : Expression =
        if remover.IsRemoveImport then
	        FinalImportScript(remover, QualifiedName(remover, remover.Import::Script ?? ReprefixName(remover, "remove", remover.Name)))
        else
            let f = QualifiedName(remover, remover.Import::Script ?? RecaseEvent(remover)) in
            if remover.IsStatic then
                "function(d) { f = d; }"
            else
                "function(i, d) { i.f = d; }"

    (* XREF1213 *)
    ExportScript(adder : EventAdder) : Expression =
        if adder.IsAddExport then
	        FinalExportScript(adder, QualifiedName(adder, adder.Export::Script ?? ReprefixName(adder, "add", adder.Name)))
        else
            FinalExportScript(adder, QualifiedName(adder, ExpandedName(adder, "add", adder.Export::Script ?? RecaseEvent(adder))))

    ExportScript(remover : EventRemover) : Expression =
        if remover.IsRemoveExport then
            FinalExportScript(QualifiedName(adder, remover.Export::Script ?? ReprefixName(remover, "remove", remover.Name)))
        else
            FinalExportScript(QualifiedName(adder, ExpandedName(remover, "remove", remover.Export::Script ?? RecaseEvent(remover))))

We say the key name of type T, written T.Key, is
 - if T has style Keyed and T's base type is not Keyed and T has exactly one non-static property prop with
   the 'Key' attribute, then:
       prop.Import::Script ?? RecaseMember(prop)
 - if T has style Keyed and T's base type U is also Keyed, then the key property of type U.
 - otherwise undefined.

We may ask the following questions of each definition node:

    IsSupported : Node -> bool
        Is definition available to programs when targetting JavaScript?
        If not, all the following are undefined.

    Style : Type -> Style
        What representation style do instance of type use for JavaScript interop?

    IsImported : Node -> bool
        Is definition's implementation supplied by unmanaged JavaScript?
        If not, the result of Import is undefined.

    Import : Node -> Expression
        The JavaScript function representing the imported unmanaged definition, ready to be bound into
        the appropriate managed JavaScript structure and be invoked from the managed world.

    IsExported : Node -> bool
        Is managed definition available to unmanaged JavaScript?
        If not, the result of Export is undefined.

    Export : Node -> Expression
        The JavaScript function which will effect the export by binding the exported definition
        into the global unmanaged JavaScript scope or the unmanaged part corresponding to a managed object.

These questions are answered by the following definitions:

    (*
     * Common
     *)

    (* XREF1103 *)
    (* We may assume all type arguments of method and its declaring type are in scope, and thus
       at1 .. atn and rt will be well-defined w.r.t. the run-time type specialization of the method
       and its declaring type. *)   
    PrimImport(method : Method, script : Expression) : Expression =
        let n = <arity of method> in
        let at1 = <type structure of method argument 1 type> in
        ...
        let atn = <type structure of method argument n type> in
        let rt = <type structure of method result type> in
        let t = <type structure of method.DeclaringType> in
        "function (x1, ..., xn) { return rt.Import(script(at1.Export(x1), ..., atn.Export(xn))); }"

    (* XREF1109 *)
    (* We may assume all type arguments of method's declaring type are in scope, but method itself
       must be monomorphic. *)
    PrimExport(method : Method, script : Expression) : Expression =
        let n = <arity of method> in
        let at1 = <type structure of method argument 1 type> in
        ...
        let atn = <type structure of method argument n type> in
        let rt = <type structure of method result type> in
        let s = <slot for method> in
        let t = <type structure of method.DeclaringType> in
	    if method.IsStatic then
            "function () {
                 script(function(x1, ..., xn) {
                            return rt.Export(t.s(at1.Import(x1), ..., atn.Import(xn)));
                        });
             }"
        else
            "function(x1) {
                 script(t.Export(x1), function(x2, ..., xn) {
                                          return rt.Export(t.s(x1, at1.Import(x2), ..., atn.Export(xn)));
                                      });
             }"

    (*
     * General
     *)

    IsSupported(node : Node) : bool = node.IsNotSupported

    (*
     * Types
     *)

    Style(type : Type) : Style =
        if type.IsInteropType then
            type.InteropType::Style
        else if type.BaseType != null then
            Style(type.BaseType)
        else
            'Normal'

    (*
     * Methods
     *)

    IsImported(method : Method) : bool = method.IsImport && method.IsExtern || method has Import attribute

    Import(method : Method) : Expression = PrimImport(method, ImportScript(method))

    IsExported(method : Method) : bool =
        method.IsExport && !method.IsExtern && !method.IsNotExported ||
        method.IsVirtual && method.OverriddenMethod != null && IsImported(method.MethodWhichIntroducedVirtualSlot)

    Export(method : Method) : Expression = PrimExport(method, ExportScript(method))

    (*
     * Constructors
     *)

    IsImported(init : InstanceInitializer) : bool = init.IsImport && init.IsExtern || init has Import attribute

    (* XREF1117 *)
    Import(init : InstanceInitializer) : Expression =
        let n = <arity of init> in
        let at1 = <type structure of init argument 1 type> in
        ...
        let atn = <type structure of init argument n type> in
        let t = <type structure of init.DeclaringType> in
        let script = ImportScript(init) in
        let obj = "script(at2.Export(x2), ..., atn.Export(xn))" in
        let body = let s = init.DeclaringType.InteropType::Style in
                   if s == 'Merged' then
                       "var j = obj;
                        root.InheritProperties(j, x1);
                        x1 = j"
                   else if s == 'Keyed' then
                       let key = init.DeclaringType.Key in
                       let u = <type structure of type introducing 'Keyed' style> in
                       "var j = obj;
                        if (j.key == null)
                            j.key = x1.Id;
                        root.KeyedObjects[root.QualifiedTypeName(u.Assembly, u.Name) + "::" + j.key] = i;
                        x1.Instance = j"
                   else if s == 'Open' then
                       "var j = obj;
                        j._lldt = x1;
                        x1.Instance = j"
                   else (* s == 'Closed' *)
                       "var j = obj;
                        x1.Instance = j" in
        if init.DeclaringType is a value type then
            "function (p, x2, ..., xn) { var x1 = p.R(); body; }"
        else
            "function (x1, x2, ..., xn) { body; return x1; }"

    IsExported(init : InstanceInitializer) : bool = init.IsExport && !init.IsExtern && !init.IsNotExported

    (* XREF1123 *)
    Export(init : InstanceInitializer) : Expression =
        let n = <arity of init> in
        let at1 = <type structure of init argument 1 type> in
        ...
        let atn = <type structure of init argument n type> in
        let t = <type structure of init.DeclaringType> in
        let s = <slot for init> in
        let body = if init.DeclaringType is a value type then
                       "t.s(root.NewPointerToValue(x1, t), at1.Import(x2), ..., atn.Import(xn));
                        return t.Export(x1)"
                   else
                       "return t.Export(t.s(x1, at1.Import(x2), ..., atn.Import(xn)))" in
        let script = ExportScript(init) in
        "function() {
             script(function(x2, ..., xn) {
                        var x1 = t.I(t);
                        body;
                    });
         }"

    (*
     * Properties
     *)

    IsImported(getter : PropertyGetter) : bool = getter.IsImport && getter.IsExtern || getter has Import attribute

    Import(getter : PropertyGetter) : Expression = PrimImport(getter, ImportScript(getter))

    IsImported(setter : PropertySetter) : bool = setter.IsImport && setter.IsExtern || setter has Import attribute

    Import(setter : PropertySetter) : Expression = PrimImport(setter, ImportScript(setter))

    IsExported(getter : PropertyGetter) : bool = getter.IsExport && !getter.IsExtern && !init.IsNotExported

    Export(getter : PropertyGetter) : Expression = PrimExport(getter, ExportScript(getter))

    IsExported(setter : PropertySetter) : bool = setter.IsExport && !setter.IsExtern && !init.IsNotExported

    Export(setter : PropertySetter) : Expression = PrimExport(setter, ExportScript(setter))

    (*
     * Events
     *)

    IsImported(adder : EventAdder) : bool = adder.IsImport && adder.IsExtern || adder has Import attribute

    (* XREF1129 *)
    Import(adder : EventAdder) : Expression =
        let dt = <type structure of event handler delegate type> in
        let s = <event slot for adder.DeclaringEvent> in
        let sl = if adder.IsStatic then
                     <type structure for adder.DeclaringType>
                 else
                     "i" in
        let eta = "dt.Export(sl.s)" in
        let script = ImportScript(adder) in
        let doadd = if adder.IsStatic then
                        "script(eta)"
                    else
                        "script(i, eta)" in
        let body = "if (sl.s == null) {
                        sl.s = d;
                        doadd;
                    }
                    else
                        sl.s = root.CombineDelegates(sl.s, d);" in
        if adder.IsStatic then
            "function(d) { body }"
        else
            "function (i, d) { body }"

    IsImported(remover : EventRemover) : bool = remover.IsImport && remover.IsExtern || remover has Import attribute

    Import(remover : EventRemover) : Expression =
        let s = <event slot for remover.DeclaringEvent> in
        let sl = if remover.IsStatic then
                     <type structure for remover.DeclaringType>
                 else
                     "i" in
        let script = ImportScript(remover) in
        let doremove = if remover.IsStatic then
                           "script(null)"
                       else
                           "script(i, null)" in
        let body = "if (sl.s == null)
                        throw root.InvalidOperationException();
                    else {
                        sl.s = root.RemoveAllDelegates(sl.s, d);
                        if (sl.s == null)
                            doremove;
                    }" in
        if remover.IsStatic then
            "function(d) { body }"
        else
            "function(i, d) { body }"

    IsExported(adder : EventAdder) : bool = adder.IsExport && !adder.IsExtern && !init.IsNotExported

    (* XREF1151 *)
    Export(adder : EventAdder) : Expression =
        let dt = <type structure for event handler delegate type> in
        let t = <type structure for adder.DeclaringType> in
        let s = <event slot for adder.DeclaringEvent> in
        let sl = if adder.IsStatic then
                     <type structure for adder.DeclaringType>
                 else
                     "i" in
        let body = "var d = dt.Import(h);
                    if (sl.s == null)
                        sl.s = d;
                    else
                        sl.s = root.CombineDelegates(sl.s, d);" in
        let script = ExportScript(adder) in
        if adder.IsStatic then
            "function() { script(function(h) { body }); }"
        else
            "function(i) { script(t.Export(i), function(h) { body }); }"

    IsExported(remover : EventRemover) : bool = remover.IsExport && !remover.IsExtern && !init.IsNotExported

    Export(remover : EventRemover) : Expression =
        let dt = <type structure for event handler delegate type> in
        let t = <type structure for remover.DeclaringType> in
        let s = <event slot for remover.DeclaringEvent> in
        let sl = if remover.IsStatic then
                     <type structure for remover.DeclaringType>
                 else
                     "i" in
        let body = "var d = dt.Import(h);  // ok since import is idempotent
                    if (sl.s == null)
                        throw root.InvalidOperationException();
                    else
                        sl.s = root.RemoveAllDelegates(sl.s, d);" in
        let script = ExportScript(remover) in
        if remover.IsStatic then
            "function() { script(function(h) { body }); }"
        else
            "function(i) { script(t.Export(i), function(h) { body }); }"












                            case InteropManager.InteropStyle.Merged:
                                {
                                    // XREF1021
                                    var thenBlock = new JST.Statements();
                                    var cond1Exp = JST.Expression.IsNotNull
                                        (JST.Expression.Dot(typeExp, Constants.TypeDynamicTypeMarshaller));
                                    var dynTypeExp = JST.Expression.DotCall
                                        (rootExp,
                                         Constants.RootResolveQualifiedType,
                                         JST.Expression.DotCall
                                             (typeExp, Constants.TypeDynamicTypeMarshaller, unmanagedObjId.ToE()));
                                    var objTypeExp = JST.Expression.Dot(unmanagedObjId.ToE(), Constants.ObjectType);
                                    thenBlock.Add
                                        (new JST.IfStatement
                                             (cond1Exp,
                                              JST.Statement.Assignment(objTypeExp, dynTypeExp),
                                              JST.Statement.Assignment(objTypeExp, typeExp)));
                                    var managedObjId = nestedTypeLocalEnv.GenSym();
                                    thenBlock.Add
                                        (JST.Statement.Var
                                             (managedObjId,
                                              JST.Expression.DotCall
                                                  (objTypeExp, Constants.TypeInitializeInstanceSlots, objTypeExp)));
                                    thenBlock.Add
                                        (JST.Statement.DotCall
                                             (rootExp,
                                              Constants.RootInheritProperties,
                                              unmanagedObjId.ToE(),
                                              managedObjId.ToE()));
                                    function.Body.Add
                                        (new JST.IfStatement
                                             (JST.Expression.Dot(unmanagedObjId.ToE(), Constants.ObjectType), thenBlock));
                                    var cond2Exp = new JST.UnaryExpression
                                        (new JST.Not(),
                                         JST.Expression.DotCall(rootExp, Constants.RootIsAssignableTo, objTypeExp, typeExp));
                                    function.Body.Add
                                        (new JST.IfStatement
                                             (cond2Exp,
                                              new JST.ThrowStatement
                                                  (JST.Expression.DotCall(rootExp, Constants.RootInvalidCastException))));
                                    function.Body.Add(new JST.ReturnStatement(unmanagedObjId.ToE()));
                                    break;
                                }


                            case InteropManager.InteropStyle.Open:
                                {
                                    // XREF1033
                                    var managedObjExp = new JST.IndexExpression
                                        (unmanagedObjId.ToE(), JST.Expression.Dot(rootExp, Constants.RootBackpointerField));
                                    var thenBlock = new JST.Statements();
                                    var objTypeId = nestedTypeLocalEnv.GenSym();
                                    thenBlock.Add(JST.Statement.Var(objTypeId, typeExp));
                                    var marshallerExp = JST.Expression.Dot(typeExp, Constants.TypeDynamicTypeMarshaller);
                                    thenBlock.Add
                                        (new JST.IfStatement
                                             (JST.Expression.IsNotNull(marshallerExp),
                                              JST.Statement.IdAssignment
                                                  (objTypeId,
                                                   JST.Expression.DotCall
                                                       (rootExp,
                                                        Constants.RootResolveQualifiedType,
                                                        new JST.CallExpression(marshallerExp, unmanagedObjId.ToE())))));
                                    thenBlock.Add
                                        (JST.Statement.Assignment
                                             (managedObjExp,
                                              JST.Expression.DotCall
                                                  (objTypeId.ToE(), Constants.TypeInitializeInstanceSlots, objTypeId.ToE())));
                                    function.Body.Add
                                        (new JST.IfStatement(JST.Expression.IsNull(managedObjExp), thenBlock));
                                    var condExp = JST.Expression.Not
                                        (JST.Expression.DotCall
                                             (rootExp,
                                              Constants.RootIsAssignableTo,
                                              JST.Expression.Dot(managedObjExp, Constants.ObjectType),
                                              typeExp));
                                    function.Body.Add
                                        (new JST.IfStatement
                                             (condExp,
                                              new JST.ThrowStatement
                                                  (JST.Expression.DotCall(rootExp, Constants.RootInvalidCastException))));
                                    function.Body.Add
                                        (JST.Statement.DotAssignment
                                             (managedObjExp, Constants.ObjectInstance, unmanagedObjId.ToE()));
                                    function.Body.Add(new JST.ReturnStatement(managedObjExp));
                                    break;
                                }



                    case InteropManager.InteropStyle.Merged:
                        // XREF1019
                        function.Body.Add(new JST.ReturnStatement(managedObjId.ToE()));
                        break;


                    case InteropManager.InteropStyle.Open:
                    {
                        // XREF1031
                        var instanceExp = JST.Expression.Dot(managedObjId.ToE(), Constants.ObjectInstance);
                        function.Body.Add
                            (new JST.IfStatement
                                 (JST.Expression.IsNull(managedObjId.ToE()),
                                  new JST.ReturnStatement(new JST.Null())));
                        var unmanagedObjId = nestedTypeLocalEnv.GenSym();
                        var thenBlock = new JST.Statements();
                        thenBlock.Add(JST.Statement.Var(unmanagedObjId, new JST.ObjectLiteral()));
                        thenBlock.Add
                            (JST.Statement.IndexAssignment
                                 (unmanagedObjId.ToE(),
                                  JST.Expression.Dot(rootExp, Constants.RootBackpointerField),
                                  managedObjId.ToE()));
                        thenBlock.Add(JST.Statement.Assignment(instanceExp, unmanagedObjId.ToE()));
                        function.Body.Add(new JST.IfStatement(JST.Expression.IsNull(instanceExp), thenBlock));
                        function.Body.Add(new JST.ReturnStatement(instanceExp));
                        break;
                    }


        public static JST.FunctionExpression IdFunction(LocalEnv localEnv)
        {
            var function = new JST.FunctionExpression();
            var id = localEnv.NameSupply.Fork().GenSym();
            function.Parameters.Add(id);
            function.Body.Add(new JST.ReturnStatement(id.ToE()));
            return function;
        }

        public static JST.FunctionExpression IgnoreFunction(LocalEnv localEnv, int arity)
        {
            var function = new JST.FunctionExpression();
            if (arity > 0)
            {
                var ns = localEnv.NameSupply.Fork();
                while (arity-- > 0)
                    function.Parameters.Add(ns.GenSym());
            }
            function.Body.Add(new JST.ReturnStatement());
            return function;
        }



                    case InteropManager.InteropStyle.Merged:
                        statements.Add
                            (JST.Statement.DotCall
                                 (MethodLocalEnv.RootId.ToE(),
                                  Constants.RootInheritProperties,
                                  tempObjId.ToE(),
                                  initObjId.ToE()));
                        statements.Add(JST.Statement.Assignment(initObjId.ToE(), tempObjId.ToE()));
                        break;


                    case InteropManager.InteropStyle.Open:
                        statements.Add
                            (JST.Statement.IndexAssignment
                                 (tempObjId.ToE(),
                                  JST.Expression.Dot(MethodLocalEnv.RootId.ToE(), Constants.RootBackpointerField),
                                  initObjId.ToE()));
                        statements.Add
                            (JST.Statement.DotAssignment(initObjId.ToE(), Constants.ObjectInstance, tempObjId.ToE()));
                        break;




        // ----------------------------------------------------------------------
        // Imported methods
        // ----------------------------------------------------------------------

        public void EmitImportedBody(JST.Statements statements)
        {
            var script = env.InteropManager.ImportScript(MethodLocalEnv, MethodDefn);

            if (MethodDefn is CLR.InstanceInitializer)
            {
                // XREF1117
                // Constructor
                var callArgs = new List<JST.Expression>();
                var managedObjId = MethodLocalEnv.Parameters[0];
                for (var i = 1; i < MethodLocalEnv.CLRParameters.Count; i++)
                {
                    if (MethodLocalEnv.CLRParameters[i].Semantics != MethodParameterSemantics.Normal)
                        throw new ArgumentException();
                    var typeId = MethodLocalEnv.ResolveTypeToIdentifier
                        (MethodLocalEnv.CLRParameters[i].Type, TypePhase.Names);
                    callArgs.Add
                        (JST.Expression.DotCall(typeId.ToE(), Constants.TypeExport, MethodLocalEnv.Parameters[i].ToE()));
                }
                var unmanagedObjId = MethodLocalEnv.GenSym();
                statements.Add
                    (JST.Statement.Var
                         (unmanagedObjId, JST.Expression.Apply(MethodLocalEnv.GenSym, script, callArgs)));
                switch (env.InteropManager.Style(MethodDefn.DeclaringType))
                {
                    case InteropManager.InteropStyle.Normal:
                        throw new ArgumentException();
                    case InteropManager.InteropStyle.Keyed:
                        {
                            var rootDefn = env.InteropManager.RootType(MethodDefn.DeclaringType);
                            var rootTypeId = MethodLocalEnv.ResolveTypeToIdentifier(rootDefn, TypePhase.Names);
                            var unmanagedKey = JST.Expression.Dot
                                (unmanagedObjId.ToE(),
                                 JST.Expression.ExplodePath(env.InteropManager.KeyField(rootDefn)));
                            statements.Add
                                (new JST.IfStatement
                                     (JST.Expression.IsNull(unmanagedKey),
                                      JST.Statement.Assignment
                                          (unmanagedKey, JST.Expression.Dot(managedObjId.ToE(), Constants.ObjectId))));
                            var keyExp = JST.Expression.Nary
                                (new JST.Plus(),
                                 JST.Expression.DotCall
                                     (MethodLocalEnv.RootId.ToE(),
                                      Constants.RootQualifiedTypeName,
                                      JST.Expression.Dot(rootTypeId.ToE(), Constants.TypeAssembly),
                                      JST.Expression.Dot(rootTypeId.ToE(), Constants.TypeName)),
                                 new JST.StringLiteral("::"),
                                 unmanagedKey);
                            statements.Add
                                (JST.Statement.Assignment
                                     (new JST.IndexExpression
                                          (JST.Expression.Dot(MethodLocalEnv.RootId.ToE(), Constants.RootKeyedObjects),
                                           keyExp),
                                      managedObjId.ToE()));
                            break;
                        }
                    case InteropManager.InteropStyle.Proxied:
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
                statements.Add
                    (JST.Statement.DotAssignment(managedObjId.ToE(), Constants.ObjectUnmanaged, unmanagedObjId.ToE()));
            }
            else if (MethodDefn.DeclaringMember != null && MethodDefn.DeclaringMember is CLR.Event)
            {
                // XREF1129
                // Event adder/remover
                var evnt = (CLR.Event)MethodDefn.DeclaringMember;
                var simulateMulticast = env.InteropManager.IsSimulateMulticastEvents(evnt);
                var evntType = env.EventEnv.Type(evnt);
                var delegateTypeId = MethodLocalEnv.ResolveTypeToIdentifier(evntType, TypePhase.Names);
                var slotId = new JST.Identifier
                    (Constants.ObjectEventSlot(env.GlobalMapping.ResolveEventDefinitionToSlot(evnt)));
                var delegateId = default(JST.Identifier);
                var objId = default(JST.Identifier);
                if (MethodDefn.IsStatic)
                {
                    objId = MethodLocalEnv.ResolveTypeToIdentifier(MethodDefn.DeclaringType, TypePhase.Names);
                    delegateId = MethodLocalEnv.Parameters[0];
                }
                else
                {
                    objId = MethodLocalEnv.Parameters[0];
                    delegateId = MethodLocalEnv.Parameters[1];
                }
                var slotExp = JST.Expression.Dot(objId.ToE(), slotId);
                if (MethodDefn == evnt.HandlerAdder)
                {
                    var args = new List<JST.Expression>();
                    if (!MethodDefn.IsStatic)
                        args.Add
                            (JST.Expression.DotCall(MethodLocalEnv.TypeId.ToE(), Constants.TypeExportThis, objId.ToE()));
                    args.Add(JST.Expression.DotCall(delegateTypeId.ToE(), Constants.TypeExport, slotExp));
                    var adder = JST.Expression.Apply(MethodLocalEnv.GenSym, script, args);
                    if (simulateMulticast)
                    {
                        var thenBlock = new JST.Statements();
                        thenBlock.Add(JST.Statement.Assignment(slotExp, delegateId.ToE()));
                        thenBlock.Add(adder.ToStatement());
                        var elseStmnt = JST.Statement.Assignment
                            (slotExp,
                             JST.Expression.DotCall
                                 (MethodLocalEnv.RootId.ToE(), Constants.RootCombineDelegates, slotExp, delegateId.ToE()));
                        statements.Add
                            (new JST.IfStatement
                                 (JST.Expression.IsNull(JST.Expression.Dot(objId.ToE(), slotId)),
                                  thenBlock,
                                  elseStmnt));
                    }
                    else
                        statements.Add(adder.ToStatement());
                }
                else if (MethodDefn == evnt.HandlerRemover)
                {
                    var args = new List<JST.Expression>();
                    if (!MethodDefn.IsStatic)
                        args.Add
                            (JST.Expression.DotCall(MethodLocalenv.TypeId.ToE(), Constants.TypeExportThis, objId.ToE()));
                    args.Add(new JST.Null());
                    var remover = JST.Expression.Apply(MethodLocalEnv.GenSym, script, args);
                    if (simulateMulticast)
                    {
                        var thenStmnt = new JST.ThrowStatement
                            (JST.Expression.DotCall(MethodLocalEnv.RootId.ToE(), Constants.RootInvalidOperationException));
                        var elseBlock = new JST.Statements();
                        elseBlock.Add
                            (JST.Statement.Assignment
                                 (slotExp,
                                  JST.Expression.DotCall
                                      (MethodLocalEnv.RootId.ToE(),
                                       Constants.RootRemoveAllDelegates,
                                       slotExp,
                                       delegateId.ToE())));
                        elseBlock.Add(new JST.IfStatement(JST.Expression.IsNull(slotExp), remover.ToStatement()));
                        statements.Add(new JST.IfStatement(JST.Expression.IsNull(slotExp), thenStmnt, elseBlock));
                    }
                    else
                        statements.Add(remover.ToStatement());
                }
                else
                    throw new ArgumentException();
            }
            else
            {
                // XREF1103
                // Property getter/setter and normal methods
                var callArgs = new List<JST.Expression>();
                for (var i = 0; i < MethodLocalEnv.CLRParameters.Count; i++)
                {
                    if (MethodLocalEnv.CLRParameters[i].Semantics != MethodParameterSemantics.Normal)
                        throw new ArgumentException();
                    var typeId = MethodLocalEnv.ResolveTypeToIdentifier
                        (MethodLocalEnv.CLRParameters[i].Type, TypePhase.Names);
                    if (i == 0 && !MethodDefn.IsStatic)
                        callArgs.Add
                            (JST.Expression.DotCall
                                 (typeId.ToE(), Constants.TypeExportThis, MethodLocalEnv.Parameters[i].ToE()));
                    else
                        callArgs.Add
                            (JST.Expression.DotCall
                                 (typeId.ToE(), Constants.TypeExport, MethodLocalEnv.Parameters[i].ToE()));
                }
                var resType = env.MethodEnv.ReturnType(MethodDefn);
                var resTypeId = resType == null
                                    ? null
                                    : MethodLocalEnv.ResolveTypeToIdentifier(resType, TypePhase.Constructed);
                var callExpr = JST.Expression.Apply(MethodLocalEnv.GenSym, script, callArgs);
                if (resTypeId == null)
                    statements.Add(callExpr.ToStatement());
                else
                    statements.Add
                        (new JST.ReturnStatement(JST.Expression.DotCall(resTypeId.ToE(), Constants.TypeImport, callExpr)));
            }
        }



                else if (env.MethodEnv.IsConstructor(methodRef.Definition) &&
                         env.MethodEnv.IsConstructor(MethodDefn))
                {
                    // SPECIAL CASE: Invoking a constructor of a base-type in a constructor of a derived type
                    //               should update the "this" variable.
                    // NOTE: In verifiable code, constructor methods must always be invoked via 'newobj' rather than
                    //       'call' EXCEPT for invocations of base construcctors. Hence the simplicity of the
                    //       above condition.
                    stackManager.DoLinear
                        (statements,
                         methodArity,
                         (stmnts, args) =>
                         JST.Statement.IdAssignment
                             (MethodLocalEnv.Parameters[0],
                              MethodCallExpression(stmnts, constrainedType, isVirtualCall, isVirtualMethod, method, args)));


        Date.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.Date", 3);
        Function.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.Function", 3);
        Number.prototype.T = root.ResolveType(root.MSCorLib, "System.Double", 3);
        Boolean.prototype.T = root.ResolveType(root.MSCorLib, "System.Boolean", 3);
        Error.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.Error", 3);
        TypeError.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.TypeError", 3);
        RangeError.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.RangeError", 3);
        EvalError.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.EvalError", 3);
        SyntaxError.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.SyntaxError", 3);
        ReferenceError.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.ReferenceError", 3);
        if (typeof UriError != "undefined")
            UriError.prototype.T = root.ResolveType(root.Interop, namespacePrefix + "JavaScript.UriError", 3);



        // Build the built-in array type constructor
        var t =  root.NewObject(root.TypeType);
        t.Assembly = root.MSCorLib;
        t.Name = "$Array";
        t.Instantiate = function(elemType) {
            // Build an instance of the built-in array type constructor
            var u = root.NewObject(root.TypeType);
            // It is exactly the same as System.Array
            root.InheritProperties(u, root.ArrayType);
            // Except it must look like an instance of the $Array type constructor
            u.Name = root.TypeName(t.Name, [elemType]);
            u.Applicand = t;
            u.Arguments = [elemType];
            // And it must look like it derives from System.Array
            u.Supertypes[root.QualifiedTypeName(root.ArrayType.Assembly, root.ArrayType.Name)] = true;
            u.Supertypes[root.QualifiedTypeName(u.Assembly, u.Name)] = false;
            u.InitializeTypeSlots = function() {
                root.ArrayType.InitializeTypeSlots();
                root.InheritProperties(u, root.ArrayType);
            }
            // But it must not share the extras of System.Array
            u.DynamicTypeMarshaller = undefined;
            u.InvokeStaticConstructor = function() { };
            u.DefaultConstructor = undefined;
            // Nor have reflection support
            u.NameToSlot = undefined;
            u.PartialToFullName = undefined;
            u.SimpleToFullName = undefined;
            u.VirtualSlots = undefined;
            u.ReflectionTypeNames = undefined;
            u.ReflectionTypeNamespace = undefined;
            return u;
        };
        root.BuiltinArrayType = t;

        // Bind the built-in array type constrctor into MSCorLib
        root.MSCorLib.c$Array = function() { return root.BuiltinArrayType; };
        root.MSCorLib.b$Array = function(phase, elemType) {
            var slot = root.SlotName("b$Array", [elemType]);
            if (root.MSCorLib[slot] == null)
                root.MSCorLib[slot] = root.BuiltinArrayType.Instantiate(elemType);
            root.EnsurePhase(root.MSCorLib[slot], phase);
            return root.MSCorLib[slot];
        };



        root.ArrayType = root.ResolveType(root.MSCorLib, "System.Array", 3);



        // ----------------------------------------------------------------------
        // Resolving events
        // ----------------------------------------------------------------------

        private JST.Expression EventToExpressionInternal(Context ctxt, JST.Expression targetObject, CLR.Event evnt)
        {
            if (Env.InteropManager.IsNotSupported(evnt))
            {
                Env.Log(new UnsupportedFieldMessage(ctxt, Env, field, "field was marked as not supported"));
                return NotSupportedExpression(Env.EventEnv.QualifiedName(evnt));
            }
            else
            {
                var evntRef = Env.EventEnv.ToReference(evnt);
                var slot = Env.GlobalMapping.ResolveEventDefinitionToSlot(evntRef.Definition);
                return new JST.IndexExpression(targetObject, new JST.StringLiteral(Constants.ObjectEventSlot(slot)));
            }
        }

        public JST.Expression StaticEventToExpression(CLR.Event evnt)
        {
            return EventToExpressionInternal
                (ResolveTypeToIdentifier(Env.EventEnv.DeclaringType(evnt), TypePhase.Constructed).ToE(), evnt);
        }

        public JST.Expression InstanceEventToExpression(JST.Expression targetObject, CLR.Event evnt)
        {
            return EventToExpressionInternal(targetObject, evnt);
        }



        // ----------------------------------------------------------------------
        // Not supported helpers
        // ----------------------------------------------------------------------

        public JST.Expression NotSupportedFunction(string msg, int arity)
        {
            var function = new JST.FunctionExpression();
            while (arity-- > 0)
                function.Parameters.Add(NameSupply.GenSym());
            function.Body.Add
                (new JST.ThrowStatement
                     (JST.Expression.DotCall
                          (RootId.ToE(), Constants.RootNotSupportedExceptionWithMessage, new JST.StringLiteral(msg))));
            return function;
        }

        public JST.Expression NotSupportedExpression(string msg)
        {
            return new JST.CallExpression(NotSupportedFunction(msg, 0));
        }







    // ----------------------------------------------------------------------
    // Loading code
    // ----------------------------------------------------------------------

    root.LoadCodeUsingExternal = function(fileName) {
        var code = window.external.LoadCode(fileName);
        eval(code);
        return true;
    };

    root.LoadCodeUsingXmlHttp = function(fileName) {
        var xmlhttp;
        if (typeof ActiveXObject != "undefined")
            xmlhttp = new ActiveXObject("MSXML2.XMLHTTP");
        else if (typeof XMLHttpRequest != "undefined")
            xmlhttp = new XMLHttpRequest();
        else
            return false;

        try {
            xmlhttp.open("GET", fileName, false);
            xmlhttp.send(null);
        }
        catch (e) {
            return false;
        }

        if (xmlhttp.status == 200 || xmlhttp.status == 0) {
            var response = xmlhttp.responseText;
            if (response == null || response == "")
                return false;
            else {
                eval(response);
                return true;
            }
        }
        else
            return false;
    };

    root.LoadCodeUsingSearchPaths = function(fileName) {
        for (var i = 0; i < root.SearchPaths.length; i++) {
            if (root.LoadCodeUsingXmlHttp(root.SearchPaths[i] + "/" + fileName))
                return true;
        }
        throw root.InvalidOperationExceptionWithMessage("unable to download file: " + fileName);
    };

    root.LoadCodeUsingScript = function(fileName) {
        var fullName = root.SearchPaths[0] + "/" + fileName;
        document.write("<script src=\"" + fullName + "\"></script>");
    };



//
// A logic variable which is either free or bound
//

using System;
using JST = Microsoft.LiveLabs.JavaScript.JST;

namespace Microsoft.LiveLabs.JavaScript.IL2JS
{
    public class BoundLogicVar<T> : LogicVar<T> {
        private T t;
    }
    
    public class LogicVar<T>
    {
        private static uint nextName;

        // Unique internal name for variable, used only when printing in debugging
        private uint name;

        // If free: both fv and t are null
        // If bound: one of fv or t are non-null
        private LogicVar<T> fv;
        private T t;

        static LogicVar()
        {
            nextName = 0;
        }

        public LogicVar()
        {
            name = nextName++;
            fv = null;
            t = null;
        }

        public LogicVar(T t)
        {
            name = nextName++;
            fv = null;
            this.t = t;
        }

        private LogicVar<T> Follow()
        {
            var thisfv = this;
            while (fv.fv != null)
                thisfv = fv.fv;
            return thisfv;
        }


        public void Unify(T othert)
        {
            var thisfv = Follow();

            if (thisfv.t != null)
                thisfv.t = thisfv.t.Unify(othert);
            else
                thisfv.t = othert;
        }

        public void Unify(LogicVar<T> otherfv)
        {
            var thisfv = Follow();
            otherfv = otherfv.Follow();

            if (thisfv.t != null && otherfv.t != null)
            {
                thisfv.t = thisfv.t.Unify(otherfv.t);
                otherfv.t = null;
                otherfv.fv = thisfv;
            }
            else if (thisfv.t != null)
                otherfv.t = thisfv.t;
            else if (otherfv.t != null)
                thisfv.t = otherfv.t;
            else
                thisfv.fv = otherfv;
        }

        public bool IsFree()
        {
            return Follow().t == null;
        }

        public T BoundTo()
        {
            var res = Follow().t;
            if (res == null)
                throw new InvalidOperationException("locic var is free");
            return res;
        }

        public override string ToString()
        {
            var thisfv = Follow();
            if (thisfv.t != null)
                return thisfv.t.ToString();
            else
                return '\'' + JST.Lexemes.UIntToIdentifier(thisfv.name, 1);
        }
    }

}














    public class StackTypes
    {
        Environment env;

        public StackTypes(Environment env)
        {
            this.env = env;
        }

        // Convert a CLR type to its verification type:
        //  - We forget the sign of all integer types, but remember their width.
        //  - We replace enumeration types by the verification type of their reperesentation type.
        //  - A pointer to T is represented by a pointer to the verification type of T
        //  - An array of T is represented by an array of the verification type of T
        //  - All other types are represented by themselves.
        public CLR.TypeNode ToVerificationType(CLR.TypeNode type)
        {
            var refType = type as CLR.Reference;
            var arrType = default(CLR.ArrayType);
            if (refType != null)
                type = refType.ElementType;
            else
            {
                arrType = type as CLR.ArrayType;
                if (arrType != null)
                    type = arrType.ElementType;
            }

            var enumType = type as CLR.EnumNode;
            if (enumType != null)
                type = enumType.UnderlyingType;

            if (refType != null)
            {
                if (env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(type)))
                {
                    switch (env.TypeEnv.SimpleName(type))
                    {
                        case "System.SByte":
                        case "System.Byte":
                        case "System.Boolean":
                            type = env.TypeEnv.SByteRef;
                            break;
                        case "System.Int16":
                        case "System.UInt16":
                        case "System.Char":
                            type = env.TypeEnv.Int16Ref;
                            break;
                        case "System.Int32":
                        case "System.UInt32":
                            type = env.TypeEnv.Int32Ref;
                            break;
                        case "System.Int64":
                        case "System.UInt64":
                            type = env.TypeEnv.Int64Ref;
                            break;
                        case "System.Single":
                            type = env.TypeEnv.SingleRef;
                            break;
                        case "System.Double":
                            type = env.TypeEnv.DoubleRef;
                            break;
                        default:
                            type = ToVerificationType(type).GetReferenceType();
                            break;
                    }
                }
                else
                    type = ToVerificationType(type).GetReferenceType();
            }
            else if (arrType != null)
            {
                if (env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(type)))
                {
                    switch (env.TypeEnv.SimpleName(type))
                    {
                        case "System.SByte":
                        case "System.Byte":
                        case "System.Boolean":
                            type = env.TypeEnv.SByteArr;
                            break;
                        case "System.Int16":
                        case "System.UInt16":
                        case "System.Char":
                            type = env.TypeEnv.Int16Arr;
                            break;
                        case "System.Int32":
                        case "System.UInt32":
                            type = env.TypeEnv.Int32Arr;
                            break;
                        case "System.Int64":
                        case "System.UInt64":
                            type = env.TypeEnv.Int64Arr;
                            break;
                        case "System.Single":
                            type = env.TypeEnv.SingleArr;
                            break;
                        case "System.Double":
                            type = env.TypeEnv.DoubleArr;
                            break;
                        default:
                            type = ToVerificationType(type).GetArrayType(1);
                            break;
                    }
                }
                else
                    type = ToVerificationType(type).GetArrayType(1);
            }
            else
            {
                if (env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(type)))
                {
                    switch (env.TypeEnv.SimpleName(type))
                    {
                        case "System.Byte":
                        case "System.Boolean":
                            type = env.TypeEnv.SByte;
                            break;
                        case "System.UInt16":
                        case "System.Char":
                            type = env.TypeEnv.Int16;
                            break;
                        case "System.UInt32":
                            type = env.TypeEnv.Int32;
                            break;
                        case "System.UInt64":
                            type = env.TypeEnv.Int64;
                            break;
                        default:
                            break;
                    }
                }
            }
            return type;
        }

        // Convert a CLR type to its representative type on the stack:
        //  - All signed and unsigned integers <= 32 bit widths are sign extended and pushed as an uninterpreted
        //    32 bit words. The sign may later be reintroduced by an operator. We represent these by Int32.
        //  - All signed and unnsigned 64 bit integers are pushed as an uninterpreted 64 bit word.
        //    Again, sign may be reintroduced by an operator. We represent these by Int64.
        //  - Single and double precision floats are pushed as a floating point with at least double's precision.
        //    We represent these by Double.
        //  - Enumerations are pushed as the stack type of their representation type.
        //  - Pointers to T are pushed as native machine pointers. We represent these as a pointer to the
        //    *verification* (not stack) type of T.
        //  - Similarly for arrays of T.
        //  - All other values are pushed as themselves.
        //
        // We use null to represent the 'null' stack type, which contains only the null object reference
        // of indeterminate reference type.
        //
        // Note that arrays are pushed as themselves, however we sometimes have to fiddle with their
        // element types when checking array access instructions.
        public CLR.TypeNode ToStackType(CLR.TypeNode type)
        {
            if (type is CLR.Reference || type is CLR.ArrayType)
                return ToVerificationType(type);

            var enumType = type as CLR.EnumNode;
            if (enumType != null)
                type = enumType.UnderlyingType;

            if (env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(type)))
            {
                switch (env.TypeEnv.SimpleName(type))
                {
                    case "System.SByte":
                    case "System.Byte":
                    case "System.Int16":
                    case "System.UInt16":
                    case "System.Int32":
                    case "System.UInt32":
                    case "System.Boolean":
                    case "System.Char":
                        type = env.TypeEnv.Int32;
                        break;
                    case "System.Int64":
                    case "System.UInt64":
                        type = env.TypeEnv.Int64;
                        break;
                    case "System.Single":
                    case "System.Double":
                        type = env.TypeEnv.Double;
                        break;
                    default:
                        break;
                }
            }
            return type;
        }

        // Equivalent to ToVerificationType(elemType).GetReferenceType()
        public CLR.TypeNode ToPointerStackType(CLR.TypeNode elemType)
        {
            if (elemType is CLR.Reference)
                throw new InvalidOperationException("pointer to pointer");

            var enumType = elemType as CLR.EnumNode;
            if (enumType != null)
                elemType = enumType.UnderlyingType;

            if (env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(elemType)))
            {
                switch (env.TypeEnv.SimpleName(elemType))
                {
                    case "System.SByte":
                    case "System.Byte":
                    case "System.Boolean":
                        return env.TypeEnv.SByteRef;
                    case "System.Int16":
                    case "System.UInt16":
                    case "System.Char":
                        return env.TypeEnv.Int16Ref;
                    case "System.Int32":
                    case "System.UInt32":
                        return env.TypeEnv.Int32Ref;
                    case "System.Int64":
                    case "System.UInt64":
                        return env.TypeEnv.Int64Ref;
                    case "System.Single":
                        return env.TypeEnv.SingleRef;
                    case "System.Double":
                        return env.TypeEnv.DoubleRef;
                    default:
                        break;
                }
            }
            return ToVerificationType(elemType).GetReferenceType();
        }

        // Equivalent to ToVerificationType(elemType).GetArrayType(1)
        public CLR.TypeNode ToArrayStackType(CLR.TypeNode elemType)
        {
            if (elemType is CLR.Reference)
                throw new InvalidOperationException("array of pointers");

            var enumType = elemType as CLR.EnumNode;
            if (enumType != null)
                elemType = enumType.UnderlyingType;

            if (env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(elemType)))
            {
                switch (env.TypeEnv.SimpleName(elemType))
                {
                    case "System.SByte":
                    case "System.Byte":
                    case "System.Boolean":
                        return env.TypeEnv.SByteArr;
                    case "System.Int16":
                    case "System.UInt16":
                    case "System.Char":
                        return env.TypeEnv.Int16Arr;
                    case "System.Int32":
                    case "System.UInt32":
                        return env.TypeEnv.Int32Arr;
                    case "System.Int64":
                    case "System.UInt64":
                        return env.TypeEnv.Int64Arr;
                    case "System.Single":
                        return env.TypeEnv.SingleArr;
                    case "System.Double":
                        return env.TypeEnv.DoubleArr;
                    default:
                        break;
                }
            }
            return ToVerificationType(elemType).GetArrayType(1);
        }

        public void CheckNumericType(CLR.TypeNode stackType)
        {
            if (stackType == null)
                throw new UnificationException();
            if (!env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(stackType)))
                throw new UnificationException();
            var name = env.TypeEnv.SimpleName(stackType);
            if (name != "System.Int32" && name != "System.Int64" && name != "System.Double")
                throw new UnificationException();
        }

        public void CheckIntegerType(CLR.TypeNode stackType)
        {
            if (stackType == null)
                throw new UnificationException();
            if (!env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(stackType)))
                throw new UnificationException();
            var name = env.TypeEnv.SimpleName(stackType);
            if (name != "System.Int32" && name != "System.Int64")
                throw new UnificationException();
        }

        public void CheckInt32Type(CLR.TypeNode stackType)
        {
            if (stackType == null)
                throw new UnificationException();
            if (!env.AssemblyEnv.IsMSCorLib(env.TypeEnv.Assembly(stackType)))
                throw new UnificationException();
            var name = env.TypeEnv.SimpleName(stackType);
            if (name != "System.Int32")
                throw new UnificationException();
        }

        public bool AreSubTypes(CLR.TypeNode leftStackType, CLR.TypeNode rightStackType)
        {
            if (leftStackType == null && rightStackType == null)
                // 'null' is a subtype of 'null'
                return true;
            if (leftStackType == null)
                // 'null' is a subtype of any reference type
                return env.TypeEnv.IsReferenceType(rightStackType);
            if (rightStackType == null)
                // no other types are subtypes of 'null'
                return false;
            if (env.TypeEnv.IsValueType(leftStackType))
            {
                // Value types must be exactly equal
                if (!env.TypeEnv.IsValueType(rightStackType))
                    return false;
                return env.TypeEnv.IsAssignableTo(leftStackType, rightStackType) &&
                       env.TypeEnv.IsAssignableTo(rightStackType, leftStackType);
            }
            // Left pointer or reference type must be assignable to right
            return env.TypeEnv.IsAssignableTo(leftStackType, rightStackType);
        }

        public CLR.TypeNode LubStackTypes(CLR.TypeNode leftStackType, CLR.TypeNode rightStackType)
        {
            if (AreSubTypes(leftStackType, rightStackType))
                return rightStackType;
            if (AreSubTypes(rightStackType, leftStackType))
                return leftStackType;
            // NOTE: According to the CLR spec we should try to find a least common interface, but
            //       we'll assume no compilers generate code that exploits this.
            throw new UnificationException();
        }

        public void CheckSubTypes(CLR.TypeNode actStackType, CLR.TypeNode expType)
        {
            if (!AreSubTypes(actStackType, ToStackType(expType)))
                throw new UnificationException();
        }

        public void CheckComparableTypes(CLR.TypeNode leftStackType, CLR.TypeNode rightStackType, bool isEquality)
        {
            if (leftStackType == null && rightStackType == null)
                // Two 'null' types are comparable
                return;
            if (leftStackType == null)
            {
                // 'null' is comparable with any reference type
                if (!env.TypeEnv.IsReferenceType(rightStackType))
                    throw new UnificationException();
            }
            else if (rightStackType == null)
            {
                // 'null' is comparable with any reference type
                if (!env.TypeEnv.IsReferenceType(leftStackType))
                    throw new UnificationException();
            }
            else if (env.TypeEnv.IsValueType(leftStackType))
            {
                CheckNumericType(leftStackType);
                if (!AreSubTypes(leftStackType, rightStackType))
                    throw new UnificationException();
            }
            else
            {
                // Reference and pointer types are comparable for equality only
                if (!isEquality)
                    throw new UnificationException();
            }
        }

        public void CheckObjectType(CLR.TypeNode stackType)
        {
            if (stackType == null)
                return;
            if (!env.TypeEnv.IsReferenceType(stackType))
                throw new UnificationException();
        }

        public void CheckEquivNumericType(CLR.TypeNode leftStackType, CLR.TypeNode rightStackType)
        {
            CheckNumericType(leftStackType);
            CheckNumericType(rightStackType);
            if (!AreSubTypes(leftStackType, rightStackType))
                throw new UnificationException();
        }

        public void CheckEquivIntegerType(CLR.TypeNode leftStackType, CLR.TypeNode rightStackType)
        {
            CheckIntegerType(leftStackType);
            CheckIntegerType(rightStackType);
            if (!AreSubTypes(leftStackType, rightStackType))
                throw new UnificationException();
        }

        public void CheckInt32OrObjectType(CLR.TypeNode stackType)
        {
            if (env.TypeEnv.IsValueType(stackType))
                CheckInt32Type(stackType);
            if (env.TypeEnv.IsPointerType(stackType))
                throw new UnificationException();
        }

        public void CheckSrcPointerType(CLR.TypeNode actStackType, CLR.TypeNode expElemType)
        {
            if (actStackType == null)
                // 'null' type cannot represent pointers, only objects
                throw new UnificationException();
            var actRefType = actStackType as CLR.Reference;
            if (actRefType == null)
                // not a pointer
                throw new UnificationException();
            if (!AreSubTypes(actRefType.ElementType, ToVerificationType(expElemType)))
                throw new UnificationException();
        }

        public void CheckDstPointerType(CLR.TypeNode actStackType, CLR.TypeNode expElemType)
        {
            if (actStackType == null)
                // 'null' type cannot represent pointers, only objects
                throw new UnificationException();
            var actRefType = actStackType as CLR.Reference;
            if (actRefType == null)
                // not a pointer
                throw new UnificationException();
            if (!AreSubTypes(ToVerificationType(expElemType), actRefType.ElementType))
                throw new UnificationException();
        }

        public void CheckArrayType(CLR.TypeNode stackType)
        {
            if (stackType != null && !(stackType is CLR.ArrayType))
                throw new UnificationException();
        }

        public void CheckSrcArrayType(CLR.TypeNode actStackType, CLR.TypeNode expElemType)
        {
            if (actStackType == null)
                // 'null' can represent arrays
                return;
            var actArrType = actStackType as CLR.ArrayType;
            if (actArrType == null)
                // not an array
                throw new UnificationException();
            if (!AreSubTypes(actArrType.ElementType, ToVerificationType(expElemType)))
                throw new UnificationException();
        }

        public void CheckSrcArrayTypeIgnoreSign(CLR.TypeNode actStackType, CLR.TypeNode expElemType)
        {
            if (actStackType == null)
                // 'null' can represent arrays
                return;
            var actArrType = actStackType as CLR.ArrayType;
            if (actArrType == null)
                // not an array
                throw new UnificationException();
            if (!AreSubTypes(ToStackType(actArrType.ElementType), ToStackType(expElemType)))
                throw new UnificationException();
        }

        public void CheckSrcArrayTypeAnyObject(CLR.TypeNode actStackType, out CLR.TypeNode actElemStackType)
        {
            if (actStackType == null)
            {
                // 'null' can represent arrays
                actElemStackType = null;
                return;
            }
            var actArrType = actStackType as CLR.ArrayType;
            if (actArrType == null)
                // not an array
                throw new UnificationException();
            if (env.TypeEnv.IsValueType(actArrType.ElementType))
                // not array of objects
                throw new UnificationException();
            actElemStackType = ToStackType(actArrType.ElementType);
        }

        public void CheckSrcArrayTypeExact(CLR.TypeNode actStackType, CLR.TypeNode expElemType)
        {
            if (actStackType == null)
                // 'null' not good enough
                throw new UnificationException();
            var actArrType = actStackType as CLR.ArrayType;
            if (actArrType == null)
                // not an array
                throw new UnificationException();
            if (!AreSubTypes(actArrType.ElementType, ToVerificationType(expElemType)))
                throw new UnificationException();
            if (!AreSubTypes(ToVerificationType(expElemType), actArrType.ElementType))
                throw new UnificationException();
        }

        public void CheckDstArrayType(CLR.TypeNode actStackType, CLR.TypeNode expElemType)
        {
            if (actStackType == null)
                // 'null' can represent arrays
                return;
            var actArrType = actStackType as CLR.ArrayType;
            if (actArrType == null)
                // not an array
                throw new UnificationException();
            if (!AreSubTypes(ToVerificationType(expElemType), actArrType.ElementType))
                throw new UnificationException();
        }

        public void CheckDstArrayTypeIgnoreSign(CLR.TypeNode actStackType, CLR.TypeNode expElemType)
        {
            if (actStackType == null)
                // 'null' can represent arrays
                return;
            var actArrType = actStackType as CLR.ArrayType;
            if (actArrType == null)
                // not an array
                throw new UnificationException();
            if (!AreSubTypes(ToStackType(expElemType), ToStackType(actArrType.ElementType)))
                throw new UnificationException();
        }

        public void CheckDstArrayTypeAnyObject(CLR.TypeNode actStackType, CLR.TypeNode expElemStackType)
        {
            if (actStackType == null)
                // 'null' can represent arrays
                return;
            if (expElemStackType == null)
                // 'null' can be cast to the desired array type
                return;
            var actArrType = actStackType as CLR.ArrayType;
            if (actArrType == null)
                // not an array
                throw new UnificationException();
            if (env.TypeEnv.IsValueType(actArrType.ElementType))
                // not an array of objects
                throw new UnificationException();
            if (env.TypeEnv.IsValueType(expElemStackType))
                // not an object value
                throw new UnificationException();
        }

        public void CheckDereferencableSubTypes(CLR.TypeNode actStackType, CLR.TypeNode expObjectType, bool canBeStruct)
        {
            if (actStackType == null)
            {
                // 'null' can be statically dereferenced if we are expecting a reference type, though
                // of course this will cause a null reference exception at runtime
                if (!env.TypeEnv.IsReferenceType(expObjectType))
                    throw new UnificationException();
            }
            else
            {
                var refType = actStackType as CLR.Reference;
                if (refType != null)
                {
                    // Pointer can be dereferenced it its contents is compatible with expected type
                    if (!AreSubTypes(refType.ElementType, ToVerificationType(expObjectType)))
                        throw new UnificationException();
                }
                else
                {
                    if (!canBeStruct && env.TypeEnv.IsValueType(actStackType))
                        throw new UnificationException();
                    // Values and objects can be dereferenced if they are compatible with expected type
                    if (!AreSubTypes(actStackType, ToStackType(expObjectType)))
                        throw new UnificationException();
                }
            }
        }

    }


            var ps = Parameters(type);
            if (ps.Count > 0)
            {
                var args = new CLR.TypeNode[ps.Count];
                for (var i = 0; i < ps.Count; i++)
                    args[i] = ps[i];
                return type.GetTemplateInstance(type, args);
            }
            else
                return type;


        // Is type definition significant at runtime? (Assemblies contain a few classes which only carry metadata)
        public bool IsAddressableType(CLR.TypeNode typeDefn)
        {
            if (!IsDefinition(typeDefn))
                throw new InvalidOperationException("type is not a definition");
            if (typeDefn == BuiltinArrayConstructor || typeDefn == BuiltinReferenceConstructor)
                return true;
            else if (typeDefn == BuiltinPointerConstructor || typeDefn == BuiltinFunctionPointerConstructor)
                return false;
            else
                return typeDefn.Name.Name != "<Module>" &&
                       !typeDefn.Name.Name.StartsWith("<PrivateImplementationDetails>");
        }




        private void EmitThisTypeExporter(TypeLocalEnv nestedTypeLocalEnv, JST.FunctionExpression function)
        {
            var typeExp = nestedTypeLocalEnv.TypeId.ToE();
            var managedObjId = function.Parameters[0];
            switch (typeRef.Flavor)
            {
                case TypeFlavor.Nullable:
                {
                    // XREF1321
                    function.Body.Add
                        (new JST.ReturnStatement
                             (JST.Expression.DotCall(function.Parameters[0].ToE(), Constants.PointerRead)));
                    break;
                }
                case TypeFlavor.Boolean:
                case TypeFlavor.Enum:
                case TypeFlavor.Number:
                case TypeFlavor.Struct:
                {
                    // XREF1361
                    function.Body.Add
                        (new JST.ReturnStatement(JST.Expression.Dot(managedObjId.ToE(), Constants.PointerRead)));
                    break;
                }
                default:
                    function.Body.Add
                        (new JST.ReturnStatement
                             (JST.Expression.DotCall(typeExp, Constants.TypeExport, managedObjId.ToE())));
                    break;
            }
        }

        private JST.Expression TypeThisExporterFunction(TypeLocalEnv typeLocalEnv)
        {
            return JSTHelpers.MakeFunction(typeLocalEnv, 1, EmitThisTypeExporter);
        }


            // ExportThis
            statements.Add(JST.Statement.DotAssignment(lhs, Constants.TypeExportThis, TypeThisExporterFunction(typeLocalEnv)));

        public static readonly JST.Identifier TypeExportThis = new JST.Identifier("ExportThis");


        public string ResolveAssemblyReferenceToSlot(CLR.AssemblyNode referencingAssembly, CLR.AssemblyNode referencedAssembly)
        {
            return AssemblyMappingFor(referencedAssembly).ResolveAssemblyReferenceToSlot(referencedAssembly);
        }

        private readonly SlotAllocation<CLR.AssemblyNode> referencedAssemblies;

            referencedAssemblies = new SlotAllocation<CLR.AssemblyNode>
                (env.Options.DebugMode,
                 NameFlavor.Identifier,
                 (sb, a) => env.AssemblyEnv.AppendFriendlyName(sb, NameFlavor.Identifier, a),
                 env.AssemblyEnv.Comparer);

            foreach (var a in env.AssemblyEnv.References(assembly))
                referencedAssemblies.Add(a);

        public string ResolveAssemblyReferenceToSlot(CLR.AssemblyNode referencedAssembly)
        {
            return referencedAssemblies.For(referencedAssembly);
        }



        [Import(@"function(root, instance) {
                      var c = instance.R();
                      if (c >= 32 && c <= 127)
                          return String.fromCharCode(c);
                      else if (c < 16)
                          return ""\\x0"" + c.toString(16);
                      else if (c < 256)
                          return ""\\x"" + c.toString(16);
                      else if (c < 4096)
                          return ""\\u0"" + c.toString(16);
                      else if (c < 65536)
                          return ""\\u"" + c.toString(16);
                      else
                          throw root.InvalidOperationExceptionWithMessage(""character out of printable range"");
                  }", PassRootAsArgument = true)]



        // Encoding of the 'sub attribute' relation (other than reflexive entries)
        private readonly static HashSet<string> subAttributes;

        private static string Pair(string l, string r)
        {
            return l + "," + r;
        }

        static InteropManager()
        {
            subAttributes = new HashSet<string>(StringComparer.Ordinal);

            subAttributes.Add(Pair(importName, namingName));
            subAttributes.Add(Pair(importGetName, namingName));
            subAttributes.Add(Pair(importSetName, namingName));
            subAttributes.Add(Pair(importAddName, namingName));
            subAttributes.Add(Pair(importRemoveName, namingName));
            subAttributes.Add(Pair(importKeyName, namingName));
            subAttributes.Add(Pair(exportName, namingName));
            subAttributes.Add(Pair(exportGetName, namingName));
            subAttributes.Add(Pair(exportSetName, namingName));
            subAttributes.Add(Pair(exportAddName, namingName));
            subAttributes.Add(Pair(exportRemoveName, namingName));
            subAttributes.Add(Pair(keyedTypeName, namingName));

            subAttributes.Add(Pair(importGetName, importName));
            subAttributes.Add(Pair(importSetName, importName));
            subAttributes.Add(Pair(importAddName, importName));
            subAttributes.Add(Pair(importRemoveName, importName));
            subAttributes.Add(Pair(importKeyName, importName));

            subAttributes.Add(Pair(exportGetName, exportName));
            subAttributes.Add(Pair(exportSetName, exportName));
            subAttributes.Add(Pair(exportAddName, exportName));
            subAttributes.Add(Pair(exportRemoveName, exportName));
        }




    // ----------------------------------------------------------------------
    // Type definitions
    // ----------------------------------------------------------------------

    public abstract class TypeDef
    {
    }

    public class TypeDerivation
    {
        public readonly TypeRef Extends;        // null => no base type, underlying def must be class/struct
        public readonly /* immutable */ IList<TypeRef> Implements;  // non-null, underlying defs must be ifaces

        public TypeDerivation(TypeRef extends, IList<TypeRef> implements)
        {
            Extends = extends;
            Implements = implements ?? Constants.EmptyTypeRefs; 
        }
    }

    // No values, signals no return type
    public class VoidTypeDef : TypeDef {
    }

    // Values passed by value
    public abstract class ValueTypeDef : TypeDef {
        public readonly TypeName Name;  // non-null, includes namespaces, outer types, and this type
        public readonly /* immutable */ IList<MemberDef> Members; // non-null
        public readonly /* immutable */ IList<Annotation> Annotations; // non-null

        protected ValueTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations)
        {
            Name = name;
            Members = members;
            Annotations = annotations;
        }
    }

    public class HandleTypeDef : ValueTypeDef
    {
        public readonly HandleStyle Style;

        public HandleTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations, HandleStyle style) :
            base(name, members, annotations)
        {
            Style = style;
        }
    }

    public class NullableTypeDef : ValueTypeDef
    {
        public readonly ParameterTypeDef Parameter; // non-null

        public NullableTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations, ParameterTypeDef parameter) :
            base(name, members, annotations)
        {
            Parameter = parameter;
        }
    }

    public class NumberTypeDef : ValueTypeDef
    {
        public readonly NumberStyle Style;

        public NumberTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations, NumberStyle style) :
            base(name, members, annotations)
        {
            Style = style;
        }
    }

    public class EnumTypeDef : ValueTypeDef
    {
        public readonly NumberStyle Implementation;  // Cannot be Single or Double
        public readonly /* immutable */ IList<FieldDef> Values;      // non-null, static fields of implementation type only

        public EnumTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations, NumberStyle implementation, IList<FieldDef> values) :
            base(name, members, annotations)
        {
            Implementation = implementation;
            Values = values ?? Constants.EmptyFieldDefs;
        }
    }

    public class StructTypeDef : ValueTypeDef
    {
        public readonly bool IsStatic;
        public readonly /* immutable */IList<ParameterTypeDef> Parameters; // non-null
        public readonly TypeDerivation Derivation; // non-null

        public StructTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations, bool isStatic, IList<ParameterTypeDef> parameters, TypeDerivation derivation) :
            base(name, members, annotations)
        {
            IsStatic = isStatic;
            Parameters = parameters ?? Constants.EmptyParameterTypeDefs;
            Derivation = derivation;
        }
    }

    // Values passed by reference
    public abstract class ReferenceTypeDef : TypeDef {
    }

    public class ArrayTypeDef : ReferenceTypeDef
    {
        public readonly ParameterTypeDef Parameter; // non-null

        public ArrayTypeDef(ParameterTypeDef parameter)
        {
            Parameter = parameter;
        }
    }

    public abstract class NamedReferenceTypeDef : ReferenceTypeDef
    {
        public readonly TypeName Name; // non-null, includes namespaces, outer types, and this type
        public readonly /* immutable */ IList<MemberDef> Members; // non-null
        public readonly /* immutable */ IList<Annotation> Annotations; // non-null

        protected NamedReferenceTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations)
        {
            Name = name;
            Members = members ?? Constants.EmptyMemberDefs;
            Annotations = annotations ?? Constants.EmptyAnnotations;
        }
    }

    public class StringTypeDef : NamedReferenceTypeDef
    {
        protected StringTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations) :
            base(name, members, annotations)
        {
        }
    }

    public class DelegateTypeDef : NamedReferenceTypeDef
    {
        public readonly /* immutable */ IList<ParameterTypeDef> Parameters; // non-null
        public readonly /* immutable */ IList<TypeRef> ValueParameters; // non-null
        public readonly TypeRef Result;  // null => void

        public DelegateTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations, IList<ParameterTypeDef> parameters, IList<TypeRef> valueParameters, TypeRef result) :
            base(name, members, annotations)
        {
            Parameters = parameters ?? Constants.EmptyParameterTypeDefs;
            ValueParameters = valueParameters ?? Constants.EmptyTypeRefs;
            Result = result;
        }
    }

    public enum ClassStyle { 
        Normal,
        Sealed,
        Abstract
    }

    public class ClassTypeDef : NamedReferenceTypeDef
    {
        public readonly bool IsStatic;
        public readonly ClassStyle Style; // static => normal
        public readonly /* immutable */ IList<ParameterTypeDef> Parameters; // non-null
        public readonly TypeDerivation Derivation; // non-null

        public ClassTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations, bool isStatic, ClassStyle style, IList<ParameterTypeDef> parameters, TypeDerivation derivation) :
            base(name, members, annotations)
        {
            IsStatic = isStatic;
            Style = style;
            Parameters = parameters ?? Constants.EmptyParameterTypeDefs;
            Derivation = derivation;
        }
    }

    // Implemented over a boxed value type or reference type
    public class InterfaceTypeDef : NamedReferenceTypeDef
    {
        public readonly /* immutable */ IList<ParameterTypeDef> Parameters; // non-null
        public readonly /* immutable */ IList<TypeRef> Implements;   // non-null, underlying definitions must be interfaces

        public InterfaceTypeDef(TypeName name, IList<MemberDef> members, IList<Annotation> annotations, IList<ParameterTypeDef> parameters, IList<TypeRef> implements)
            : base(name, members, annotations)
        {
            Parameters = parameters ?? Constants.EmptyParameterTypeDefs;
            Implements = implements ?? Constants.EmptyTypeRefs;
        }
    }

    // Managed pointer to value
    public class PointerTypeDef : TypeDef
    {
        public readonly ParameterTypeDef Parameter; // non-null

        public PointerTypeDef(ParameterTypeDef parameter)
        {
            Parameter = parameter;
        }
    }

    public class UnmanagedPointerTypeDef : TypeDef
    {
        public readonly ParameterTypeDef Parameter; // non-null

        public UnmanagedPointerTypeDef(ParameterTypeDef parameter)
        {
            Parameter = parameter;
        }
    }

    public class FunctionPointerTypeDef : TypeDef
    {
        public readonly /* immutable */ IList<ParameterTypeDef> ArgumentParameters; // non-null
        public readonly ParameterTypeDef ResultParameter; // non-null

        public FunctionPointerTypeDef(IList<ParameterTypeDef> argumentParameters, ParameterTypeDef resultParameter)
        {
            ArgumentParameters = argumentParameters;
            ResultParameter = resultParameter;
        }
    }

    public enum ConstraintStyle
    {
        None,
        ReferenceType,
        ReferenceTypeWithDefaultConstructor,
        NonNullableValueType
    }

    public class ParameterTypeDef : TypeDef
    {
        public readonly int Index;
        public readonly bool IsCovariant;
        public readonly bool IsContravariant;
        public readonly ConstraintStyle Style;
        public readonly TypeDerivation Constraints; // non-null, null base type implies no class constraint.

        public ParameterTypeDef(int index, bool isCovariant, bool isContravariant, ConstraintStyle style, TypeDerivation constraints)
        {
            Index = index;
            IsCovariant = isCovariant;
            IsContravariant = isContravariant;
            Style = style;
            Constraints = constraints;
        }
    }


        public override int CompareTo(MemberDef other)
        {
            var methdef = other as MethodDef;
            if (methdef == null)
                return -1;
            var i = TypeParameters.Count.CompareTo(methdef.TypeParameters.Count);
            if (i != 0)
                return i;
            i = ValueParameters.Count.CompareTo(methdef.ValueParameters.Count);
            if (i != 0)
                return i;
            for (var j = 0; j < ValueParameters.Count; j++)
            {
                i = ValueParameters[i].CompareTo(methdef.ValueParameters[i]);
                if (i != 0)
                    return i;
            }
            if (Result == null && methdef.Result == null)
                return 0;
            else if (Result == null)
                return -1;
            else if (methdef.Result == null)
                return 1;
            else
                return Result.CompareTo(methdef.Result);
        }


            var assembly = env.AssemblyContext();
            if (assembly == null)
                throw new InvalidOperationException("not in assembly context");
            return new QualifiedTypeName(assembly.Name, Name);


    public class AssemblyEnvironment
    {
        public GlobalEnvironment Env;
        public readonly AssemblyDef Assembly;

        public AssemblyEnvironment(GlobalEnvironment env, AssemblyDef assembly)
        {
            Env = env;
            Assembly = assembly;
        }
    }

    public class TypeEnvironment : AssemblyEnvironment
    {
        public readonly TypeDef Type; // non-null
        public readonly /* immutable */ IList<TypeRef> ClassTypeArguments; // non-null

        public TypeEnvironment(GlobalEnvironment env, AssemblyDef assembly, TypeDef type, IList<TypeRef> classTypeArguments) :
            base(env, assembly)
        {
            Type = type;
            ClassTypeArguments = classTypeArguments ?? Constants.EmptyTypeRefs;
        }

        public TypeEnvironment Refocus(AssemblyDef assembly, TypeDef type, IList<TypeRef> classTypeArguments)
        {
            var substClassTypeArguments = default(List<TypeRef>);
            if (classTypeArguments != null && classTypeArguments.Count > 0)
            {
                substClassTypeArguments = new List<TypeRef>();
                foreach (var typeRef in classTypeArguments)
                    substClassTypeArguments.Add(typeRef.Substitute(this));
            }
            return new TypeEnvironment(Env, assembly, type, substClassTypeArguments);
        }

        public virtual TypeEnvironment ResolveTypeParameter(ParameterTypeRef parameter)
        {
            if (parameter.IsClassBound)
            {
                if (parameter.Index < ClassTypeArguments.Count)
                    return ClassTypeArguments[parameter.Index].Enter(this);
                else
                {
                    var ps = Type.EffectiveParameters();
                    if (parameter.Index < ps.Count)
                        return new TypeEnvironment(Env, Assembly, ps[parameter.Index], null);
                    else
                        throw new InvalidOperationException("no in-scope binding for class type parameter");
                }
            }
            else
                throw new InvalidOperationException("no in-scope binding for method type parameter");
        }
    }

    public class MemberEnvironment : TypeEnvironment
    {
        public readonly MemberDef Member; // non-null

        public MemberEnvironment(GlobalEnvironment env, AssemblyDef assembly, TypeDef type, IList<TypeRef> classTypeArguments, MemberDef member) :
            base(env, assembly, type, classTypeArguments)
        {
            Member = member;
        }
    }

    public class MethodEnvironment : MemberEnvironment
    {
        public readonly /* immutable */ IList<TypeRef> MethodTypeArguments; // non-null

        public MethodEnvironment(GlobalEnvironment env, AssemblyDef assembly, TypeDef type, IList<TypeRef> classTypeArguments, MethodDef method, IList<TypeRef> methodTypeArguments) :
            base(env, assembly, type, classTypeArguments, method)
        {
            MethodTypeArguments = methodTypeArguments ?? Constants.EmptyTypeRefs;
        }

        public override TypeEnvironment ResolveTypeParameter(ParameterTypeRef parameter)
        {
            if (parameter.IsClassBound)
                return base.ResolveTypeParameter(parameter);
            else
            {
                if (parameter.Index < MethodTypeArguments.Count)
                    return MethodTypeArguments[parameter.Index].Enter(this);
                else
                {
                    var ps = Member.EffectiveTypeParameters();
                    if (parameter.Index < ps.Count)
                        return new TypeEnvironment(Env, Assembly, ps[parameter.Index], null);
                    else
                        throw new InvalidOperationException("no in-scope binding for method type parameter");
                }
            }
        }
    }


        public virtual TypeRef Substitute(IList<TypeRef> classTypeArguments, IList<TypeRef> methodTypeArguments)
        {
            var args = EffectiveArguments(env);
            if (args.Count > 0)
            {
                var newArgs = new List<TypeRef>();
                var changed = false;
                foreach (var typeRef in args)
                {
                    var newTypeRef = typeRef.Substitute(env);
                    if (newTypeRef != typeRef)
                        changed = true;
                    newArgs.Add(newTypeRef);
                }
                if (changed)
                    return CloneWithArguments(newArgs);
                else
                    return this;
            }
            else
                return this;
        }


        // ----------------------------------------------------------------------
        // Phase 3: Exception structure recovery
        // ----------------------------------------------------------------------

        private void BuildExceptionScopesFrom(IList<CST.Instruction> instructions, Info context)
        {
            for (var i = 0; i < instructions.Count; i++)
            {
                var instruction = instructions[i];

                switch (instruction.Style)
                {
                    case InstructionStyle.Unsupported:
                    case InstructionStyle.Branch:
                    case InstructionStyle.Switch:
                    case InstructionStyle.Compare:
                    case InstructionStyle.Arg:
                    case InstructionStyle.Local:
                    case InstructionStyle.Field:
                    case InstructionStyle.Method:
                    case InstructionStyle.Type:
                    case InstructionStyle.LdElemAddr:
                    case InstructionStyle.LdInt32:
                    case InstructionStyle.LdInt64:
                    case InstructionStyle.LdSingle:
                    case InstructionStyle.LdDouble:
                    case InstructionStyle.LdString:
                    case InstructionStyle.Arith:
                    case InstructionStyle.Conv:
                        break;
                    case InstructionStyle.Misc:
                        {
                            var misci = (CST.MiscInstruction)instruction;
                            switch (misci.Op)
                            {
                                case CST.MiscOp.Rethrow:
                                    {
                                        if (context == null)
                                            throw new InvalidOperationException("rethrow not within catch");
                                        var handlerInfo = context as HandlerInfo;
                                        if (handlerInfo == null)
                                            throw new InvalidOperationException("rethrow not within catch");
                                        if (!(handlerInfo.ILHandler is CST.CatchHandler))
                                            throw new InvalidOperationException("rethrow not within catch");
                                        break;
                                    }
                                case CST.MiscOp.Ret:
                                    {
                                        if (context != null)
                                            throw new InvalidOperationException("ret within try or handler");
                                        break;
                                    }
                                default:
                                    break;
                            }
                        }
                        break;
                    case InstructionStyle.Try:
                        {
                            var tryi = (CST.TryInstruction)instruction;
                            var parent = default(TryInfo);
                            if (context != null)
                            {
                                parent = context as TryInfo;
                                if (parent == null)
                                {
                                    var handlerInfo = context as HandlerInfo;
                                    if (handlerInfo == null)
                                        throw new InvalidOperationException();
                                    parent = handlerInfo.TryInfo;
                                }
                            }
                            var tryInfo = new TryInfo
                            {
                                ILTry = tryi,
                                Parent = parent,
                                Handlers = new List<HandlerInfo>(),
                                TryBasicBlock = null
                            };
                            BuildExceptionScopesFrom(tryi.Body, tryInfo);
                            foreach (var h in tryi.Handlers)
                            {
                                if (h is CST.FilterHandler)
                                    throw new NotSupportedException("filter blocks");
                                var handlerInfo = new HandlerInfo { ILHandler = h, TryInfo = tryInfo, HandlerHeader = null };
                                tryInfo.Handlers.Add(handlerInfo);
                                BuildExceptionScopesFrom(h.Body, handlerInfo);
                            }
                        }
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }



    public class OffsetRange {
        // Offset of first instruction in try or handler block
        public readonly int Start;
        // Offset of last instruction in try or handler block
        public readonly int End;

        public OffsetRange(int start, int end)
        {
            Start = start;
            End = end;
        }

        public bool Includes(int offset)
        {
            return offset >= Start && offset <= End;
        }
    }





                            if (methi.IsVirtual)
                                // Should have followed dup
                                throw new UnificationException();
                            else
                            {
                                // Look for blessed sequence
                                //   ldftn <method>; newobj <delegate::.ctor>
                                // which constructs a delegate
                                var delmeth = methi.Method;
                                methi = AsNewObj(instructions, ref index);
                                if (methi == null)
                                    throw new UnificationException();
                                var delctor = methi.Method;
                                var deltype = methi.Method.DefiningType as CST.DelegateTypeRef;
                                if (deltype == null)
                                    throw new UnificationException();
                                if (delctor.ValueParameters.Count != 3)
                                    throw new UnificationException();
                                var objStackType = default(CST.TypeRef);
                                var tail = stack.Pop(out objStackType);
                                CheckIsAssignableTo(objStackType, delctor.ValueParameters[1]);
                                // TODO: Should also check delegate function has signature expected by delegate
                                return tail.Push(delctor.DefiningType.ToRunTimeType(env, true));


        private CST.MethodInstruction AsLdVirtFtn(IList<CST.Instruction> instructions, ref int index)
        {
            if (index >= instructions.Count)
                return null;
            var mi = instructions[index] as CST.MethodInstruction;
            if (mi == null)
                return null;
            if (mi.Op != CST.MethodOp.Ldftn || !mi.IsVirtual)
                return null;
            index++;
            return mi;
        }

        private CST.MethodInstruction AsNewObj(IList<CST.Instruction> instructions, ref int index)
        {
            if (index >= instructions.Count)
                return null;
            var mi = instructions[index] as CST.MethodInstruction;
            if (mi == null)
                return null;
            if (mi.Op != CST.MethodOp.Newobj)
                return null;
            index++;
            return mi;
        }

    // ----------------------------------------------------------------------
    // Existentially quantified type parameter (not part of CLR metadata)
    // ----------------------------------------------------------------------

    public class ExistentialTypeRef : TypeRef
    {
        public readonly int Id;

        public ExistentialTypeRef(int id)
        {
            Id = id;
        }

        public override TypeRef Substitute(IList<TypeRef> classTypeArguments, IList<TypeRef> methodTypeArguments)
        {
            var constraints = Constraints.Substitute(classTypeArguments, methodTypeArguments);
            if (constraints != Constraints)
                return new ExistentialTypeRef(Id, Style, constraints);
            else
                return this;
        }

        public override QualifiedTypeName EffectiveName(GlobalEnvironment global)
        {
            throw new InvalidOperationException("existentially-quantified type variables do not have names");
        }

        public override IList<TypeRef> EffectiveArguments(Environment env)
        {
            return Constants.EmptyTypeRefs;
        }

        public override Environment Enter(Environment env)
        {
            throw new InvalidOperationException("cannot enter an existentially quantified type variable");
        }

        public override bool IsAssignableToGround(Environment env, TypeRef other)
        {
            if (Equals(other))
                return true;
            else if (other is ClassTypeRef && Constraints.Extends != null)
                return Constraints.Extends.IsAssignableToGround(env, other);
            else if (other is InterfaceTypeRef)
            {
                foreach (var iface in Constraints.Implements)
                {
                    if (iface.IsAssignableToGround(env, other))
                        return true;
                }
                return false;
            }
            else
                return false;
        }

        public override TypeRef CloneWithArguments(IList<TypeRef> arguments)
        {
            if (arguments != null && arguments.Count > 0)
                throw new InvalidOperationException("mismatched type arity");
            return this;
        }

        public override TypeRef ToRunTimeType(Environment env, bool forStack)
        {
            return this;
        }

        public override void Append(Writer w)
        {
            w.Append("`");
            w.Append(Id);
        }

        public override int GetHashCode()
        {
            return Tag ^ (Id * 547);
        }

        public override bool Equals(TypeRef other)
        {
            var otherEx = other as ExistentialTypeRef;
            if (otherEx == null)
                return false;
            return Id == otherEx.Id;
        }

        protected override int CompareToSameType(TypeRef other)
        {
            return Id.CompareTo(((ExistentialTypeRef)other).Id);
        }

        protected override int Tag
        {
            get
            {
                var k = 0x25d479d8u;
                return (int)k;
            }
        }
    }
    




//
// A logic variable which is either free or bound
//

using System;
using JST = Microsoft.LiveLabs.JavaScript.JST;

namespace Microsoft.LiveLabs.JavaScript.IL2JS
{
    public class LogicVar<T> where T : class
    {
        private static uint nextName;

        // Unique internal name for variable, used only when printing in debugger
        private uint name;
        // Null if free
        private T t;

        static LogicVar()
        {
            nextName = 0;
        }

        public LogicVar()
        {
            name = nextName++;
            t = null;
        }

        public LogicVar(T t)
        {
            name = nextName++;
            this.t = t;
        }

        public bool IsFree { get { return t == null; } }
        public bool IsBound { get { return t != null; } }

        public T Value
        {
            get
            {
                if (t == null)
                    throw new InvalidOperationException("logic var is free");
                return t;
            }
            set
            {
                if (t != null)
                    throw new InvalidOperationException("logic var is bound");
                t = value;
            }
        }

        public override string ToString()
        {
            if (t == null)
                return '\'' + JST.Lexemes.UIntToIdentifier(name, 1);
            else
                return t.ToString();
        }
    }
}

        // ----------------------------------------------------------------------
        // Phase 2: Stack shape sharing
        // ----------------------------------------------------------------------

        private void UnifyBeforeStacks(int offset, LogicVar<StackShape> lv)
        {
            var existing = default(LogicVar<StackShape>);
            if (offsetToBeforeStack.TryGetValue(offset, out existing))
                existing.Unify(lv);
            else
                // Ok to share actual logic var object itself
                offsetToBeforeStack.Add(offset, lv);
        }

        private void ShareStacksFrom(IList<CST.Instruction> instructions)
        {
            var current = new LogicVar<StackShape>();
            for (var i = 0; i < instructions.Count; i++)
            {
                var instruction = instructions[i];
                UnifyBeforeStacks(instruction.Offset, current);
                switch (instruction.Style)
                {
                    case CST.InstructionStyle.Branch:
                    {
                        var bri = (CST.BranchInstruction)instruction;
                        if (bri.Op != CST.BranchOp.Br)
                            // Stack changes
                            current = new LogicVar<StackShape>();
                        offsetToAfterStack.Add(instruction.Offset, current);
                        UnifyBeforeStacks(bri.Target, current);
                        break;
                    }
                    case CST.InstructionStyle.Switch:
                    {
                        var switchi = (CST.SwitchInstruction)instruction;
                        // Stack changes
                        current = new LogicVar<StackShape>();
                        offsetToAfterStack.Add(instruction.Offset, current);
                        foreach (var j in switchi.Targets)
                            UnifyBeforeStacks(j, current);
                        break;
                    }
                    case CST.InstructionStyle.Try:
                    {
                        // Stack known to be empty on entry and exit, no need to worry about sharing
                        var tryi = (CST.TryInstruction)instruction;
                        ShareStacksFrom(tryi.Body);
                        foreach (var h in tryi.Handlers)
                        {
                            ShareStacksFrom(h.Body);
                            var fh = h as CST.FilterHandler;
                            if (fh != null)
                                ShareStacksFrom(fh.FilterBody);
                        }
                        break;
                    }
                    default:
                        // Stack changes
                        current = new LogicVar<StackShape>();
                        offsetToAfterStack.Add(instruction.Offset, current);
                        break;
                }
                if (instruction.NeverReturns)
                    // No constraint between after current and before next
                    current = new LogicVar<StackShape>();
            }
        }





                if (types[i] is CST.NullTypeRef && other.types[i] is CST.ReferenceTypeRef)
                    types[i] = other.types[i];
                else if (types[i] is CST.ReferenceTypeRef && other.types[i] is CST.NullTypeRef)
                {
                    // nop
                }
                else if (!types[i].IsEquivalentTo(env, other.types[i]))
                    throw new UnificationException();





        // ----------------------------------------------------------------------
        // Phase 2: Stack shapes
        // ----------------------------------------------------------------------

        // NOTE: Stack types may be refined upwards (to super-types) as we discover
        //       new control flow to already analised instructions.

        private void CheckNumericType(CST.TypeRef stackType)
        {
            if (!(stackType is CST.NumberTypeRef))
                throw new UnificationException();
        }

        private void CheckIntegerType(CST.TypeRef stackType)
        {
            var num = stackType as CST.NumberTypeRef;
            if (num == null)
                throw new UnificationException();
            if (num.Style != CST.NumberStyle.Int32 && num.Style != CST.NumberStyle.Int64)
                throw new UnificationException();
        }

        private void CheckIsAssignableTo(CST.TypeRef actStackType, CST.TypeRef expType)
        {
            if (!actStackType.IsAssignableTo(env, expType.ToRunTimeType(env, true)))
                throw new UnificationException();
        }

        private void CheckComparableTypes(CST.TypeRef leftStackType, CST.TypeRef rightStackType, bool isEquality)
        {
            if (leftStackType is CST.NullTypeRef)
            {
                if (!(rightStackType is CST.ReferenceTypeRef))
                    throw new UnificationException();
            }
            else if (rightStackType is CST.NullTypeRef)
            {
                if (!(leftStackType is CST.ReferenceTypeRef))
                    throw new UnificationException();
            }
            else if (leftStackType is CST.ValueTypeRef)
            {
                CheckNumericType(leftStackType);
                if (!leftStackType.IsEquivalentTo(env, rightStackType))
                    throw new UnificationException();
            }
            else
            {
                if (!isEquality)
                    throw new UnificationException();
            }
        }

        private void CheckObjectType(CST.TypeRef stackType)
        {
            if (!(stackType is CST.ReferenceTypeRef))
                throw new UnificationException();
        }

        private void CheckEquivNumericTypes(CST.TypeRef leftStackType, CST.TypeRef rightStackType)
        {
            CheckNumericType(leftStackType);
            CheckNumericType(rightStackType);
            if (!leftStackType.IsEquivalentTo(env, rightStackType))
                throw new UnificationException();
        }

        private void CheckEquivIntegerTypes(CST.TypeRef leftStackType, CST.TypeRef rightStackType)
        {
            CheckIntegerType(leftStackType);
            CheckIntegerType(rightStackType);
            if (!leftStackType.IsEquivalentTo(env, rightStackType))
                throw new UnificationException();
        }

        private void CheckIntegerOrObjectOrPointerType(CST.TypeRef stackType)
        {
            if (stackType is CST.ValueTypeRef)
                CheckIntegerType(stackType);
            else if (!(stackType is CST.ReferenceTypeRef || stackType is CST.ManagedPointerTypeRef))
                throw new UnificationException();
        }

        private void CheckIntegerOrObjectType(CST.TypeRef stackType)
        {
            if (stackType is CST.ValueTypeRef)
                CheckIntegerType(stackType);
            else if (!(stackType is CST.ReferenceTypeRef))
                throw new UnificationException();
        }

        private CST.TypeRef CheckPointerType(CST.TypeRef stackType)
        {
            var ptr = stackType as CST.ManagedPointerTypeRef;
            if (ptr == null)
                throw new UnificationException();
            return ptr.ElementType.ToRunTimeType(env, true);
        }

        private void CheckSrcPointerType(CST.TypeRef actStackType, CST.TypeRef expElemType)
        {
            var ptr = actStackType as CST.ManagedPointerTypeRef;
            if (ptr == null)
                throw new UnificationException();
            // Pointer types are invariant, hence test result won't change as stack shapes are refined
            if (!ptr.ElementType.IsAssignableTo(env, expElemType.ToRunTimeType(env, false)))
                throw new UnificationException();
        }

        private void CheckDstPointerType(CST.TypeRef actStackType, CST.TypeRef expElemType)
        {
            var ptr = actStackType as CST.ManagedPointerTypeRef;
            if (ptr == null)
                throw new UnificationException();
            if (!expElemType.ToRunTimeType(env, false).IsAssignableTo(env, ptr.ElementType))
                throw new UnificationException();
        }

        private void CheckDstPointerTypeStack(CST.TypeRef actStackType, CST.TypeRef expStackType)
        {
            var ptr = actStackType as CST.ManagedPointerTypeRef;
            if (ptr == null)
                throw new UnificationException();
            // NOTE: expStackType must be final
            if (!expStackType.IsAssignableTo(env, ptr.ElementType))
                throw new UnificationException();
        }

        private CST.TypeRef CheckArrayType(CST.TypeRef stackType)
        {
            var arr = stackType as CST.ArrayTypeRef;
            if (arr == null)
                throw new UnificationException();
            return arr.ElementType.ToRunTimeType(env, true);
        }

        private void CheckSrcArrayType(CST.TypeRef actStackType, CST.TypeRef expElemType)
        {
            if (actStackType is CST.NullTypeRef)
                return;
            var arr = actStackType as CST.ArrayTypeRef;
            if (arr == null)
                throw new UnificationException();
            // NOTE: actStackType must be final
            if (!arr.ElementType.IsAssignableTo(env, expElemType.ToRunTimeType(env, false)))
                throw new UnificationException();
        }

        private CST.TypeRef CheckSrcArrayTypeAnyObject(CST.TypeRef actStackType)
        {
            if (actStackType is CST.NullTypeRef)
                return new CST.NullTypeRef();
            var arr = actStackType as CST.ArrayTypeRef;
            if (arr == null)
                throw new UnificationException();
            if (arr.ElementType is CST.ValueTypeRef)
                throw new UnificationException();
            return arr.ElementType.ToRunTimeType(env, true);
        }

        private void CheckSrcArrayTypeExact(CST.TypeRef actStackType, CST.TypeRef expElemType)
        {
            var arr = actStackType as CST.ArrayTypeRef;
            if (arr == null)
                throw new UnificationException();
            if (!arr.ElementType.IsEquivalentTo(env, expElemType.ToRunTimeType(env, false)))
                throw new UnificationException();
        }

        private void CheckDstArrayType(CST.TypeRef actStackType, CST.TypeRef expElemType)
        {
            if (actStackType is CST.NullTypeRef)
                return;
            var arr = actStackType as CST.ArrayTypeRef;
            if (arr == null)
                throw new UnificationException();
            if (!expElemType.ToRunTimeType(env, false).IsAssignableTo(env, arr.ElementType))
                throw new UnificationException();
        }

        private void CheckDstArrayTypeAnyObject(CST.TypeRef actStackType, CST.TypeRef expElemStackType)
        {
            if (actStackType is CST.NullTypeRef)
                return;
            if (expElemStackType is CST.NullTypeRef)
                return;
            var arr = actStackType as CST.ArrayTypeRef;
            if (arr == null)
                throw new UnificationException();
            if (arr.ElementType is CST.ValueTypeRef)
                throw new UnificationException();
            if (expElemStackType is CST.ValueTypeRef)
                throw new UnificationException();
            // NOTE: expElemStackType must be final
            if (!expElemStackType.IsAssignableTo(env, arr.ElementType))
                throw new UnificationException();
        }

        private void CheckBoxedType(CST.TypeRef actStackType, CST.TypeRef expType)
        {
            if (actStackType is CST.NullTypeRef)
                return;
            if (actStackType is CST.ReferenceTypeRef)
            {
                if (!actStackType.Equals(env.Global.ObjectType))
                    throw new UnificationException();
            }
            else
            {
                var box = actStackType as CST.BoxedTypeRef;
                if (box == null)
                    throw new UnificationException();
                var expElemType = expType.ToRunTimeType(env, false);
                var nullable = expElemType as CST.NullableTypeRef;
                if (nullable != null)
                    expElemType = nullable.ElementType;
                if (!box.ElementType.IsEquivalentTo(env, expElemType))
                    throw new UnificationException();
            }
        }

        private void CheckDereferencableSubTypes(CST.TypeRef actStackType, CST.TypeRef expObjectType, bool canBeStruct)
        {
            if (actStackType is CST.NullTypeRef)
            {
                // 'null' can be statically dereferenced if we are expecting a reference type, though
                // of course this will cause a null reference exception at runtime
                if (!(expObjectType is CST.ReferenceTypeRef))
                    throw new UnificationException();
            }
            else
            {
                var ptr = actStackType as CST.ManagedPointerTypeRef;
                if (ptr != null)
                {
                    // Pointers are invariant so this check is stable under stack refinement
                    // Pointer can be dereferenced it its contents is compatible with expected type
                    if (!ptr.ElementType.IsAssignableTo(env, expObjectType.ToRunTimeType(env, false)))
                        throw new UnificationException();
                }
                else
                {
                    if (!canBeStruct && actStackType is CST.ValueTypeRef)
                        throw new UnificationException();
                    // Values and objects can be dereferenced if they are compatible with expected type
                    // NOTE: actStackType must be final
                    if (!actStackType.IsAssignableTo(env, expObjectType.ToRunTimeType(env, true)))
                        throw new UnificationException();
                }
            }
        }


        // Return stack shape after performing given instruction on entry stack shape
        private StackShape StepThroughInstruction(StackShape stack, CST.Instruction instruction)
        {
            switch (instruction.Style)
            {
                case CST.InstructionStyle.Unsupported:
                    throw new InvalidOperationException("unsupported opcode");
                case CST.InstructionStyle.Misc:
                    {
                        var misci = (CST.MiscInstruction)instruction;
                        switch (misci.Op)
                        {
                            case CST.MiscOp.Nop:
                            case CST.MiscOp.Break:
                                {
                                    return stack;
                                }
                            case CST.MiscOp.Dup:
                                {
                                    var head = default(CST.TypeRef);
                                    var tail = stack.Pop(out head);
                                    return tail.Push(head).Push(head);
                                }
                            case CST.MiscOp.Pop:
                                {
                                    return stack.PopAndDiscard();
                                }
                            case CST.MiscOp.Ldnull:
                                {
                                    return stack.Push(new CST.NullTypeRef());
                                }
                            case CST.MiscOp.ConvRUn:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckIntegerType(stackType);
                                    return tail.Push(env.Global.DoubleType);
                                }
                            case CST.MiscOp.Ckfinite:
                                {
                                    return stack.PopExpected(env.Global.DoubleType).Push(env.Global.DoubleType);
                                }
                            case CST.MiscOp.Throw:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckObjectType(stackType);
                                    // Discard stack
                                    return new StackShape(env);
                                }
                            case CST.MiscOp.Rethrow:
                                {
                                    // Discard stack
                                    return new StackShape(env);
                                }
                            case CST.MiscOp.LdindRef:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    var elemStackType = CheckPointerType(stackType);
                                    return tail.Push(elemStackType);
                                }
                            case CST.MiscOp.StindRef:
                                {
                                    var valStackType = default(CST.TypeRef);
                                    var addrStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out valStackType).Pop(out addrStackType);
                                    CheckObjectType(valStackType);
                                    CheckDstPointerTypeStack(addrStackType, valStackType);
                                    return tail;
                                }
                            case CST.MiscOp.LdelemRef:
                                {
                                    var arrStackType = default(CST.TypeRef);
                                    var tail = stack.PopExpected(env.Global.Int32Type).Pop(out arrStackType);
                                    var elemStackType = CheckSrcArrayTypeAnyObject(arrStackType);
                                    return tail.Push(elemStackType);
                                }
                            case CST.MiscOp.StelemRef:
                                {
                                    var arrStackType = default(CST.TypeRef);
                                    var elemStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out elemStackType).PopExpected(env.Global.Int32Type).Pop
                                        (out arrStackType);
                                    CheckDstArrayTypeAnyObject(arrStackType, elemStackType);
                                    return tail;
                                }
                            case CST.MiscOp.Ldlen:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckArrayType(stackType);
                                    return tail.Push(env.Global.Int32Type);
                                }
                            case CST.MiscOp.Ret:
                                {
                                    var resultType = method.Result;
                                    var tail = resultType != null
                                                   ? stack.PopExpected(resultType.ToRunTimeType(env, true))
                                                   : stack;
                                    if (tail.Depth != 0)
                                        throw new UnificationException();
                                    return tail; // empty
                                }
                            case CST.MiscOp.Endfilter:
                                {
                                    var tail = stack.PopExpected(env.Global.Int32Type);
                                    if (tail.Depth != 0)
                                        throw new UnificationException();
                                    return tail;
                                }
                            case CST.MiscOp.Endfinally:
                                {
                                    // Discard stack
                                    return new StackShape(env);
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.Branch:
                    {
                        var bri = (CST.BranchInstruction)instruction;
                        switch (bri.Op)
                        {
                            case CST.BranchOp.Br:
                                {
                                    PropogateStackToBefore(stack, bri.Target);
                                    return stack;
                                }
                            case CST.BranchOp.Brtrue:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckIntegerOrObjectType(stackType);
                                    PropogateStackToBefore(tail, bri.Target);
                                    bri.Type = stackType;
                                    return tail;
                                }
                            case CST.BranchOp.Brfalse:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckIntegerOrObjectOrPointerType(stackType);
                                    PropogateStackToBefore(tail, bri.Target);
                                    bri.Type = stackType;
                                    return tail;
                                }
                            case CST.BranchOp.Breq:
                            case CST.BranchOp.Brne:
                                {
                                    var leftStackType = default(CST.TypeRef);
                                    var rightStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out rightStackType).Pop(out leftStackType);
                                    CheckComparableTypes(leftStackType, rightStackType, true);
                                    PropogateStackToBefore(tail, bri.Target);
                                    bri.Type = leftStackType;
                                    return tail;
                                }
                            case CST.BranchOp.Leave:
                                {
                                    // Discard stack
                                    var tail = new StackShape(env);
                                    PropogateStackToBefore(tail, bri.Target);
                                    return tail;
                                }
                            case CST.BranchOp.BrLt:
                            case CST.BranchOp.BrLe:
                            case CST.BranchOp.BrGt:
                            case CST.BranchOp.BrGe:
                                {
                                    var leftStackType = default(CST.TypeRef);
                                    var rightStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out rightStackType).Pop(out leftStackType);
                                    CheckComparableTypes(leftStackType, rightStackType, false);
                                    PropogateStackToBefore(tail, bri.Target);
                                    bri.Type = leftStackType;
                                    return tail;
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.Switch:
                    {
                        var switchi = (CST.SwitchInstruction)instruction;
                        var tail = stack.PopExpected(env.Global.Int32Type);
                        for (var i = 0; i < switchi.Targets.Count; i++)
                            PropogateStackToBefore(tail, switchi.Targets[i]);
                        return tail;
                    }
                case CST.InstructionStyle.Compare:
                    {
                        var cmpi = (CST.CompareInstruction)instruction;
                        switch (cmpi.Op)
                        {
                            case CST.CompareOp.Ceq:
                                {
                                    var leftStackType = default(CST.TypeRef);
                                    var rightStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out rightStackType).Pop(out leftStackType);
                                    CheckComparableTypes(leftStackType, rightStackType, true);
                                    cmpi.Type = leftStackType;
                                    return tail.Push(env.Global.Int32Type);
                                }
                            case CST.CompareOp.Clt:
                            case CST.CompareOp.Cgt:
                                {
                                    var leftStackType = default(CST.TypeRef);
                                    var rightStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out rightStackType).Pop(out leftStackType);
                                    CheckComparableTypes(leftStackType, rightStackType, false);
                                    cmpi.Type = leftStackType;
                                    return tail.Push(env.Global.Int32Type);
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.Arg:
                    {
                        var argi = (CST.ArgInstruction)instruction;
                        switch (argi.Op)
                        {
                            case CST.ArgOp.Ldarg:
                                {
                                    var type = method.ValueParameters[argi.Arg];
                                    return stack.Push(type.ToRunTimeType(env, true));
                                }
                            case CST.ArgOp.Ldarga:
                                {
                                    var type = new CST.ManagedPointerTypeRef(method.ValueParameters[argi.Arg]);
                                    return stack.Push(type.ToRunTimeType(env, true));
                                }
                            case CST.ArgOp.Starg:
                                {
                                    var type = method.ValueParameters[argi.Arg];
                                    return stack.PopExpected(type.ToRunTimeType(env, true));
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.Local:
                    {
                        var loci = (CST.LocalInstruction)instruction;
                        switch (loci.Op)
                        {
                            case CST.LocalOp.Ldloc:
                                {
                                    var type = method.Locals[loci.Local];
                                    return stack.Push(type.ToRunTimeType(env, true));
                                }
                            case CST.LocalOp.Ldloca:
                                {
                                    var type = new CST.ManagedPointerTypeRef(method.Locals[loci.Local]);
                                    return stack.Push(type.ToRunTimeType(env, true));
                                }
                            case CST.LocalOp.Stloc:
                                {
                                    var type = method.Locals[loci.Local];
                                    return stack.PopExpected(type.ToRunTimeType(env, true));
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.Field:
                    {
                        var fieldi = (CST.FieldInstruction)instruction;
                        switch (fieldi.Op)
                        {
                            case CST.FieldOp.Ldfld:
                                {
                                    if (fieldi.Field.IsStatic)
                                        return stack.Push(fieldi.Field.FieldType.ToRunTimeType(env, true));
                                    else
                                    {
                                        var stackType = default(CST.TypeRef);
                                        var tail = stack.Pop(out stackType);
                                        CheckDereferencableSubTypes(stackType, fieldi.Field.DefiningType, true);
                                        fieldi.IsViaPointer = stackType is CST.ManagedPointerTypeRef;
                                        return tail.Push(fieldi.Field.FieldType.ToRunTimeType(env, true));
                                    }
                                }
                            case CST.FieldOp.Ldflda:
                                {
                                    var type = new CST.ManagedPointerTypeRef(fieldi.Field.FieldType);
                                    if (fieldi.Field.IsStatic)
                                    {
                                        return stack.Push(type.ToRunTimeType(env, true));
                                    }
                                    else
                                    {
                                        var stackType = default(CST.TypeRef);
                                        var tail = stack.Pop(out stackType);
                                        CheckDereferencableSubTypes(stackType, fieldi.Field.DefiningType, false);
                                        fieldi.IsViaPointer = stackType is CST.ManagedPointerTypeRef;
                                        return tail.Push(type.ToRunTimeType(env, true));
                                    }
                                }
                            case CST.FieldOp.Stfld:
                                {
                                    if (fieldi.Field.IsStatic)
                                        return stack.PopExpected(fieldi.Field.FieldType.ToRunTimeType(env, true));
                                    else
                                    {
                                        var stackType = default(CST.TypeRef);
                                        var tail = stack.PopExpected(fieldi.Field.FieldType.ToRunTimeType(env, true)).Pop
                                            (out stackType);
                                        CheckDereferencableSubTypes(stackType, fieldi.Field.DefiningType, false);
                                        fieldi.IsViaPointer = stackType is CST.ManagedPointerTypeRef;
                                        return tail;
                                    }
                                }
                            case CST.FieldOp.Ldtoken:
                                {
                                    return stack.Push(env.Global.RuntimeFieldHandleType.ToRunTimeType(env, true));
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.Method:
                    {
                        var methi = (CST.MethodInstruction)instruction;
                        var funcptr = methi.Method.EffectiveFunctionPointer(env);
                        switch (methi.Op)
                        {
                            case CST.MethodOp.Call:
                                {
                                    var tail = stack;
                                    for (var i = funcptr.Parameters.Count - 1; i >= 1; i--)
                                        tail = tail.PopExpected(funcptr.Parameters[i].ToRunTimeType(env, true));
                                    if (methi.Constrained != null)
                                    {
                                        var ptr = new CST.ManagedPointerTypeRef(methi.Constrained);
                                        tail = tail.PopExpected(ptr.ToRunTimeType(env, true));

                                        if (methi.Constrained is CST.ValueTypeRef)
                                        {
                                            var thisptr = funcptr.Parameters[0] as CST.ManagedPointerTypeRef;
                                            if (thisptr != null)
                                            {
                                                // Constrained is a no-op
                                                if (!methi.Constrained.IsAssignableTo(env, thisptr.ElementType))
                                                    throw new UnificationException();
                                            }
                                            else
                                            {
                                                // Constrained is morally a box, but since no supertype of a value type may
                                                // mutate the value, we don't need to take a copy of the value when boxing,
                                                // so in practice is a no-op
                                                if (!methi.Constrained.IsAssignableTo(env, funcptr.Parameters[0]))
                                                    throw new UnificationException();
                                            }
                                        }
                                        else
                                        {
                                            // If reference type, constrained is a deref. If a type parameter, we must
                                            // decide at runtime between no-op and dereference.
                                            if (!methi.Constrained.IsAssignableTo(env, funcptr.Parameters[0]))
                                                throw new UnificationException();
                                        }
                                    }
                                    else if (funcptr.Parameters.Count > 0)
                                        tail = tail.PopExpected(funcptr.Parameters[0].ToRunTimeType(env, true));
                                    if (funcptr.Result != null)
                                        tail = tail.Push(funcptr.Result.ToRunTimeType(env, true));
                                    return tail;
                                }
                            case CST.MethodOp.Ldftn:
                                {
                                    return stack.Push(funcptr.ToRunTimeType(env, true));
                                }
                            case CST.MethodOp.Newobj:
                                {
                                    if (funcptr.Result != null)
                                        throw new InvalidOperationException("not a constructor");
                                    var tail = stack;
                                    for (var i = funcptr.Parameters.Count - 1; i >= 1; i--)
                                        tail = tail.PopExpected(funcptr.Parameters[i].ToRunTimeType(env, true));
                                    // First argument to constructor is created by runtime. If definining type is
                                    // a value type, first argument will be a pointer, but result left on stack
                                    // will be the value itself.
                                    return tail.Push(methi.Method.DefiningType.ToRunTimeType(env, true));
                                }
                            case CST.MethodOp.Ldtoken:
                                {
                                    return stack.Push(env.Global.RuntimeMethodHandleType.ToRunTimeType(env, true));
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.Type:
                    {
                        var typei = (CST.TypeInstruction)instruction;
                        switch (typei.Op)
                        {
                            case CST.TypeOp.Ldobj:
                                {
                                    var expElemType = typei.Type;
                                    var actSrcPointerStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out actSrcPointerStackType);
                                    CheckSrcPointerType(actSrcPointerStackType, expElemType);
                                    return tail.Push(expElemType.ToRunTimeType(env, true));
                                }
                            case CST.TypeOp.Stobj:
                                {
                                    var expElemType = typei.Type;
                                    var actElemStackType = default(CST.TypeRef);
                                    var actDstPointerStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out actElemStackType).Pop(out actDstPointerStackType);
                                    CheckIsAssignableTo(actElemStackType, expElemType);
                                    CheckDstPointerType(actDstPointerStackType, expElemType);
                                    return tail;
                                }
                            case CST.TypeOp.Cpobj:
                                {
                                    var expElemType = typei.Type;
                                    var actSrcPointerStackType = default(CST.TypeRef);
                                    var actDstPointerStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out actSrcPointerStackType).Pop(out actDstPointerStackType);
                                    CheckSrcPointerType(actSrcPointerStackType, expElemType);
                                    CheckDstPointerType(actDstPointerStackType, expElemType);
                                    return tail;
                                }
                            case CST.TypeOp.Newarr:
                                {
                                    var elemType = typei.Type;
                                    var arrType = new CST.ArrayTypeRef(elemType);
                                    return stack.PopExpected(env.Global.Int32Type).Push(arrType.ToRunTimeType(env, true));
                                }
                            case CST.TypeOp.Initobj:
                                {
                                    var expType = typei.Type;
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckDstPointerType(stackType, expType);
                                    return tail;
                                }
                            case CST.TypeOp.Castclass:
                            case CST.TypeOp.Isinst:
                                {
                                    var castType = typei.Type;
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckObjectType(stackType);
                                    var resultType = castType is CST.ValueTypeRef
                                                         ? new CST.BoxedTypeRef(castType) // using Box<T> type
                                                         : castType;
                                    return tail.Push(resultType.ToRunTimeType(env, true));
                                }
                            case CST.TypeOp.Box:
                                {
                                    var expType = typei.Type;
                                    var boxType = new CST.BoxedTypeRef(expType);
                                    return stack.PopExpected(expType.ToRunTimeType(env, true)).Push
                                        (boxType.ToRunTimeType(env, true)); // using Box<T> type
                                }
                            case CST.TypeOp.Unbox:
                                {
                                    var expType = typei.Type;
                                    if (!(expType is CST.ValueTypeRef))
                                        throw new UnificationException();
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckBoxedType(stackType, expType); // using Box<T> type
                                    var ptrType = new CST.ManagedPointerTypeRef(expType);
                                    return tail.Push(ptrType.ToRunTimeType(env, true));
                                }
                            case CST.TypeOp.UnboxAny:
                                {
                                    var expType = typei.Type;
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    if (expType is CST.ValueTypeRef)
                                        CheckBoxedType(stackType, expType); // using Box<T> type
                                    return tail.Push(expType.ToRunTimeType(env, true));
                                }
                            case CST.TypeOp.Ldtoken:
                                {
                                    return stack.Push(env.Global.RuntimeTypeHandleType.ToRunTimeType(env, true));
                                }
                            case CST.TypeOp.Ldelem:
                                {
                                    var elemType = typei.Type;
                                    var arrStackType = default(CST.TypeRef);
                                    var tail = stack.PopExpected(env.Global.Int32Type).Pop(out arrStackType);
                                    CheckSrcArrayType(arrStackType, elemType);
                                    return tail.Push(elemType.ToRunTimeType(env, true));
                                }
                            case CST.TypeOp.Stelem:
                                {
                                    var elemType = typei.Type;
                                    var arrStackType = default(CST.TypeRef);
                                    var tail =
                                        stack.PopExpected(elemType.ToRunTimeType(env, true)).PopExpected
                                            (env.Global.Int32Type).Pop(out arrStackType);
                                    CheckDstArrayType(arrStackType, elemType);
                                    return tail;
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.LdElemAddr:
                    {
                        var ldelemai = (CST.LdElemAddrInstruction)instruction;
                        var arrStackType = default(CST.TypeRef);
                        var tail = stack.PopExpected(env.Global.Int32Type).Pop(out arrStackType);
                        if (ldelemai.IsReadonly)
                            CheckSrcArrayType(arrStackType, ldelemai.Type);
                        else
                            CheckSrcArrayTypeExact(arrStackType, ldelemai.Type);
                        var ptr = new CST.ManagedPointerTypeRef(ldelemai.Type);
                        return tail.Push(ptr.ToRunTimeType(env, true));
                    }
                case CST.InstructionStyle.LdInt32:
                    {
                        return stack.Push(env.Global.Int32Type);
                    }
                case CST.InstructionStyle.LdInt64:
                    {
                        return stack.Push(env.Global.Int64Type);
                    }
                case CST.InstructionStyle.LdSingle:
                    {
                        return stack.Push(env.Global.DoubleType);
                    }
                case CST.InstructionStyle.LdDouble:
                    {
                        return stack.Push(env.Global.DoubleType);
                    }
                case CST.InstructionStyle.LdString:
                    {
                        return stack.Push(env.Global.StringType);
                    }
                case CST.InstructionStyle.Arith:
                    {
                        var arithi = (CST.ArithInstruction)instruction;
                        switch (arithi.Op)
                        {
                            case CST.ArithOp.Add:
                            case CST.ArithOp.Sub:
                            case CST.ArithOp.Mul:
                            case CST.ArithOp.Div:
                            case CST.ArithOp.Rem:
                                {
                                    var leftStackType = default(CST.TypeRef);
                                    var rightStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out rightStackType).Pop(out leftStackType);
                                    CheckEquivNumericTypes(leftStackType, rightStackType);
                                    arithi.Type = leftStackType;
                                    return tail.Push(leftStackType);
                                }
                            case CST.ArithOp.Neg:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckNumericType(stackType);
                                    arithi.Type = stackType;
                                    return tail.Push(stackType);
                                }
                            case CST.ArithOp.And:
                            case CST.ArithOp.Or:
                            case CST.ArithOp.Xor:
                                {
                                    var leftStackType = default(CST.TypeRef);
                                    var rightStackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out rightStackType).Pop(out leftStackType);
                                    CheckEquivIntegerTypes(leftStackType, rightStackType);
                                    arithi.Type = leftStackType;
                                    return tail.Push(leftStackType);
                                }
                            case CST.ArithOp.Not:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.Pop(out stackType);
                                    CheckIntegerType(stackType);
                                    arithi.Type = stackType;
                                    return tail.Push(stackType);
                                }
                            case CST.ArithOp.Shl:
                            case CST.ArithOp.Shr:
                                {
                                    var stackType = default(CST.TypeRef);
                                    var tail = stack.PopExpected(env.Global.Int32Type).Pop(out stackType);
                                    CheckIntegerType(stackType);
                                    arithi.Type = stackType;
                                    return tail.Push(stackType);
                                }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                case CST.InstructionStyle.Conv:
                    {
                        var convi = (CST.ConvInstruction)instruction;
                        var resType = new CST.NumberTypeRef(convi.NumberStyle);
                        var stackType = default(CST.TypeRef);
                        var tail = stack.Pop(out stackType);
                        CheckNumericType(stackType);
                        convi.Type = stackType;
                        return tail.Push(resType.ToRunTimeType(env, true));
                    }
                case CST.InstructionStyle.Try:
                    {
                        var tryi = (CST.TryInstruction)instruction;
                        if (stack.Depth != 0)
                            throw new UnificationException();
                        StepThroughInstructions(tryi.Body, stack);
                        foreach (var h in tryi.Handlers)
                        {
                            switch (h.Style)
                            {
                                case CST.HandlerStyle.Catch:
                                    {
                                        var catchh = (CST.CatchHandler)h;
                                        StepThroughInstructions(catchh.Body, new StackShape(env, catchh.Type));
                                        break;
                                    }
                                case CST.HandlerStyle.Filter:
                                    {
                                        var filterh = (CST.FilterHandler)h;
                                        StepThroughInstructions
                                            (filterh.FilterBody, new StackShape(env, env.Global.ObjectType));
                                        StepThroughInstructions(filterh.Body, new StackShape(env, env.Global.ObjectType));
                                        break;
                                    }
                                case CST.HandlerStyle.Fault:
                                case CST.HandlerStyle.Finally:
                                    {
                                        StepThroughInstructions(h.Body, new StackShape(env));
                                        break;
                                    }
                                default:
                                    throw new ArgumentOutOfRangeException();
                            }
                        }
                        return null; // suppress assignment of stack
                    }
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private void PropogateStackToBefore(StackShape stack, int offset)
        {
            var existing = default(StackShape);
            if (offsetToBeforeStack.TryGetValue(offset, out existing))
                existing.UnifyInPlace(stack);
            else
                offsetToBeforeStack.Add(offset, stack);
        }

        private void PropogateStackToAfter(StackShape stack, int offset)
        {
            var existing = default(StackShape);
            if (offsetToAfterStack.TryGetValue(offset, out existing))
                existing.UnifyInPlace(stack);
            else
                offsetToAfterStack.Add(offset, stack);
        }

        private void StepThroughInstructions(IList<CST.Instruction> instructions, StackShape initStack)
        {
            var stack = initStack;
            for (var i = 0; i < instructions.Count; i++)
            {
                var offset = instructions[i].Offset;
                if (stack == null)
                {
                    // Has an earlier instruction transferred control to here?
                    if (!offsetToBeforeStack.TryGetValue(offset, out stack))
                    {
                        // CLR spec requires that an instruction only reached by back jumps has an empty entry stack
                        stack = new StackShape(env);
                        offsetToBeforeStack.Add(offset, stack);
                    }
                }
                else
                    PropogateStackToBefore(stack, offset);
                stack = StepThroughInstruction(stack, instructions[i]);
                if (stack != null)
                    PropogateStackToAfter(stack, offset);
                if (instructions[i].NeverReturns)
                    stack = null;
                else if (stack == null)
                    stack = new StackShape(env);
            }
            if (stack != null)
                throw new UnificationException();
        }



        Return,
        Throw,
        Rethrow,


    public class ReturnBasicBlock : BasicBlock
    {
        public ReturnBasicBlock(int id, IList<Instruction> instructions, StackShape entryStack, StackShape exitStack)
            : base(id, instructions, entryStack, exitStack)
        {
        }

        public override BasicBlockFlavor Flavor { get { return BasicBlockFlavor.Return; } }

        public override IList<BasicBlock> Targets { get { return EmptyBasicBlocks; } }

        public override BasicBlock CloneWithInstructions(int id, IList<Instruction> instructions, StackShape entryStack)
        {
            return new ReturnBasicBlock(id, instructions, entryStack, ExitStack);
        }

        public override bool HasSameExit(BasicBlock other)
        {
            return other is ReturnBasicBlock;
        }

        public override void FixupTargets(BasicBlock origBlock, BasicBlock newBlock)
        {
        }
        
        public override void AppendLast(Writer w)
        {
            w.Append("RETURN");
        }
    }

    public class ThrowBasicBlock : BasicBlock
    {
        public ThrowBasicBlock(int id, IList<Instruction> instructions, StackShape entryStack, StackShape exitStack)
            : base(id, instructions, entryStack, exitStack)
        {
        }

        public override BasicBlockFlavor Flavor { get { return BasicBlockFlavor.Throw; } }

        public override IList<BasicBlock> Targets { get { return EmptyBasicBlocks; } }

        public override BasicBlock CloneWithInstructions(int id, IList<Instruction> instructions, StackShape entryStack)
        {
            return new ThrowBasicBlock(id, instructions, entryStack, ExitStack);
        }

        public override bool HasSameExit(BasicBlock other)
        {
            return other is ThrowBasicBlock;
        }

        public override void FixupTargets(BasicBlock origBlock, BasicBlock newBlock)
        {
        }

        public override void AppendLast(Writer w)
        {
            w.Append("THROW");
        }
    }

    public class RethrowBasicBlock : BasicBlock
    {
        public RethrowBasicBlock(int id, IList<Instruction> instructions, StackShape entryStack, StackShape exitStack)
            : base(id, instructions, entryStack, exitStack)
        {
        }

        public override BasicBlockFlavor Flavor { get { return BasicBlockFlavor.Rethrow; } }

        public override IList<BasicBlock> Targets { get { return EmptyBasicBlocks; } }

        public override BasicBlock CloneWithInstructions(int id, IList<Instruction> instructions, StackShape entryStack)
        {
            return new RethrowBasicBlock(id, instructions, entryStack, ExitStack);
        }

        public override bool HasSameExit(BasicBlock other)
        {
            return other is RethrowBasicBlock;
        }

        public override void FixupTargets(BasicBlock origBlock, BasicBlock newBlock)
        {
        }

        public override void AppendLast(Writer w)
        {
            w.Append("RETHROW");
        }
    }

        public bool AllReturningPathsEndAt(BasicBlock other)
        {
            return AllReturningPathsEndAtFrom(other, new HashSet<BasicBlock>());
        }

        private bool AllReturningPathsEndAtFrom(BasicBlock other, HashSet<BasicBlock> visited)
        {
            if (visited.Contains(this))
                return true;
            else if (this is NonReturningBasicBlock)
                return true;
            else
            {
                visited.Add(this);
                foreach (var t in Targets)
                {
                    if (!t.AllReturningPathsEndAtFrom(other, visited))
                        return false;
                }
                return true;
            }
        }





// ***** Moribund *****

using System;
using System.Collections.Generic;

namespace Microsoft.LiveLabs.CST
{

    // ----------------------------------------------------------------------
    // Basic block spanning trees
    // ----------------------------------------------------------------------

    public class BBSTNode : IEquatable<BBSTNode>
    {
        public readonly BasicBlock Block;
        public readonly BBSTNode Parent;
        public readonly IList<BBSTNode> Successors;
        public readonly IList<BBSTNode> ForwardEdges;
        public readonly IList<BBSTNode> BackwardEdges;
        public readonly IList<BBSTNode> CrossEdges;

        public BBSTNode(BasicBlock block, BBSTNode parent)
        {
            Block = block;
            Parent = parent;
            Successors = new List<BBSTNode>();
            ForwardEdges = new List<BBSTNode>();
            BackwardEdges = new List<BBSTNode>();
            CrossEdges = new List<BBSTNode>();
        }

        public override int GetHashCode()
        {
            return Block.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            var node = obj as BBSTNode;
            return node != null && Block.Equals(node.Block);
        }

        public bool Equals(BBSTNode other)
        {
            return Block.Equals(other.Block);
        }
    }

    public class BasicBlockSpanningTree {
        // Map nodes to list of nodes which target it via back edges
        public Dictionary<BBSTNode, List<BBSTNode>> BackwardEdgesInto;
        // Map nodes to their descendants
        public Dictionary<BBSTNode, HashSet<BBSTNode>> StrictDescendentsOf;

        public BBSTNode Root;


        public bool IsAncestor(BBSTNode left, BBSTNode right)
        {
            if (left.Equals(right))
                return true;
            else
            {
                var nodes = default(HashSet<BBSTNode>);
                if (StrictDescendentsOf.TryGetValue(left, out nodes))
                    return nodes.Contains(right);
                else
                    return false;
            }
        }

        public bool PathBack(BBSTNode left, BBSTNode right)
        {
            var finals = default(List<BBSTNode>);
            if (!BackwardEdgesInto.TryGetValue(right, out finals))
                return false;
            foreach (var final in finals)
            {
                if (final.Equals(left))
                    return true;
                if (IsAncestor(left, final))
                {
                    var parent = final;
                    do
                    {
                        if (parent.Equals(right))
                            break;
                        parent = parent.Parent;
                    }
                    while (parent != left);
                    if (parent == left)
                        return true;
                }
            }
            return false;
        }


        public BBSTNode DepthFirstSpanningTree(BasicBlock root)
        {
            var node = new BBSTNode(root, null);
            var visited = new Dictionary<BasicBlock, BBSTNode>();
            foreach (var t in root.Targets)
                DepthFirstSpanningTreeFrom(t, node, visited);
            return node;
        }

        private void DepthFirstSpanningTreeFrom(BasicBlock block, BBSTNode parent, Dictionary<BasicBlock, BBSTNode> visited)
        {
            var node = default(BBSTNode);
            if (visited.TryGetValue(block, out node))
            {
                if (IsAncestor(node, parent))
                {
                    parent.BackwardEdges.Add(node);
                    var nodes = default(List<BBSTNode>);
                    if (BackwardEdgesInto.TryGetValue(node, out nodes))
                        nodes.Add(parent);
                    else
                    {
                        nodes = new List<BBSTNode> { parent };
                        BackwardEdgesInto.Add(node, nodes);
                    }
                }
                else if (IsAncestor(parent, node))
                    parent.ForwardEdges.Add(node);
                else
                    parent.CrossEdges.Add(node);
            }
            else
            {
                node = new BBSTNode(block, parent);
                visited.Add(block, node);
                parent.Successors.Add(node);
                var ancestor = parent;
                do
                {
                    var nodes = default(HashSet<BBSTNode>);
                    if (StrictDescendentsOf.TryGetValue(ancestor, out nodes))
                        nodes.Add(node);
                    else
                        StrictDescendentsOf.Add(ancestor, new HashSet<BBSTNode> { node });
                    ancestor = ancestor.Parent;
                }
                while (ancestor != null);
                foreach (var t in block.Targets)
                    DepthFirstSpanningTreeFrom(t, node, visited);
            }
        }

        public BasicBlockSpanningTree(BasicBlock root)
        {
            BackwardEdgesInto = new Dictionary<BBSTNode, List<BBSTNode>>();
            StrictDescendentsOf = new Dictionary<BBSTNode, HashSet<BBSTNode>>();
            Root = DepthFirstSpanningTree(root);
        }

        public IList<BBSTNode> PostOrder()
        {
            var res = new List<BBSTNode>();
            PostOrderFrom(Root, res);
            return res;
        }

        private void PostOrderFrom(BBSTNode node, IList<BBSTNode> res)
        {
            foreach (var s in node.Successors)
                PostOrderFrom(s, res);
            res.Add(node);
        }
    }
}


    // ----------------------------------------------------------------------
    // Statements
    // ----------------------------------------------------------------------

    public abstract class Statement { }

    public class ExpressionStatement
    {
        public Expression Value;
    }

    public class BlockStatement : Statement
    {
        public IList<Statement> Body;
    }

    public class ThrowStatement : Statement
    {
        public Expression Exception;
    }

    public class RethrowStatement : Statement
    {
        public Expression Exception;
    }

    public class AssignmentStatement : Statement
    {
        public Expression Address;
        public Expression Value;
        public CST.TypeRef ContentType;
    }

    public class ReturnStatement : Statement
    {
        public Expression Value;
    }

    public class IfThenStatement : Statement
    {
        public Expression Condition;
        public Statement Then;
    }

    public class IfThenElseStatement : Statement
    {
        public Expression Condition;
        public Statement Then;
        public Statement Else;
    }

    public class SwitchStatement : Statement
    {
        public Expression Value;
        public IList<Statement> Cases;
        public Statement Default;
    }

    public class LoopStatement : Statement
    {
        public Statement Body;
    }

    public class DoWhileStatement : Statement
    {
        public Statement Body;
        public Expression Condition;
    }

    public class WhileDoStatement : Statement
    {
        public Expression Condition;
        public Statement Body;
    }

    public class InitializeObjectStatement : Statement
    {
        public Expression Address;
        public CST.TypeRef Type;
    }

    public class TryStatement : Statement
    {
        public Statement Body;
        public IList<Handler> Handlers;
    }

    public abstract class Handler
    {
        public Statement Body;
    }

    public class CatchHandler : Handler
    {
        public JST.Identifier ExceptionId;
        public CST.TypeRef Type;
    }

    public class FaultHandler : Handler { }

    public class FinallyHandler : Handler { }




                case InstructionStyle.Try:
                {
                    var tryi = (TryInstruction)instruction;
                    var effects = EffectsOfInstructions(tryi.Body, bottom);
                    foreach (var h in tryi.Handlers)
                    {
                        effects = effects.Lub(EffectsOfInstructions(h.Body, bottom));
                        switch (h.Style)
                        {
                            case HandlerStyle.Catch:
                            case HandlerStyle.Fault:
                            case HandlerStyle.Finally:
                                break;
                            case HandlerStyle.Filter:
                            {
                                var filterh = (FilterHandler)h;
                                effects = effects.Lub(EffectsOfInstructions(filterh.FilterBody, bottom));
                                break;
                            }
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                    }
                    return effects;
                    break;
                }
                case InstructionStyle.IfThenElse:
                {
                    var itei = (IfThenElseInstruction)instruction;
                    var effects = EffectsOfInstructions(itei.Condition, bottom);
                    effects = effects.Lub(EffectsOfInstructions(itei.Then, bottom));
                    if (itei.Else != null)
                        effects = effects.Lub(EffectsOfInstructions(itei.Else, bottom));
                    return effects;
                }
                case InstructionStyle.ShortCircuiting:
                {
                    var shorti = (ShortCircuitingInstruction)instruction;
                    var effects = EffectsOfInstructions(shorti.Left, bottom);
                    effects = effects.Lub(EffectsOfInstructions(shorti.Right, bottom));
                    return effects;
                }
                case InstructionStyle.StructuralSwitch:
                {
                    var switchi = (StructuralSwitchInstruction)instruction;
                    var effects = EffectsOfInstructions(switchi.Body, bottom);
                    foreach (var c in switchi.Cases)
                        effects = effects.Lub(EffectsOfInstructions(c.Body, bottom));
                    return effects;
                }
                case InstructionStyle.Loop:
                {
                    // NOTE: No fixed points here! Effectfullness of instructions does not depend on effectfullness
                    //       of other instructions, only the points-to analysis which is already at a fixed point
                    var loopi = (LoopInstruction)instruction;
                    return EffectsOfInstructions(loopi.Body, bottom);
                }
                case InstructionStyle.WhileDo:
                {
                    var whiledoi = (WhileDoInstruction)instruction;
                    var effects = EffectsOfInstructions(whiledoi.Condition, bottom);
                    effects = effects.Lub(EffectsOfInstructions(whiledoi.Body, bottom));
                    return effects;
                }
                case InstructionStyle.DoWhile:
                {
                    var dowhilei = (DoWhileInstruction)instruction;
                    return EffectsOfInstructions(dowhilei.Condition, bottom);
                }
                case InstructionStyle.LoopControl:
                    return bottom;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public Effects EffectsOfInstructions(IList<Instruction> instructions)
        {
            var effects = bottom;
            for (var i = 0; i < instructions.Count; i++)
            {
                if (i > 0 && instructions[i - 1].NeverReturns)
                    init = bottom;
                init = init.Lub(EffectsOfInstruction(instructions[i]));
            }
            return init;
        }


        public bool IsEquivalentTo(Environment env, StackShape other)
        {
            if (Depth != other.Depth)
                return false;
            for (var i = 0; i < Depth; i++)
            {
                if (!entries[i].HasValue || !other.entries[i].HasValue)
                    return false;
                if (!entries[i].Value.IsEquivalentTo(env, other.entries[i].Value))
                    return false;
            }
            return true;
        }



        public void AllocIds(Func<JST.Identifier> gensym)
        {
            var set = new HashSet<JST.Identifier>();
            for (var i = 0; i < ids.Count; i++)
            {
                if (!ids[i].HasValue)
                    ids[i].Bind(gensym());
                if (!set.Add(ids[i].Value))
                    // This should never happen
                    throw new InvalidOperationException("over-constrained stack: some stack entries share the same identifier");
            }
        }



        private static void CollectInnerLeaveInstructions(IList<Instruction> instructions, List<BranchInstruction> leaves)
        {
            foreach (var instruction in instructions)
            {
                switch (instruction.Style)
                {
                    case InstructionStyle.Branch:
                    {
                        var branchi = (BranchInstruction)instruction;
                        if (branchi.Op == BranchOp.Leave)
                            leaves.Add(branchi);
                        break;
                    }
                    case InstructionStyle.Try:
                    {
                        var tryi = (TryInstruction)instruction;
                        CollectInnerLeaveInstructions(tryi.Body, leaves);
                        for (var j = 0; j < tryi.Handlers.Count; j++)
                        {
                            if (tryi.Handlers[j].Style == HandlerStyle.Catch)
                                CollectInnerLeaveInstructions(tryi.Handlers[j].Body, leaves);
                        }
                        break;
                    }
                    case InstructionStyle.Unsupported:
                    case InstructionStyle.Misc:
                    case InstructionStyle.Switch:
                    case InstructionStyle.Compare:
                    case InstructionStyle.Arg:
                    case InstructionStyle.Local:
                    case InstructionStyle.Field:
                    case InstructionStyle.Method:
                    case InstructionStyle.Type:
                    case InstructionStyle.LdElemAddr:
                    case InstructionStyle.LdInt32:
                    case InstructionStyle.LdInt64:
                    case InstructionStyle.LdSingle:
                    case InstructionStyle.LdDouble:
                    case InstructionStyle.LdString:
                    case InstructionStyle.Arith:
                    case InstructionStyle.Conv:
                        // Not structural instructions
                        break;
                    case InstructionStyle.IfThenElse:
                    case InstructionStyle.ShortCircuiting:
                    case InstructionStyle.StructuralSwitch:
                    case InstructionStyle.Loop:
                    case InstructionStyle.WhileDo:
                    case InstructionStyle.DoWhile:
                    case InstructionStyle.LoopControl:
                        // No leaves inside structural statements
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }
        }



        public IList<BranchInstruction> InnerLeaveInstructions
        {
            get
            {
                var res = new List<BranchInstruction>();
                CollectInnerLeaveInstructions(Body, res);
                return res;
            }
        }



Arithmetic
~~~~~~~~~~

The CLR (like most microarchitectures) defers the interpretation of words as signed vs unsigned to the
operators rather than the operands. At the same time it allows wider words to be truncated (explicitly using
conv, stind etc, and implicitly when making method calls) to narrower words without requiring the original
sign of the word to be specified, only the sign of the target. Meanwhile JavaScript just has floats, which
are always signed. Since signed values are the common case, and truncation is rare, we use the following
scheme for pushing and poping values on the stack.

In the following we use:
   v = value of width n bits (signed or unsigned)
   w = stack value of width m bits

For signed:

   Push(v) = v                               (where m >= n)
    Pop(w) = ((w+2^m+2^(n-1))%2^n)-2^(n-1)   (where m >= n)

and thus:

    Pop(w) = w                               (if m = n)
    Pop(Push(v)) = v                         (if m = n)

For unsigned:

   Push(v) = ((v+2^(m-1))%2^m)-2^(m-1)       (where m >= n)
    Pop(w) = (w+2^n)%2^n                     (where m >= n)

and thus:

    Pop(Push(v)) = v                         (if m = n)




            else if (methodDefn.DeclaringMember != null && methodDefn.DeclaringMember is CCI.Event)
            {
                // XREF1151
                // Event adder/remover
                var evnt = (CCI.Event)methodDefn.DeclaringMember;
                var unmanagedDelegateId = localEnv.GenSym();
                if (!methodDefn.IsStatic && captureThis)
                {
                    var id = nestedLocalenv.GenSym();
                    function.Parameters.Add(
                }
                function.Parameters.Add(unmanagedDelegateId);
                var delegateTypeId = localEnv.ResolveTypeToIdentifier(evnt.HandlerType, TypePhase.Names);
                var slotId = new JST.Identifier
                    (Constants.ObjectEventSlot(env.GlobalMapping.ResolveEventDefinitionToSlot(evnt)));
                var slotExp = JST.Expression.Dot
                    (methodDefn.IsStatic ? declTypeId.ToE() : managedInstanceId.ToE(), slotId);
                var managedDelegateId = localEnv.GenSym();
                var tryBody = new JST.Statements();
                tryBody.Add
                    (JST.Statement.Var
                         (managedDelegateId,
                          JST.Expression.DotCall(delegateTypeId.ToE(), Constants.TypeImport, unmanagedDelegateId.ToE())));
                if (methodDefn == evnt.HandlerAdder)
                {
                    tryBody.Add
                        (new JST.IfStatement
                             (JST.Expression.IsNull(slotExp),
                              JST.Statement.Assignment(slotExp, managedDelegateId.ToE()),
                              JST.Statement.Assignment
                                  (slotExp,
                                   JST.Expression.DotCall
                                       (localEnv.RootId.ToE(),
                                        Constants.RootCombineDelegates,
                                        slotExp,
                                        managedDelegateId.ToE()))));
                }
                else if (methodDefn == evnt.HandlerRemover)
                {
                    tryBody.Add
                        (new JST.IfStatement
                             (JST.Expression.IsNull(slotExp),
                              new JST.ThrowStatement
                                  (JST.Expression.DotCall(localEnv.RootId.ToE(), Constants.RootInvalidOperationException)),
                              JST.Statement.Assignment
                                  (slotExp,
                                   JST.Expression.DotCall
                                       (localEnv.RootId.ToE(),
                                        Constants.RootRemoveAllDelegates,
                                        slotExp,
                                        managedDelegateId.ToE()))));
                }
                else
                    throw new ArgumentException();
                function.Body.Add(WrapTryCatch(localEnv, tryBody, false));
                return function;
            }




        private void EmitImportedMethodBody(JST.Statements statements)
        {
            var script = JSTHelpers.ImportedFunction(MethodLocalEnv, MethodDefn);
            var lastArgIsParamArray =
                MethodDefn.Parameters[MethodDefn.Parameters.Length - 1].GetParamArrayAttribute() != null;
            var exp = default(JST.Expression);
            if (lastArgIsParamArray)
            {
                var arrId = MethodLocalEnv.GenSym();
                statements.Add(JST.Statement.Var(arrId, new JST.ArrayLiteral()));
                for (var i = 0; i < MethodLocalEnv.Parameters.Count - 1; i++)
                    statements.Add(JST.Statement.DotCall(arrId.ToE(), Constants.push, MethodLocalEnv.Parameters[i].ToE()));
                var paramsId = MethodLocalEnv.Parameters[MethodLocalEnv.Parameters.Count - 1];
                var iId = MethodLocalEnv.GenSym();
                statements.Add(
                    new JST.IfStatement(
                        JST.Expression.IsNotNull(paramsId.ToE()),
                        new JST.ForStatement(
                            new JST.ForVarLoopClause(iId, new JST.NumericLiteral(0),
                                                     new JST.BinaryExpression(iId.ToE(),
                                                                              new JST.
                                                                                  LessThan(),
                                                                              JST.Expression.
                                                                                  Dot(
                                                                                  paramsId.
                                                                                      ToE(),
                                                                                  Constants.
                                                                                      length)),
                                                     new JST.UnaryExpression(iId.ToE(),
                                                                             new JST.
                                                                                 PostIncrement
                                                                                 ())),
                            JST.Statement.DotCall(arrId.ToE(), Constants.push,
                                                  new JST.IndexExpression(paramsId.ToE(),
                                                                          iId.ToE())))));
                var fId = MethodLocalEnv.GenSym();
                statements.Add(JST.Statement.Var(fId, script));
                exp = JST.Expression.DotCall(fId.ToE(), Constants.apply, new JST.Null(), arrId.ToE());
            }
            else
            {
                var args = new List<JST.Expression>();
                foreach (var id in MethodLocalEnv.Parameters)
                    args.Add(id.ToE());
                exp = JST.Expression.Apply(MethodLocalEnv.GenSym, script, args);
            }
            if (env.MethodEnv.ReturnType(MethodDefn) == null)
                statements.Add(exp.ToStatement());
            else
                statements.Add(new JST.ReturnStatement(exp));
        }


        // ----------------------------------------------------------------------
        // For CCI only
        // ----------------------------------------------------------------------

        public static MessageContext Member(CCI.Member member)
        {
            return Member(null, member);
        }

        public static MessageContext Member(MessageContext parent, CCI.Member member)
        {
            var loc = default(CST.Location);
            if (member.SourceContext.Document != null)
                loc = member.SourceContext.ToLocation();
            else if (member.Name != null && member.Name.SourceContext.Document != null)
                loc = member.Name.SourceContext.ToLocation();

            return new MessageContext
                (parent,
                 loc,
                 sb =>
                 {
                     sb.Append("Member ");
                     sb.Append(member.FullName);
                 });
        }

        public static MessageContext Method(CCI.Method method)
        {
            return Method(null, method);
        }

        public static MessageContext Method(MessageContext parent, CCI.Method method)
        {
            var loc = default(CST.Location);
            if (method.SourceContext.Document != null)
                loc = method.SourceContext.ToLocation();
            else if (method.Name != null && method.Name.SourceContext.Document != null)
                loc = method.Name.SourceContext.ToLocation();
            else if (method.Instructions != null && method.Instructions.Count > 1 &&
                     method.Instructions[1].SourceContext.Document != null)
                loc = method.Instructions[1].SourceContext.ToLocation();
            return new MessageContext
                (parent,
                 loc,
                 sb =>
                 {
                     sb.Append("Method ");
                     sb.Append(method.FullName);
                 });
        }

        public static MessageContext Type(CCI.TypeNode type)
        {
            return Type(null, type);
        }

        public static MessageContext Type(MessageContext parent, CCI.TypeNode type)
        {
            var loc = default(CST.Location);
            if (type.SourceContext.Document != null)
                loc = type.SourceContext.ToLocation();
            else if (type.Name != null && type.Name.SourceContext.Document != null)
                loc = type.Name.SourceContext.ToLocation();
            return new MessageContext
                (parent,
                 loc,
                 sb =>
                 {
                     sb.Append("Type ");
                     sb.Append(type.FullName);
                 });
        }


        public static MessageContext Field(CCI.Field field)
        {
            return Field(null, field);
        }

        public static MessageContext Field(MessageContext parent, CCI.Field field)
        {
            var loc = default(CST.Location);
            if (field.SourceContext.Document != null)
                loc = field.SourceContext.ToLocation();
            else if (field.Name != null && field.Name.SourceContext.Document != null)
                loc = field.Name.SourceContext.ToLocation();
            return new MessageContext(parent, loc, sb => sb.Append(field.FullName));
        }

        public static MessageContext Event(CCI.Event evnt)
        {
            return Event(null, evnt);
        }

        public static MessageContext Event(MessageContext parent, CCI.Event evnt)
        {
            var loc = default(CST.Location);
            if (evnt.SourceContext.Document != null)
                loc = evnt.SourceContext.ToLocation();
            else if (evnt.Name != null && evnt.Name.SourceContext.Document != null)
                loc = evnt.Name.SourceContext.ToLocation();
            return new MessageContext(parent, loc, sb => { sb.Append(evnt.FullName); });
        }

        public static MessageContext Property(CCI.Property prop)
        {
            return Property(null, prop);
        }

        public static MessageContext Property(MessageContext parent, CCI.Property prop)
        {
            var loc = default(CST.Location);
            if (prop.SourceContext.Document != null)
                loc = prop.SourceContext.ToLocation();
            else if (prop.Name != null && prop.Name.SourceContext.Document != null)
                loc = prop.Name.SourceContext.ToLocation();
            return new MessageContext(parent, loc, sb => { sb.Append(prop.FullName); });
        }

        public static MessageContext Assembly(CCI.AssemblyNode assembly)
        {
            return Assembly(null, assembly);
        }

        public static MessageContext Assembly(MessageContext parent, CCI.AssemblyNode assembly)
        {
            var loc = default(CST.Location);
            if (assembly.SourceContext.Document != null)
                loc = assembly.SourceContext.ToLocation();
            return new MessageContext
                (parent,
                 loc,
                 sb =>
                 {
                     sb.Append("Assembly ");
                     sb.Append(assembly.StrongName);
                 });
        }

        public static MessageContext Instruction(CCI.Method method, int index)
        {
            return Instruction(null, method, index);
        }

        public static MessageContext Instruction(MessageContext parent, CCI.Method method, int index)
        {
            var loc = default(CST.Location);
            if (method.Instructions[index].SourceContext.Document != null)
                loc = method.Instructions[index].SourceContext.ToLocation();
            return new MessageContext
                (parent,
                 loc,
                 sb =>
                 {
                     sb.Append("Instruction ");
                     sb.Append(method.Instructions[index].OpCode.ToString());
                     sb.Append(" offset ");
                     sb.Append(method.Instructions[index].Offset);
                 });
        }

        public static MessageContext AttributeProperty(CCI.AttributeNode attr, string property)
        {
            return AttributeProperty(null, attr, property);
        }

        public static MessageContext AttributeProperty(MessageContext parent, CCI.AttributeNode attr, string property)
        {
            var loc = default(CST.Location);
            if (attr.SourceContext.Document != null)
                loc = attr.SourceContext.ToLocation();
            return new MessageContext
                (parent,
                 loc,
                 sb =>
                 {
                     sb.Append("Custom attribute ");
                     sb.Append(attr.Type.FullName);
                     sb.Append(" property ");
                     sb.Append(property);
                 });
        }


                // DEMO HACK
                // private static void QuickSort<TKey, TValue>(TKey[] keys, TValue[] values, int left, int right, IComparer<TKey> comparer)
                var p0 = new CST.ParameterTypeRef(CST.ParameterFlavor.Method, 0);
                var p1 = new CST.ParameterTypeRef(CST.ParameterFlavor.Method, 1);
                var icomparerName = new CST.QualifiedTypeName(global.MsCorLibName, new CST.TypeName("System.Collections.Generic.IComparer`1"));
                var sigArgs = new AList<CST.TypeRef> {
                    CST.TypeRef.ArrayOf(global, p0),
                    CST.TypeRef.ArrayOf(global, p1),
                    global.Int32Ref,
                    global.Int32Ref,
                    new CST.NamedTypeRef(icomparerName, p0)
                };
                var methodRef = new CST.PolymorphicMethodRef(global.ArrayRef, "QuickSort", true, 2, sigArgs, null);
                var memEnv = methodRef.Enter(global.Environment());
                var methEnv = memEnv.AddSelfMethodBoundArguments();
                var methodCompiler = new MethodCompiler(env, methEnv, trace);
                methodCompiler.ValueFunctionExpression();


    root.FieldName = function(isStatic, simpleFieldName, fieldType) {
        var sb = [];
        root.AppendFieldName(sb, isStatic, simpleFieldName, fieldType);
        return sb.join("");
    };

    root.AppendFieldName = function(sb, isStatic, simpleFieldName, fieldType) {
        sb.push("field ", isStatic ? "static " : "instance ", simpleFieldName);
        if (fieldType != null) {
            sb.push(":");
            root.AppendQualifiedTypeName(sb, fieldType.Assembly, fieldType.Name);
        }
    };

    root.QualifiedFieldName = function(declType, isStatic, simpleFieldName, fieldType) {
        var sb = [];
        root.AppendQualifiedTypeName(sb, declType.Assembly, declType.Name);
        sb.push("::");
        root.AppendFieldName(sb, isStatic, simpleFieldName, fieldType);
        return sb.join("");
    };

    root.EventName = function(isStatic, simpleEventName, handlerType) {
        var sb = [];
        root.AppendEventName(sb, isStatic, simpleEventName, handlerType);
        return sb.join("");
    };

    root.AppendEventName = function(sb, isStatic, simpleEventName, handlerType) {
        sb.push("event ", isStatic ? "static " : "instance ", simpleEventName, ":");
        root.AppendQualifiedTypeName(sb, handlerType.Assembly, handlerType.Name);
    };

    root.QualifiedEventName = function(declType, isStatic, simpleEventName, handlerType) {
        var sb = [];
        root.AppendQualifiedTypeName(sb, declType.Assembly, declType.Name);
        sb.push("::");
        root.AppendEventName(sb, isStatic, simpleEventName, handlerType);
        return sb.join("");
    };

    root.PropertyName = function(isStatic, simplePropertyName, type) {
        var sb = [];
        root.AppendPropertyName(sb, isStatic, simplePropertyName, type);
        return sb.join("");
    };

    root.AppendPropertyName = function(sb, isStatic, simplePropertyName, type) {
        sb.push("property ", isStatic ? "static " : "instance ", simplePropertyName, ":");
        root.AppendQualifiedTypeName(sb, type.Assembly, type.Name);
    };

    root.QualifiedPropertyName = function(declType, isStatic, simplePropertyName, type) {
        var sb = [];
        root.AppendQualifiedTypeName(sb, declType.Assembly, declType.Name);
        sb.push("::");
        root.AppendPropertyName(sb, isStatic, simplePropertyName, type);
        return sb.join("");
    };





        public static JST.Expression ReadExpressionForType
            (AssemblyLocalEnv localEnv, CCI.TypeNode type, JST.Expression obj)
        {
            var env = localEnv.Env;
            var typeRef = env.TypeEnv.ToReference(type);
            switch (typeRef.Flavor)
            {
                case TypeFlavor.Pointer:
                case TypeFlavor.FunctionPointer:
                    throw new InvalidOperationException("pointers are not supported");
                case TypeFlavor.Void:
                    throw new InvalidOperationException("void has no values");
                case TypeFlavor.Array:
                case TypeFlavor.Reference:
                case TypeFlavor.Class:
                case TypeFlavor.Delegate:
                case TypeFlavor.Interface:
                case TypeFlavor.String:
                case TypeFlavor.Handle:
                    // No-op
                    return obj;
                case TypeFlavor.Nullable:
                case TypeFlavor.Number:
                case TypeFlavor.Struct:
                case TypeFlavor.Boolean:
                case TypeFlavor.Enum:
                    // Inline
                    return CloneExpressionForType(localEnv, type, JST.Expression.DotCall(obj, Constants.PointerRead));
                case TypeFlavor.Parameter:
                    // Defer to type
                    return JST.Expression.DotCall
                        (localEnv.ResolveTypeToIdentifier(type, TypePhase.Constructed).ToE(),
                         Constants.TypeRead,
                         obj);
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public static JST.Expression UnboxExpressionForType
            (AssemblyLocalEnv localEnv, CCI.TypeNode type, JST.Expression obj)
        {
            var env = localEnv.Env;
            var typeRef = env.TypeEnv.ToReference(type);
            switch (typeRef.Flavor)
            {
                case TypeFlavor.Pointer:
                case TypeFlavor.FunctionPointer:
                    throw new InvalidOperationException("pointers are not supported");
                case TypeFlavor.Void:
                    throw new InvalidOperationException("void has no values");
                case TypeFlavor.Array:
                case TypeFlavor.Reference:
                case TypeFlavor.Class:
                case TypeFlavor.Delegate:
                case TypeFlavor.Interface:
                case TypeFlavor.String:
                    throw new InvalidOperationException("cannot unbox a reference type");
                case TypeFlavor.Struct:
                case TypeFlavor.Boolean:
                case TypeFlavor.Enum:
                case TypeFlavor.Nullable:
                case TypeFlavor.Parameter:
                    // Defer to type
                    return JST.Expression.DotCall
                        (localEnv.ResolveTypeToIdentifier(type, TypePhase.Constructed).ToE(),
                         Constants.TypeUnbox,
                         obj);
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public static JST.Expression UnboxAnyExpressionForType
            (AssemblyLocalEnv localEnv, CCI.TypeNode type, JST.Expression obj)
        {
            var env = localEnv.Env;
            var typeRef = env.TypeEnv.ToReference(type);
            switch (typeRef.Flavor)
            {
                case TypeFlavor.Pointer:
                case TypeFlavor.FunctionPointer:
                    throw new InvalidOperationException("pointers are not supported");
                case TypeFlavor.Void:
                    throw new InvalidOperationException("void has no values");
                case TypeFlavor.Array:
                case TypeFlavor.Reference:
                case TypeFlavor.Class:
                case TypeFlavor.Delegate:
                case TypeFlavor.Interface:
                case TypeFlavor.String:
                case TypeFlavor.Handle:
                    {
                        // Inline
                        var typeExp = localEnv.ResolveTypeToIdentifier(type, TypePhase.Constructed).ToE();
                        return JST.Expression.DotCall(localEnv.RootId.ToE(), Constants.RootCastClass, typeExp, obj);
                    }
                case TypeFlavor.Struct:
                case TypeFlavor.Boolean:
                case TypeFlavor.Enum:
                case TypeFlavor.Number:
                case TypeFlavor.Nullable:
                case TypeFlavor.Parameter:
                    // Defer to type
                    return JST.Expression.DotCall
                        (localEnv.ResolveTypeToIdentifier(type, TypePhase.Constructed).ToE(),
                         Constants.TypeUnboxAny,
                         obj);
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }


        // XREF1087

        private void EmitHigherKindedTypeBuilder(Resolver subResolver, IImSeq<JST.Identifier> parameters, ISeq<JST.Statement> body, CST.TypeConstructorEnvironment tyconEnv)
        {
            var slot = env.GlobalMapping.ResolveTypeDefinitionToSlot(tyconEnv);
            var phaseId = parameters[0];
            var args = new Seq<JST.Expression>();
            for (var i = 1; i < parameters.Count; i++)
                args.Add(parameters[i].ToE());
            var typeStructId = subResolver.GenSym();
            body.Add
                (JST.Statement.Var
                     (typeStructId,
                      JST.Expression.DotCall
                          (subResolver.AssemblyId.ToE(),
                           new JST.Identifier(Constants.AssemblyTypeConstructorBuilderSlot(slot)))));
            var slotNameId = subResolver.GenSym();
            body.Add
                (JST.Statement.Var
                     (slotNameId, Resolver.SlotName(subResolver.RootId, Constants.AssemblyCachedTypeSlot(slot), args)));
            var slotExp = new JST.IndexExpression(subResolver.AssemblyId.ToE(), slotNameId.ToE());
            body.Add
                (new JST.IfStatement
                     (JST.Expression.IsNull(slotExp),
                      JST.Statement.Assignment
                          (slotExp, JST.Expression.DotCall(typeStructId.ToE(), Constants.TypeInstantiate, args))));
            body.Add
                (JST.Statement.DotCall(subResolver.RootId.ToE(), Constants.RootEnsurePhase, slotExp, phaseId.ToE()));
            body.Add(new JST.ReturnStatement(slotExp));
        }

        private void BindHigherKindedTypeBuilderFunction(ISeq<JST.Statement> body, CST.TypeConstructorEnvironment tyconEnv)
        {
            var slot = env.GlobalMapping.ResolveTypeDefinitionToSlot(tyconEnv);
            var function = resolver.MakeFunction(1 + tyconEnv.Type.Arity, (subResolver, parameters, subBody) => EmitHigherKindedTypeBuilder(subResolver, parameters, subBody, tyconEnv));
            body.Add
                (JST.Statement.DotAssignment
                     (resolver.AssemblyId.ToE(),
                      new JST.Identifier(Constants.AssemblyTypeBuilderSlot(slot)),
                      function));
        }



        // XREF1069

        private void EmitFirstKindedTypeBuilder(Resolver subResolver, IImSeq<JST.Identifier> parameters, ISeq<JST.Statement> body, CST.TypeConstructorEnvironment tyconEnv)
        {
            var slot = env.GlobalMapping.ResolveTypeDefinitionToSlot(tyconEnv);
            var phaseId = parameters[0];
            var nm = CST.CSTWriter.WithAppend
                (env.Global, CST.WriterStyle.Uniform, tyconEnv.Type.EffectiveName(env.Global).Append);
            body.Add
                (JST.Statement.DotCall
                     (subResolver.RootId.ToE(),
                      Constants.RootLoadType,
                      subResolver.AssemblyId.ToE(),
                      new JST.StringLiteral(Constants.AssemblyCachedTypeSlot(slot)),
                      new JST.StringLiteral(nm)));
            var typeStructId = subResolver.GenSym();
            body.Add
                (JST.Statement.Var
                     (typeStructId,
                      new JST.IndexExpression(subResolver.AssemblyId.ToE(), Constants.AssemblyCachedTypeSlot(slot))));
            var updatedFunc = new JST.FunctionExpression
                (parameters,
                 new Seq<JST.Statement>
                     {
                         JST.Statement.DotCall
                             (subResolver.RootId.ToE(), Constants.RootEnsurePhase, typeStructId.ToE(), phaseId.ToE()),
                         new JST.ReturnStatement(typeStructId.ToE())
                     });
            body.Add
                (JST.Statement.DotAssignment
                     (subResolver.AssemblyId.ToE(), new JST.Identifier(Constants.AssemblyTypeBuilderSlot(slot)), updatedFunc));
            body.Add
                (JST.Statement.DotCall
                     (subResolver.RootId.ToE(), Constants.RootEnsurePhase, typeStructId.ToE(), phaseId.ToE()));
            body.Add(new JST.ReturnStatement(typeStructId.ToE()));
        }

        private void BindFirstKindedTypeBuilderFunction(ISeq<JST.Statement> body, CST.TypeConstructorEnvironment tyconEnv)
        {
            var slot = env.GlobalMapping.ResolveTypeDefinitionToSlot(tyconEnv);
            var function = resolver.MakeFunction(1, (subResolver, parameters, subBody) => EmitFirstKindedTypeBuilder(subResolver, parameters, subBody, tyconEnv));
            body.Add
                (JST.Statement.DotAssignment
                     (resolver.AssemblyId.ToE(),
                      new JST.Identifier(Constants.AssemblyTypeBuilderSlot(slot)),
                      function));
        }

        // XREF1091

        private void EmitHigherKindedConstructorBuilder(Resolver subResolver, IImSeq<JST.Identifier> parameters, ISeq<JST.Statement> body, CST.TypeConstructorEnvironment tyconEnv)
        {
            var slot = env.GlobalMapping.ResolveTypeDefinitionToSlot(tyconEnv);
            var nm = CST.CSTWriter.WithAppend
                (env.Global, CST.WriterStyle.Uniform, tyconEnv.Type.EffectiveName(env.Global).Append);
            body.Add
                (JST.Statement.DotCall
                     (subResolver.RootId.ToE(),
                      Constants.RootLoadType,
                      subResolver.AssemblyId.ToE(),
                      new JST.StringLiteral(Constants.AssemblyCachedTypeSlot(slot)),
                      new JST.StringLiteral(nm)));
            var typeStructId = subResolver.GenSym();
            body.Add
                (JST.Statement.Var
                     (typeStructId,
                      new JST.IndexExpression(subResolver.AssemblyId.ToE(), Constants.AssemblyCachedTypeSlot(slot))));
            var updatedFunc = new JST.FunctionExpression(null, new JST.ReturnStatement(typeStructId.ToE()));
            body.Add
                (JST.Statement.DotAssignment
                     (subResolver.AssemblyId.ToE(),
                      new JST.Identifier(Constants.AssemblyTypeConstructorBuilderSlot(slot)),
                      updatedFunc));
            body.Add(new JST.ReturnStatement(typeStructId.ToE()));
        }

        private void BindHigherKindedConstructorBuilderFunction(ISeq<JST.Statement> body, CST.TypeConstructorEnvironment tyconEnv)
        {
            var slot = env.GlobalMapping.ResolveTypeDefinitionToSlot(tyconEnv);
            var function = resolver.MakeFunction
                (0,
                 (subResolver, parameters, subBody) =>
                 EmitHigherKindedConstructorBuilder(subResolver, parameters, subBody, tyconEnv));
            body.Add
                (JST.Statement.IndexAssignment
                     (resolver.AssemblyId.ToE(),
                      new JST.StringLiteral(Constants.AssemblyTypeConstructorBuilderSlot(slot)),
                      function));
        }




                    var slotId = new JST.Identifier());
                    var outerBody = new Seq<JST.Statement>();
                    var refAssemblyId = NameSupply.GenSym();
                    var snStr = CST.CSTWriter.WithAppend(Env.Global, WriterStyle.Uniform, assemblyName.Append);
                    outerBody.Add
                        (JST.Statement.Var
                             (refAssemblyId,
                              JST.Expression.DotCall
                                  (RootId.ToE(), Constants.RootResolveAssembly, new JST.StringLiteral(snStr))));
                    outerBody.Add
                        (new JST.IfStatement
                             (JST.Expression.IsNotNull
                                  (JST.Expression.Dot(refAssemblyId.ToE(), Constants.AssemblyInitialize)),
                              JST.Statement.DotCall(refAssemblyId.ToE(), Constants.AssemblyInitialize)));
                    var inner = new JST.FunctionExpression(null, new JST.ReturnStatement(refAssemblyId.ToE()));
                    outerBody.Add(JST.Statement.DotAssignment(AssemblyId.ToE(), slotId, inner));
                    outerBody.Add(new JST.ReturnStatement(refAssemblyId.ToE()));
                    var outer = new JST.FunctionExpression(null, outerBody);
                    body.Add(JST.Statement.DotAssignment(AssemblyId.ToE(), slotId, outer));



        // XREF1381
        // XREF1399

        private void EmitRedirectorFunction(Resolver subResolver, IImSeq<JST.Identifier> parameters, ISeq<JST.Statement> body, CST.MethodDef methodDef)
        {
            var tyconMemEnv = typeEnv.ForgetTypeBoundArguments().AddMember(methodDef);
            var typeExp = subResolver.TypeId.ToE();
            var slot = env.GlobalMapping.ResolveMemberDefinitionToSlot(tyconMemEnv);
            var funcId = subResolver.GenSym();

            var builderSlotId = new JST.Identifier(Constants.TypeMethodBuilderSlot(slot));
            var cachedSlotExp = default(JST.Expression);

            if (methodDef.TypeArity > 0)
            {
                // Polymorphic method: The cached method slot depends on the method type parameters
                var slotId = subResolver.GenSym();
                body.Add
                    (JST.Statement.Var
                         (slotId,
                          Resolver.SlotName
                              (subResolver.RootId,
                               Constants.TypeCachedMethodSlot(slot),
                               parameters.Select(id => id.ToE()).ToSeq())));
                cachedSlotExp = new JST.IndexExpression(typeExp, slotId.ToE());
            }
            else
                // Monomorphic method: The cached method slot is fixed
                cachedSlotExp = new JST.IndexExpression(typeExp, Constants.TypeCachedMethodSlot(slot));

            // To protect against blackholes we must eta-expand the builder to yield a value function
            var builderSelfCall = new JST.CallExpression
                (JST.Expression.Dot(typeExp, builderSlotId), parameters.Select(id => id.ToE()).ToSeq());
            var etaParameters = new Seq<JST.Identifier>();
            var etaArgs = new Seq<JST.Expression>();
            for (var i = 0; i < methodDef.Arity; i++)
            {
                var id = subResolver.GenSym();
                etaParameters.Add(id);
                etaArgs.Add(id.ToE());
            }
            var etaValueFunction = new JST.FunctionExpression
                (etaParameters, new JST.ReturnStatement(new JST.CallExpression(builderSelfCall, etaArgs)));

            // The higher-kinded type has a builder function which, in turn, contains the value-level function
            var constArgs = new Seq<JST.Expression>();
            constArgs.Add(typeExp);
            foreach (var id in parameters)
                constArgs.Add(id.ToE());
            var valueFunction = new JST.CallExpression
                (JST.Expression.Dot
                     (subResolver.TypeConstructorId.ToE(), new JST.Identifier(Constants.TypeMethodBuilderSlot(slot))),
                 constArgs);

            if (methodDef.TypeArity > 0)
            {
                // Polymorphic functions: we must dynamically check if the desired instance of
                // the function has already been cached
                body.Add(JST.Statement.Var(funcId, cachedSlotExp));

                var thenStatements = new Seq<JST.Statement>
                                         {
                                             JST.Statement.Assignment(cachedSlotExp, etaValueFunction),
                                             JST.Statement.IdAssignment(funcId, valueFunction),
                                             JST.Statement.Assignment(cachedSlotExp, funcId.ToE())
                                         };

                body.Add(new JST.IfStatement(JST.Expression.IsNull(funcId.ToE()), thenStatements));
            }
            else
            {
                // Monomorphic functions: We can self-update this builder function to ensure
                // the value-level function is built at most once
                var retSelfFunction = new JST.FunctionExpression(null, new JST.ReturnStatement(funcId.ToE()));
                var retEtaValueFunction = new JST.FunctionExpression(null, new JST.ReturnStatement(etaValueFunction));

                var builderSlotExp = JST.Expression.Dot(typeExp, builderSlotId);

                body.Add(JST.Statement.Assignment(builderSlotExp, retEtaValueFunction));
                body.Add(JST.Statement.Var(funcId, valueFunction));
                body.Add(JST.Statement.Assignment(cachedSlotExp, funcId.ToE()));
                body.Add(JST.Statement.Assignment(builderSlotExp, retSelfFunction));
            }

            body.Add(new JST.ReturnStatement(funcId.ToE()));
        }


        // XREF1427
        // XREF1429

        // Method 'slot' is either the compiled method definition itself (which should be monomorphic and
        // virtual) or a monomorphic interface method for which 'impl' provides an implementation. 
        // Add binding into type structure with id for a self-updating value-level function which redirects
        // to underlying builder upon the first call.
        private void BindMonomorphicDirectCallFunction
            (Resolver subResolver,
             ISeq<JST.Statement> body,
             JST.Identifier typeStructId,
             CST.PolymorphicMethodRef slotMethodRef,
             CST.PolymorphicMethodRef implMethodRef)
        {
            var tyconMemEnv = implMethodRef.Enter(typeEnv).ForgetTypeBoundArguments();
            var implSlot = new JST.Identifier
                (Constants.TypeMethodBuilderSlot(env.GlobalMapping.ResolveMemberDefinitionToSlot(tyconMemEnv)));
            var thisSlotExpr = new JST.IndexExpression
                (typeStructId.ToE(), subResolver.SlotExpression(slotMethodRef, true));

            // Function takes method parameters as arguments
            var function = subResolver.MakeFunction
                (slotMethodRef.MethodArity,
                 (r, p, b) =>
                     {
                         var funcId = subResolver.GenSym();
                         b.Add(JST.Statement.Var(funcId, JST.Expression.DotCall(subResolver.TypeId.ToE(), implSlot)));
                         b.Add(JST.Statement.Assignment(thisSlotExpr, funcId.ToE()));
                         b.Add
                             (new JST.ReturnStatement
                                  (new JST.CallExpression(funcId.ToE(), p.Select(id => id.ToE()).ToSeq())));
                     });

            body.Add(JST.Statement.Assignment(thisSlotExpr, function));
        }



        // If method is interface or virtual, the virtual slot name. Otherwise the builder slot name.
        public JST.Expression CallingSlotName(CST.MethodRef methodRef, out bool isVirtualMethod)
        {
            var tyconMemEnv = methodRef.EnterConstructor(RootEnv);
            var slotNameBase = Env.GlobalMapping.ResolveMemberDefinitionToSlot(tyconMemEnv);

            var typeBoundArugments = default(Seq<JST.Expression>);
            if (tyconMemEnv.Type is CST.InterfaceTypeDef)
            {
                // The slot name for interface methods must include any interface type arguments
                typeBoundArugments =
                    methodRef.DefiningType.Arguments.Select
                        (t => ResolveTypeToIdentifier(t, TypePhase.Constructed).ToE()).ToSeq();
                isVirtualMethod = true;
            }
            else
                isVirtualMethod = tyconMemEnv.Method.IsVirtualOrAbstract;

            var slotNamePrefix = isVirtualMethod
                                     ? Constants.TypeVirtualMethodSlot(slotNameBase)
                                     : Constants.TypeMethodBuilderSlot(slotNameBase);

            return MakeSlotName(RootId, slotNamePrefix, typeBoundArugments);
        }



            // R
            if (env.DebugMode)
                inner.Add(new JST.CommentStatement("Read"));
            inner.Add(JST.Statement.DotAssignment(lhs, Constants.TypeRead, ReadFunction(subResolver)));



        // XREF1279
        private void EmitRead(Resolver subResolver, IImSeq<JST.Identifier> parameters, ISeq<JST.Statement> body)
        {
            var s = typeEnv.Type.Style;

            if (s is CST.VoidTypeStyle)
                body.Add
                    (new JST.ThrowStatement
                         (JST.Expression.DotCall(subResolver.RootId.ToE(), Constants.RootInvalidOperationException)));
            else if (s is CST.HandleTypeStyle || s is CST.ReferenceTypeStyle)
                body.Add(new JST.ReturnStatement(parameters[0].ToE()));
            else
                body.Add
                    (new JST.ReturnStatement(JST.Expression.DotCall(parameters[0].ToE(), Constants.PointerRead)));
        }

        private JST.Expression ReadFunction(Resolver subResolver)
        {
            return subResolver.MakeFunction(1, EmitRead);
        }



            // Bind self type
            if (compEnv.Type.Arity > 0)
                body.Add(JST.Statement.Var(resolver.TypeId, resolver.ResolveTypeToExpression(compEnv.ForgetMember().Exit, TypePhase.Constructed)));



        public const string JSNumberName = "Microsoft.LiveLabs.JavaScript.JSNumber";
        public const string JSStringName = "Microsoft.LiveLabs.JavaScript.JSString";
        public const string JSArrayName = "Microsoft.LiveLabs.JavaScript.JSArray";
        public const string JSDateName = "Microsoft.LiveLabs.JavaScript.JSDate";
        public const string JSRegExpName = "Microsoft.LiveLabs.JavaScript.JSRegExp";
        public const string JSFunctionName = "Microsoft.LiveLabs.JavaScript.JSFunction";
        public const string JSErrorName = "Microsoft.LiveLabs.JavaScript.JSError";
        public const string JSEvalErrorName = "Microsoft.LiveLabs.JavaScript.JSEvalError";
        public const string JSRangeErrorName = "Microsoft.LiveLabs.JavaScript.JSRangeError";
        public const string JSReferenceErrorName = "Microsoft.LiveLabs.JavaScript.JSReferenceError";
        public const string JSSyntaxErrorName = "Microsoft.LiveLabs.JavaScript.JSSyntaxError";
        public const string JSTypeErrorName = "Microsoft.LiveLabs.JavaScript.JSTypeError";
        public const string JSURIErrorName = "Microsoft.LiveLabs.JavaScript.JSURIError";


            JSNumberRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSNumberName)));
            JSStringRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSStringName)));
            JSArrayRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSArrayName)));
            JSDateRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSDateName)));
            JSRegExpRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSRegExpName)));
            JSFunctionRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSFunctionName)));
            JSErrorRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSErrorName)));
            JSEvalErrorRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSEvalErrorName)));
            JSRangeErrorRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSRangeErrorName)));
            JSReferenceErrorRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSReferenceErrorName)));
            JSSyntaxErrorRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSSyntaxErrorName)));
            JSTypeErrorRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSTypeErrorName)));
            JSURIErrorRef = new CST.NamedTypeRef
                (new CST.QualifiedTypeName(env.Global.MsCorLibName, new CST.TypeName(Constants.JSURIErrorName)));


        [NotNull]
        public readonly CST.TypeRef JSNumberRef;
        [NotNull]
        public readonly CST.TypeRef JSStringRef;
        [NotNull]
        public readonly CST.TypeRef JSArrayRef;
        [NotNull]
        public readonly CST.TypeRef JSDateRef;
        [NotNull]
        public readonly CST.TypeRef JSRegExpRef;
        [NotNull]
        public readonly CST.TypeRef JSFunctionRef;
        [NotNull]
        public readonly CST.TypeRef JSErrorRef;
        [NotNull]
        public readonly CST.TypeRef JSEvalErrorRef;
        [NotNull]
        public readonly CST.TypeRef JSRangeErrorRef;
        [NotNull]
        public readonly CST.TypeRef JSReferenceErrorRef;
        [NotNull]
        public readonly CST.TypeRef JSSyntaxErrorRef;
        [NotNull]
        public readonly CST.TypeRef JSTypeErrorRef;
        [NotNull]
        public readonly CST.TypeRef JSURIErrorRef;



        public bool MemberHasAttribute<T>(CST.TypeConstructorMemberEnvironment<T> tyconMemEnv, AttributeType attrType, bool inheritable) where T : MemberDef
        {
            switch (tyconMemEnv.Member.Flavor)
            {
            case MemberDefFlavor.Field:
                return false;
            case MemberDefFlavor.Method:
                return MethodHasAttribute(tyconMemEnv.ForMethod, attrType, inheritable);
            case MemberDefFlavor.Event:
                return EventHasAttribute(tyconMemEnv.ForEvent, attrType, inheritable);
            case MemberDefFlavor.Property:
                return PropertyHasAttribute(tyconMemEnv.ForProperty, attrType, inheritable);
            default:
                throw new ArgumentOutOfRangeException();
            }
        }



        public bool GetValueFromMember<T, U>(MessageContext ctxt, CST.TypeConstructorMemberEnvironment<T> tyconMemEnv, AttributeType attrType, IProperty<U> property, bool inheritable, ref U value) where T : MemberDef
        {
            switch (tyconMemEnv.Member.Flavor)
            {
            case MemberDefFlavor.Field:
                return false;
            case MemberDefFlavor.Method:
                return GetValueFromMethod<U>
                    (ctxt,
                     tyconMemEnv.ForMethod,
                     attrType,
                     property,
                     inheritable,
                     ref value);
            case MemberDefFlavor.Event:
                return GetValueFromEvent<U>
                    (ctxt,
                     tyconMemEnv.ForEvent,
                     attrType,
                     property,
                     inheritable,
                     ref value);
            case MemberDefFlavor.Property:
                return GetValueFromProperty<U>
                    (ctxt,
                     tyconMemEnv.ForProperty,
                     attrType,
                     property,
                     inheritable,
                     ref value);
            default:
                throw new ArgumentOutOfRangeException();
            }
        }

        public U GetValueFromMember<T, U>(MessageContext ctxt, CST.TypeConstructorMemberEnvironment<T> tyconMemEnv, AttributeType attrType, IProperty<U> property) where T : MemberDef
        {
            var res = default(U);
            if (!GetValueFromMember<T, U>(ctxt, tyconMemEnv, attrType, property, true, ref res))
                res = property.Default;
            return res;
        }


    root.BindFKToHKMethodBuilderRedirector = function BindFKToHKMethodBuilderRedirector(type, slotName) {
        type["b"+slotName] = function TypeBuilder(/* methodTypeArg_1, ..., methodTypeArg_n */) {
            var i;
            var cacheSlotName = "m"+slotName;
            for (i = 0; i < arguments.length; i++)
                cacheSlotName += "_" + arguments[i].Id;
            var method = type[cacheSlotName];
            if (method == null) {
                // Break any black-holes by delaying call
                type[cacheSlotName] = function(/* valueArg_1, ..., valueArg_m */) {
                    return type[cacheSlotName].apply(null, arguments);
                };
                // Defer to the type-constructor's method builder
                var allTypeArgs = [];
                for (i = 0; i < type.Arguments.length; i++)
                    allTypeArgs.push(type.Arguments[i]);
                for (i = 0; i < arguments.length; i++)
                    allTypeArgs.push(arguments[i]);
                method = type.Applicand["b"+slotName].apply(null, allTypeArgs);
                type[cacheSlotName] = method;
                if (arguments.length == 0) {
                    // Short circuit builder redirector
                    type["b"+slotName] = function() { return method; };
                }
            }
            return method;
        }
    }

    root.BindFKMethodBuilder = function BindFKMethodBuilder(type, slotName, f) {
        type["b"+slotName] = function TypeBuilder(/* methodTypeArg_1, ..., methodTypeArg_n */) {
            var i;
            var cacheSlotName = "m"+slotName;
            for (i = 0; i < arguments.length; i++)
                cacheSlotName += "_" + arguments[i].Id;
            var method = type[cacheSlotName];
            if (method == null) {
                // Break any black-holes by delaying call
                type[cacheSlotName] = function(/* valueArg1, ..., valueArg_m */) {
                    return type[cacheSlotName].apply(null, arguments);
                }
                // Build the method
                method = f.apply(null, arguments);
                type[cacheSlotName] = method;
                if (arguments.length == 0) {
                    // Short circuit builder itself
                    type["b"+slotName] = function() { return method; };
                }
            }
            return method;
        }
    }



        // A redirector function within an instance of a higher-kinded type has signature:
        //   (<method-bound type arg 1>, ..., <method-bound type arg n>) ->
        //       ((<method value arg 1>, ..., <method value arg m>) -> <result>)
        // It redirects to the type-constructors builder and caches within the type instance.
        private void BindFKToHKMethodBuilderRedirector
            (ISeq<JST.Statement> body, Resolver subResolver, CST.MethodDef methodDef)
        {
            var tyconMemEnv = TypeEnv.ForgetTypeBoundArguments().AddMember(methodDef);
            var slotName = new JST.StringLiteral(env.GlobalMapping.ResolveMemberDefinitionToSlot(tyconMemEnv));
            body.Add
                (JST.Statement.DotCall
                     (rootId.ToE(),
                      Constants.RootBindFKToHKMethodBuilderRedirector,
                      typeId.ToE(),
                      slotName));
        }

        // A builder function in a first-kinded type has signature:
        //   (<method-bound type arg 1>, ..., <method-bound type arg n>) ->
        //       ((<method value arg 1>, ..., <method value arg m>) -> <result>)
        // It caches within the type.
        private void BindFKMethodBuilder
            (ISeq<JST.Statement> body, Resolver subResolver, CST.MethodDef methodDef)
        {
            var compiler = new MethodCompiler(this, rootId, assemblyId, nameSupply, methodDef);
            var func = compiler.Function();
            var tyconMemEnv = TypeEnv.ForgetTypeBoundArguments().AddMember(methodDef);
            var slotName = new JST.StringLiteral(env.GlobalMapping.ResolveMemberDefinitionToSlot(tyconMemEnv));
            body.Add
                (JST.Statement.DotCall
                     (rootId.ToE(),
                      Constants.RootBindFKMethodBuider,
                      typeId.ToE(),
                      slotName,
                      func));
        }




        private void BindMethodIntoFirstKindedType(ISeq<JST.Statement> body, Resolver subResolver, CST.MethodDef methodDef)
        {
            if (TypeEnv.Type.Arity > 0)
                // Higher-kinded type: Bind a method builder which redirects to the true builder in the higher-kinded type structure
                BindFKToHKMethodBuilderRedirector(body, subResolver, methodDef);
            else
                // First-kinded type: Bind the true method builder
                BindFKMethodBuilder(body, subResolver, methodDef);
        }



        private JST.Expression TranslateCall(MethodCompilerEnvironment methCompEnv, bool isVirtCall, CST.MethodRef methodRef, IImSeq<Expression> arguments)
        {
            var methEnv = methodRef.EnterMethod(methCompEnv);
            var typeDef = methEnv.Type;
            var methodDef = methEnv.Member;
            if (typeDef is CST.InterfaceTypeDef)
                isVirtCall = true;
            var args = arguments.Select(e => TranslateExpression(methCompEnv, e)).ToSeq();

            var s = methodRef.DefiningType.Style(methCompEnv);

            if (s is ObjectTypeStyle && !methodDef.IsStatic && methodDef.MethodStyle == MethodStyle.Constructor)
            {
                // SPECIAL CASE: Object constructor is the identity
                return null;
            }
            else if (s is ArrayTypeStyle && methodDef.Name.Equals("GetEnumerator", StringComparison.Ordinal) &&
                     !methodDef.IsStatic && methodDef.ValueParameters.Count == 1 && methodDef.TypeParameters.Count == 0)
            {
                // SPECIAL CASE: Redirect to runtime GetEnumerator to simulate covariance
                var elemType = methCompEnv.ResolveType(methodRef.DefiningType.Arguments[0]);
                return JST.Expression.DotCall
                    (rootId.ToE(), Constants.RootGetEnumerator, args[0], elemType, new JST.NullExpression());
            }
            else if (s is GenericIEnumerableTypeStyle &&
                     methodDef.Name.Equals("GetEnumerator", StringComparison.Ordinal) && !methodDef.IsStatic &&
                     methodDef.ValueParameters.Count == 1 && methodDef.TypeParameters.Count == 0)
            {
                // SPECIAL CASE: Redirect to runtime GetEnumerator to simulate covariance. Should the
                //               target object not be a built-in array, redirect back to original target of call.
                var id = nameSupply.GenSym();
                var func = new JST.FunctionExpression
                    (new Seq<JST.Identifier> { id },
                     new JST.ReturnStatement
                         (methCompEnv.VirtualMethodCallExpression
                              (methodRef, new Seq<JST.Expression> { id.ToE() })));
                var elemType = methCompEnv.ResolveType(methodRef.DefiningType.Arguments[0]);
                return JST.Expression.DotCall
                    (rootId.ToE(), Constants.RootGetEnumerator, args[0], elemType, func);
            }
            else if (s is DelegateTypeStyle && methodDef.Name.Equals("Invoke", StringComparison.Ordinal))
            {
                // SPECIAL CASE: System.Delegate::Invoke is rewritten to direct function application
                return new JST.CallExpression(args[0], args.Skip(1).ToSeq());
            }
            else if (s is NullableTypeStyle && !methodDef.IsStatic && methodDef.IsConstructor &&
                     methodDef.Arity == 2)
            {
                // SPECIAL CASE: Nullable`1::.ctor(ptr, x) is just ptr.W(x)
                return JST.Expression.DotCall(args[0], Constants.PointerWrite, args[1]);
            }
            else if (s is NullableTypeStyle &&
                     methodDef.Name.Equals("get_HasValue", StringComparison.Ordinal))
            {
                // SPECIAL CASE: Nullable`1::get_HasValue(ptr) becomes ptr.R() != null
                return JST.Expression.IsNotNull
                    (JST.Expression.DotCall(args[0], Constants.PointerRead));
            }
            else if (s is NullableTypeStyle &&
                     methodDef.Name.Equals("get_Value", StringComparison.Ordinal))
            {
                // SPECIAL CASE: Nullable`1::get_Value(ptr) becomes AssertNonNullInvalidOperation(ptr.R())
                return JST.Expression.DotCall
                    (rootId.ToE(),
                     Constants.RootAssertNonNullInvalidOperation,
                     JST.Expression.DotCall(args[0], Constants.PointerRead));
            }
            else if (s is MultiDimArrayTypeStyle &&
                     methodDef.Name.Equals("Get", StringComparison.Ordinal))
            {
                // SPECIAL CASE: Multi-dimensional array get
                return JST.Expression.DotCall
                    (rootId.ToE(), Constants.RootGetMultiDimArrayValue, args);
            }
            else if (s is MultiDimArrayTypeStyle &&
                     methodDef.Name.Equals("Set", StringComparison.Ordinal))
            {
                // SPECIAL CASE: Multi-dimensional array set
                return JST.Expression.DotCall
                    (rootId.ToE(), Constants.RootSetMultiDimArrayValue, args);
            }
            else if (s is MultiDimArrayTypeStyle &&
                     methodDef.Name.Equals("Address", StringComparison.Ordinal))
            {
                // SPECIAL CASE: Multi-dimensional array element address
                var elemType = methCompEnv.ResolveType(methEnv.TypeBoundArguments[0]);
                var allArgs = new Seq<JST.Expression> { elemType };
                foreach (var a in args)
                    allArgs.Add(a);
                return JST.Expression.DotCall
                    (rootId.ToE(),
                     Constants.RootNewPointerToMultiDimArrayElem,
                     allArgs);
            }
            else if (methodRef.DefiningType.Equals(Env.Global.DebuggerRef) &&
                     methodRef.Name.Equals("Break", StringComparison.Ordinal))
            {
                // SPECIAL CASE: Break into debugger directly
                return new JST.DebuggerExpression();
            }
            else
            {
                var exp = isVirtCall
                              ? methCompEnv.VirtualMethodCallExpression
                                    (methodRef, args)
                              : methCompEnv.MethodCallExpression(methodRef, args);
                //var nm = CST.CSTWriter.WithAppend(env.Global, CST.WriterStyle.Debug, methodRef.Append);
                //if (env.DebugMode)
                //    return new JST.CommentExpression(exp, nm);
                //else
                return exp;
            }
        }



                if (arguments == null)
                {
                    if (methodRef.DefiningType.Arguments.Count > 0 || methodRef.MethodTypeArguments.Count > 0)
                    {
                        // Partially apply method to type-bound and method-bound type arguments to yield function
                        // over method value parameters
                        var parameters = new Seq<JST.Identifier>();
                        for (var i = 0; i < tyconMemEnv.Member.Arity; i++)
                        {
                            var id = nameSupply.GenSym();
                            parameters.Add(id);
                            args.Add(id.ToE());
                        }
                        return new JST.FunctionExpression
                            (parameters,
                             JST.Statement.OptReturn
                                 (tyconMemEnv.Member.Result != null, new JST.CallExpression(func, args)));
                    }
                    else
                        // NOTE: Cannot eta-expand otherwise we destroy delegate identity
                        // However, this means it is not safe to cache arbitrary methods, since they may
                        // be updated.
                        return func;
                }
                else
                {


                    if (arguments == null)
                    {
                        // Partially apply method to method-bound type arguments to yield function over method value parameters
                        // (any type-bound arguments have already been captured when virtual was bound)
                        var parameters = new Seq<JST.Identifier>();
                        for (var i = 0; i < tyconMemEnv.Member.Arity; i++)
                        {
                            var id = nameSupply.GenSym();
                            parameters.Add(id);
                            args.Add(id.ToE());
                        }
                        return new JST.FunctionExpression
                            (parameters,
                             JST.Statement.OptReturn
                                 (tyconMemEnv.Member.Result != null, new JST.CallExpression(func, args)));
                    }








            var function = default(JST.FunctionExpression);
            if (nameSupply != null)
            {
                var parameters = new Seq<JST.Identifier>();
                var body = new Seq<JST.Statement>();
                var callArgs = new Seq<JST.Expression>();

                if (!lastArgIsParamsArray)
                {
                    if (scriptExpectsRoot)
                        callArgs.Add(rootId.ToE());

                    for (var i = 0; i < arity; i++)
                    {
                        var id = gensym();
                        parameters.Add(id);
                        if (i == 0 && instanceIsThis)
                        {
                            if (script is JST.FunctionExpression)
                            {
                                callArgs.Insert(0, id.ToE());
                                var funcId = gensym();
                                body.Add(JST.Statement.Var(funcId, script));
                                script = JST.Expression.Dot(funcId.ToE(), Constants.call);
                            }
                            else
                                script = JST.Expression.Dot(id.ToE(), JST.Expression.ExplodePath(script));
                        }
                        else
                            callArgs.Add(id.ToE());
                    }
                }
                else
                {
                    var argsId = gensym();
                    body.Add(JST.Statement.Var(argsId, new JST.ArrayLiteral()));

                    if (scriptExpectsRoot)
                        body.Add(JST.Statement.DotCall(argsId.ToE(), Constants.push, rootId.ToE()));

                    if (!isInstanceMethod)
                        callArgs.Add(new JST.NullExpression());

                    for (var i = 0; i < arity; i++)
                    {
                        var id = gensym();
                        parameters.Add(id);
                        if (isInstanceMethod && i == 0)
                        {
                            if (instanceIsThis)
                                callArgs.Add(id.ToE());
                            else
                            {
                                callArgs.Add(new JST.NullExpression());
                                body.Add(JST.Statement.DotCall(argsId.ToE(), Constants.push, id.ToE()));
                            }
                        }
                        else if (i == arity - 1)
                        {
                            var iId = gensym();
                            body.Add
                                (new JST.IfStatement
                                     (JST.Expression.IsNotNull(id.ToE()),
                                      new JST.ForStatement
                                          (new JST.ForVarLoopClause
                                               (iId,
                                                new JST.NumericLiteral(0),
                                                new JST.BinaryExpression
                                                    (iId.ToE(),
                                                     JST.BinaryOp.LessThan,
                                                     JST.Expression.Dot(id.ToE(), Constants.length)),
                                                new JST.UnaryExpression(iId.ToE(), JST.UnaryOp.PostIncrement)),
                                           JST.Statement.DotCall
                                               (argsId.ToE(),
                                                Constants.push,
                                                new JST.IndexExpression(id.ToE(), iId.ToE())))));
                        }
                        else
                            body.Add(JST.Statement.DotCall(argsId.ToE(), Constants.push, id.ToE()));
                    }
                    if (script is JST.FunctionExpression)
                    {
                        var funcId = gensym();
                        body.Add(JST.Statement.Var(funcId, script));
                        script = JST.Expression.Dot(funcId.ToE(), Constants.apply);
                    }
                    else
                        script = JST.Expression.Dot(script, Constants.apply);
                    callArgs.Add(argsId.ToE());
                }

                var exp = (JST.Expression)new JST.CallExpression(script, callArgs);
                if (isNew)
                    exp = new JST.NewExpression(exp);

                body.Add(JST.Statement.OptReturn(EffectiveResult(tyconMemEnv) != null, exp));

                function = new JST.FunctionExpression(parameters, body);
            }

            return new ImportMethodInfo(tyconMemEnv, function);

            if (s is CST.ArrayTypeStyle)
            {
                var newObjId = innerNameSupply.GenSym();
                innerBody.Add
                    (JST.Statement.Var
                         (newObjId,
                          new JST.NewExpression
                              (new JST.CallExpression(Constants.Array.ToE(), new JST.NumericLiteral(0)))));
                innerBody.Add(JST.Statement.DotAssignment(newObjId.ToE(), Constants.ObjectType, type));
                innerBody.Add
                    (JST.Statement.DotAssignment
                         (newObjId.ToE(),
                          Constants.ObjectId,
                          new JST.UnaryExpression
                              (JST.Expression.Dot(rootId.ToE(), Constants.RootNextObjectId), JST.UnaryOp.PostIncrement)));
                innerBody.Add(new JST.ReturnStatement(newObjId.ToE()));
            }



        // Expression to build the name or qualified name of type, making sure we only require other
        // types to be at phase 1.
        private JST.Expression ResolveTypeToNameExpression(CST.TypeRef typeRef, bool isQualified)
        {
            if (typeId != null && typeRef.Equals(TypeEnv.Exit))
            {
                var unqual = JST.Expression.Dot(typeId.ToE(), Constants.TypeName);
                if (isQualified)
                    return JST.Expression.DotCall
                        (rootId.ToE(), Constants.RootQualifiedTypeName, assemblyId.ToE(), unqual);
                else
                    return unqual;
            }

            var otherTypeEnv = typeRef.Enter(TypeEnv);
            if (otherTypeEnv.Type is CST.ParameterTypeDef)
            {
                var parameterTypeDef = (CST.ParameterTypeDef)otherTypeEnv.Type;
                var id = default(JST.Identifier);
                switch (parameterTypeDef.ParameterFlavor)
                {
                case ParameterFlavor.Type:
                    id = typeBoundTypeParameterIds[parameterTypeDef.Index];
                    break;
                case ParameterFlavor.Method:
                    throw new InvalidOperationException("not in scope of method-bound type parameters");
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
                }
                if (isQualified)
                    return JST.Expression.DotCall
                        (rootId.ToE(),
                         Constants.RootQualifiedTypeName,
                         JST.Expression.Dot(id.ToE(), Constants.TypeAssembly),
                         JST.Expression.Dot(id.ToE(), Constants.TypeName));
                else
                    return JST.Expression.Dot(id.ToE(), Constants.TypeName);
            }
            else
            {
                var nm = CST.CSTWriter.WithAppend
                    (env.Global, CST.WriterStyle.Uniform, otherTypeEnv.Type.EffectiveName(env.Global).Append);
                var args = otherTypeEnv.TypeBoundArguments.Select(t => ResolveTypeToNameExpression(t, true)).ToSeq();

                if (isQualified)
                {
                    var assembly = ResolveAssembly(otherTypeEnv.Assembly.Name);
                    if (args.Count == 0)
                        return JST.Expression.DotCall
                            (rootId.ToE(), Constants.RootQualifiedTypeName, assembly, new JST.StringLiteral(nm));
                    else
                        return JST.Expression.DotCall
                            (rootId.ToE(),
                             Constants.RootQualifiedTypeName,
                             assembly,
                             new JST.StringLiteral(nm),
                             new JST.ArrayLiteral(args));
                }
                else if (args.Count == 0)
                    return new JST.StringLiteral(nm);
                else
                    return JST.Expression.DotCall
                        (rootId.ToE(), Constants.RootTypeName, new JST.StringLiteral(nm), new JST.ArrayLiteral(args));
            }
        }



        private void BindInlined(MethodCompilerEnvironment outer)
        {
            // Assemblies of outer are visible
            foreach (var kv in outer.boundAssemblies)
                boundAssemblies.Add(kv.Key, kv.Value);

            // Ground types of outer are visible
            // (Type-bound and method-bound parameters of outer, and any types using them, cannot be used by inner
            //  since the type- and method-bound parameters are not in scope)
            foreach (var kv in outer.boundTypes)
            {
                if (kv.Key.IsGround)
                    boundTypes.Add(kv.Key, kv.Value);
            }
            // Args and locals of outer are not visible

            // Type- and method-bound type parameters of this method are in scope
            for (var i = 0; i < Type.Arity; i++)
                boundTypes.Add(TypeBoundArguments[i], TypeBoundTypeParameterIds[i].ToE());
            for (var i = 0; i < Member.TypeArity; i++)
                boundTypes.Add(MethodBoundArguments[i], MethodBoundTypeParameterIds[i].ToE());
        }



        public MethodCompilerEnvironment EnterInlinedMethod(CST.CompilationEnvironment compEnv)
        {
            var typeBoundTypeParameterIds = new Seq<JST.Identifier>();
            for (var i = 0; i < compEnv.Type.Arity; i++)
                typeBoundTypeParameterIds.Add(nameSupply.GenSym());

            var methodBoundTypeParameterIds = new Seq<JST.Identifier>();
            for (var i = 0; i < compEnv.Member.TypeArity; i++)
                methodBoundTypeParameterIds.Add(nameSupply.GenSym());

            var argumentIds = new Seq<JST.Identifier>();
            for (var i = 0; i < compEnv.Member.ValueParameters.Count; i++)
                argumentIds.Add(nameSupply.GenSym());

            var localIds = new Seq<JST.Identifier>();
            for (var i = 0; i < compEnv.Member.Locals.Count; i++)
                localIds.Add(nameSupply.GenSym());

            var res = new MethodCompilerEnvironment
                (compEnv.Global,
                 compEnv.TypeBoundSkolemDefs,
                 compEnv.MethodBoundSkolemDefs,
                 compEnv.Assembly,
                 compEnv.Type,
                 compEnv.TypeBoundArguments,
                 compEnv.Member,
                 compEnv.MethodBoundArguments,
                 compEnv.Temporaries,
                 env,
                 nameSupply,
                 rootId,
                 currentAssembly,
                 assemblyId,
                 referencedAssemblySlots,
                 null,
                 stringStats,
                 sharedTypeStrings,
                 null,
                 typeBoundTypeParameterIds,
                 methodBoundTypeParameterIds,
                 argumentIds,
                 localIds);

            res.BindInlined(this);

            return res;
        }


                // Interface methods must have slots allocated in a global scope. These slots must be:
                //  - unique (equal slots implies the same method in the same first-kinded interface)
                //  - stable (can't change between recompilation of the same assembly, and can't change
                //    depending on the compilation order of assemblies)
                // We achieve this by hashing the fully qualified method name, then appending the run-time id's of any
                // interface type arguments. We only calculae the base name here.
                var polyRef = (CST.PolymorphicMethodRef)tyconMemEnv.Exit;
                var slot = default(string);
                if (!interfaceMethodCache.TryGetValue(polyRef, out slot))
                {
                    var sb = new StringBuilder();
                    var qualName = CST.CSTWriter.WithAppend
                        (env.Global, CST.WriterStyle.Uniform, polyRef.Append);
                    JST.Lexemes.AppendHashToIdentifier(sb, qualName);
                    if (env.DebugMode)
                    {
                        sb.Append('_');
                        sb.Append(polyRef.Name);
                    }
                    slot = sb.ToString();
                    interfaceMethodCache.Add(polyRef, slot);
                }
                return slot;


        private enum Mode
        {
            // Emit assembly definition into it's own file, with all types and methods defined within it.
            SelfContained,
            // Emit assembly definition and any types which are in this trace
            DefHere,
            // Don't emit assembly definition, but emit any types which are in this trace
            DefElsewhere
        }



            if (methodRef.DefiningType.Arguments.Count == 0 && methodRef.MethodTypeArguments.Count == 0)
            {
                var method = default(CST.CSTMethod);
                if (!cache.TryGetValue(polyMethodRef, out method))
                {
                    var tyconMemEnv = polyMethodRef.EnterConstructor(rootEnv);
                    if (MethodIsInlinable(tyconMemEnv))
                    {
                        var s = MethodBodySize(tyconMemEnv);
                        if (s >= 0 && s <= env.InlineThreshold)
                        {
                            // Since method is free of type parameters (both type- and method-bound) it
                            // is ok to enter it using our plain root environment, and to cache the
                            // result of compilation
                            var methEnv = methodRef.EnterMethod(rootEnv);
                            method = methEnv.ToCSTMethod(trace);
                        }
                    }
                    cache.Add(polyMethodRef, method);
                }
                return method != null;
            }

//        target[slotName] = function(/* this? ++ methodTypeArgs ++ methodValueArgs */) {
//            var args = fkType.L.slice();
//            for (var i = 0; i < arguments.length; i++)
//                args.push(arguments[i]);
//            // Method definitions on higher-kinded type definitions are always bound into the type itself
//            return fkType.K[slotName].apply(this, args); // valid for static and instance methods
//        };


        target[slotName] = function(/* this? ++ methodTypeArgs ++ methodValueArgs */) {
            var args = fkType.L.slice();
            var i;
            var j = 0;
            for (i = 0; i < methTypeArity; i++)
                args.push(arguments[j++]);
            if (!isStatic)
                args.push(this);
            for (i = 0; i < argArity; i++)
                args.push(arguments[j++]);
            // Method definitions on higher-kinded type definitions are always bound into the type itself
            return fkType.K[slotName].apply(null, args);
        };



function(/* this ++ methodTypeArg ++ methodValueArgs */) {
            var method = this[implSlotName];
            return method.apply(this, arguments);
            // NOTE: Since this interface function redirector may be shared by multiple derived types,
            //       it is not safe to update the slot.
        };


    // Called by type loader fragment to bind virtual method into binding type.
    // Method redirects at most once to non-virtual method of implementing type.
    root.BindVirtualMethod = function BindVirtualMethod(bindingType, implType, origSlotName, implSlotName) {
        var virtSlotName = "V" + origSlotName;
        var target = bindingType.I.prototype;
        var source = implType.I.prototype;
        target[virtSlotName] = function(/* this ++ methodTypeArgs ++ methodValueArgs */) {
            var method = source[implSlotName];
            var res = method.apply(this, arguments);
            // Now that we've called method at least once its slot will have been updated, so safe to copy it.
            target[virtSlotName] = source[implSlotName];
            return res;
        };
    };


    root.VToMCache = {};
    root.MakeVToM = function MakeIToV(virtSlotName, implSlotName, methTypeAndArgArity) {
        var k = virtSlotName + "," +
                implSlotName + "," +
                methTypeAndArgArity.toString();
        $il2jsit = root.VToMCache[k];
        if ($il2jsit == null) {
            var i;
            var sb = [];
            sb.push("$il2jsit = function(t) { return function(");
            for (i = 0; i < methTypeAndArgArity; i++) {
                if (i > 0)
                    sb.push(",");
                sb.push("a");
                sb.push(i.toString());
            }
            sb.push(") { var res = this.");
            sb.push(implSlotName);
            sb.push("(");
            for (i = 0; i < methTypeAndArgArity; i++) {
                if (i > 0) sb.push(",");
                sb.push("a");
                sb.push(i.toString());
            }
            sb.push("); ");
            sb.push("t.");
            sb.push(virtSlotName);
            sb.push(" = this.");
            sb.push(implSlotName);
            sb.push("; ");
            sb.push("return res; }; }");
            var s = sb.join("");
            eval(s);
            root.VToMCache[k] = $il2jsit;
        }
        return $il2jsit;
    };


    // Called by type loader fragment to bind virtual method into binding type.
    // Method redirects at most once to non-virtual method of implementing type.
    root.BindVirtualMethod = function BindVirtualMethod(bindingType, implType, origSlotName, implSlotName, methTypeAndArgArity) {
        var virtSlotName = "V" + origSlotName;
        var target = bindingType.I.prototype;
        var f = root.MakeVToM(virtSlotName, implSlotName, methTypeAndArgArity)
        target[virtSlotName] = f.call(null, target);
    };

    root.W = function BindVirtualMethods(bindingType, implType /* origSlotName1, implSlotName1, methTypeAndArgArity1, ... */) {
        for (var i = 2; i < arguments.length; i+=3)
            root.BindVirtualMethod(bindingType, implType, arguments[i], arguments[i+1], arguments[i+2]);
    }



        var del = function(/* methodValueArgs */) {
            var args, i;
            if (codePtr == null)
                // "Empty" delegate
                return;
            else {
                var args;
                // Collect args
                if (codePtr.A == null)
                    args = arguments;
                else {
                    args = codePtr.A.slice(0);
                    for (var i = 0; i < arguments.length; i++)
                        args.push(arguments[i]);
                }
                if (target == null) {
                    // Static method
                    return codePtr.T[codePtr.S].apply(null, args);
                }
                else {
                    // Instance method, possibly virtual or interface
                    return target[codePtr.S].apply(target, args);
                }
            }
        };

        target[virtSlotName] = function(/* this ++ methodTypeArgs ++ methodValueArgs */) {
            var method = source[implSlotName];
            var res = method.apply(this, arguments);
            // Now that we've called method at least once its slot will have been updated, so safe to copy it.
            target[virtSlotName] = source[implSlotName];
            return res;
        };


        target[virtSlotName] = function(/* this ++ methodTypeArgs ++ methdValueArgs */) {
            var method = source[implSlotName];
            var res = method.apply(this, arguments);
            // Now that we've called method at least once its slot will have been updated, so safe to copy it.
            target[virtSlotName] = source[implSlotName];
            return res;
        };


        // Cache the well-known types
        // String will hook itself into the String constructor prototype
        // Array will hook itself into the Array constructor prototype
        // MulticastDelegate will hook itself into the Function constructor prototype
        root.O = root.TryResolveType(root.L, "System.Object", 2);
        root.ArrayTypeConstructor = root.TryResolveType(root.L, "$Array", 2);
        root.PointerTypeConstructor = root.TryResolveType(root.L, "$Pointer", 2);
        root.ValueType = root.TryResolveType(root.L, "System.ValueType", 2);
        root.I = root.TryResolveType(root.L, "System.Int32", 2);
        root.B = root.TryResolveType(root.L, "System.Boolean", 2);
        root.CharType = root.TryResolveType(root.L, "System.Char", 2);
        root.NullableTypeConstructor = root.TryResolveType(root.L, "System.Nullable`1", 2);
        root.EnumType = root.TryResolveType(root.L, "System.Enum", 2);
        root.ArrayType = root.TryResolveType(root.L, "System.Array", 2);
        root.S = root.TryResolveType(root.L, "System.String", 2);
        root.IEnumerableTypeConstructor = root.TryResolveType(root.L, "System.Collections.Generic.IEnumerable`1", 2);
        root.X = root.TryResolveType(root.L, "System.Exception", 2);
        root.JSExceptionType = root.TryResolveType(root.L, "Microsoft.LiveLabs.JavaScript.Interop.JSException", 2);
        root.JSPropertyType = root.TryResolveType(root.L, "Microsoft.LiveLabs.JavaScript.JSProperty", 2);
        root.JSObjectType = root.TryResolveType(root.L, "Microsoft.LiveLabs.JavaScript.JSObject", 2);
        root.MulticastDelegateType = root.TryResolveType(root.L, "System.MulticastDelegate", 2);
        root.TypeType = root.TryResolveType(root.L, "System.Type", 2);

        // Bring the well-known types online
        root.EnsureTypePhase(root.O);
        root.EnsureTypePhase(root.ArrayTypeConstructor);
        root.EnsureTypePhase(root.PointerTypeConstructor);
        root.EnsureTypePhase(root.ValueType);
        root.EnsureTypePhase(root.I);
        root.EnsureTypePhase(root.B);
        root.EnsureTypePhase(root.CharType);
        root.EnsureTypePhase(root.NullableTypeConstructor);
        root.EnsureTypePhase(root.EnumType);
        root.EnsureTypePhase(root.ArrayType);
        root.EnsureTypePhase(root.S);
        root.EnsureTypePhase(root.IEnumerableTypeConstructor);
        root.EnsureTypePhase(root.X);
        root.EnsureTypePhase(root.JSExceptionType);
        root.EnsureTypePhase(root.JSPropertyType);
        root.EnsureTypePhase(root.JSObjectType);
        root.EnsureTypePhase(root.MulticastDelegateType);
        root.EnsureTypePhase(root.TypeType);



            // Well-known types can be fetched from the root structure
            // NOTE: Even though System.Type and System.Reflection.Assembly are bound to
            //       fields in the root structure, it is not safe to access them directly
            //       since they are loaded only on demand.
            var wellKnownTypes = new Map<CST.TypeRef, JST.Identifier>();
            wellKnownTypes.Add(env.Global.ObjectRef, Constants.RootObjectType);
            wellKnownTypes.Add(env.Global.ArrayTypeConstructorRef, Constants.RootArrayTypeConstructor);
            wellKnownTypes.Add(env.Global.ManagedPointerTypeConstructorRef, Constants.RootPointerTypeConstructor);
            wellKnownTypes.Add(env.Global.IEnumerableTypeConstructorRef, Constants.RootIEnumerableTypeConstructor);
            wellKnownTypes.Add(env.Global.NullableTypeConstructorRef, Constants.RootNullableTypeConstructor);
            wellKnownTypes.Add(env.JSExceptionRef, Constants.RootJSExceptionType);
            wellKnownTypes.Add(env.JSObjectRef, Constants.RootJSObjectType);
            wellKnownTypes.Add(env.Global.Int32Ref, Constants.RootInt32Type);
            wellKnownTypes.Add(env.Global.BooleanRef, Constants.RootBooleanType);
            wellKnownTypes.Add(env.Global.StringRef, Constants.RootStringType);
            wellKnownTypes.Add(env.Global.ValueTypeRef, Constants.RootValueType);
            wellKnownTypes.Add(env.Global.CharRef, Constants.RootCharType);
            wellKnownTypes.Add(env.Global.ArrayRef, Constants.RootArrayType);
            wellKnownTypes.Add(env.JSPropertyRef, Constants.RootJSPropertyType);
            wellKnownTypes.Add(env.Global.EnumRef, Constants.RootEnumType);
            wellKnownTypes.Add(env.Global.MulticastDelegateRef, Constants.RootMulticastDelegateType);
            wellKnownTypes.Add(env.Global.TypeRef, Constants.RootTypeType);
            WellKnownTypes = wellKnownTypes;


            var id = default(JST.Identifier);
            if (phase == TypePhase.Constructed && WellKnownTypes.TryGetValue(typeRef, out id))
                // Well-known types are bound in the root
                // NOTE: However don't use them if asking for type during another type's setup phases
                return JST.Expression.Dot(resolver.RootId.ToE(), id);




            // Well-known types are bound in the root
            foreach (var kv in env.JSTHelpers.WellKnownTypes)
            {
                if (!boundTypes.ContainsKey(kv.Key))
                    boundTypes.Add(kv.Key, JST.Expression.Dot(rootId.ToE(), kv.Value));
            }


        private void BindWellKnownTypes()
        {
            // Well-known types are bound in the root
            foreach (var kv in env.JSTHelpers.WellKnownTypes)
            {
                var updated = new ExpressionAndPhase
                    (JST.Expression.Dot(rootId.ToE(), kv.Value), TypePhase.Constructed);
                if (boundTypes.ContainsKey(kv.Key))
                    boundTypes[kv.Key] = updated;
                else
                    boundTypes.Add(kv.Key, updated);
            }
        }




                        // Check all the entry points make sense
                        // While we're at it, check that interop annotations make sense at the type level.
                        var anyEntryPoints = false;
                        foreach (var assemblyDef in compilingAssemblies)
                        {
                            var entryPoint = default(CST.MethodRef);
                            var assmEnv = rootEnv.AddAssembly(assemblyDef);

                            foreach (var typeDef in assemblyDef.Types)
                            {
                                if (typeDef.Invalid == null)
                                {
                                    var tyconEnv = assmEnv.AddType(typeDef);
                                    // call for side effects
                                    env.InteropManager.DefInstanceState(tyconEnv);

                                    foreach (var methodDef in typeDef.Members.OfType<CST.MethodDef>())
                                    {
                                        var tyconMemEnv = tyconEnv.AddMember(methodDef);
                                        if (env.AttributeHelper.MethodHasAttribute
                                            (tyconMemEnv, env.AttributeHelper.EntryPointAttributeRef, false))
                                        {
                                            var methodRef =
                                                tyconEnv.AddSelfTypeBoundArguments().AddMember(methodDef).
                                                    AddSelfMethodBoundArguments().Exit;
                                            if (entryPoint == null)
                                                entryPoint = methodRef;
                                            else
                                                env.Log(new DuplicateEntryPointsMessage(entryPoint, methodRef));
                                        }
                                    }
                                }
                            }

                            if (entryPoint == null)
                                entryPoint = assemblyDef.EntryPoint;

                            if (entryPoint != null)
                            {
                                var ctxt = CST.MessageContextBuilders.Assembly(assemblyDef);
                                var methEnv = entryPoint.EnterMethod(rootEnv);
                                if (methEnv.Member.Invalid != null)
                                {
                                    env.Log(new CST.UnimplementableRootMethodMessage(ctxt, methEnv.Member.Invalid));
                                    throw new ExitException();
                                }
                                anyEntryPoints = true;
                            }

                            // Update entry point to be the correct one
                            assemblyDef.EntryPoint = entryPoint;
                        }


						        var subCtxt = CST.MessageContextBuilders.Type(typeRef);
            var s = typeRef.Style(rootEnv);

            //            if (s is CST.ParameterTypeStyle)
            //                return JavaScript.Interop.InstanceState.ManagedOnly;

            for (var i = 0; i < typeRef.Arguments.Count; i++)
            {
                // call for side effects
                GetInstanceState
                    (CST.MessageContextBuilders.TypeArg(subCtxt, ParameterFlavor.Type, i), rootEnv, typeRef.Arguments[i]);
            }

            var typeEnv = typeRef.Enter(rootEnv);

            if (s is CST.DelegateTypeStyle)
            {
                var delTypeDef = (CST.DelegateTypeDef)typeEnv.Type;
                for (var i = 0; i < delTypeDef.ValueParameters.Count; i++)
                    // call for side effects
                    GetInstanceState
                        (CST.MessageContextBuilders.ArgOrLocal(subCtxt, CST.ArgLocal.Arg, i),
                         typeEnv,
                         delTypeDef.ValueParameters[i].Type);
                if (delTypeDef.Result != null)
                    // call for side effects
                    GetInstanceState(CST.MessageContextBuilders.Result(subCtxt), typeEnv, delTypeDef.Result.Type);
            }

            return DefInstanceState(typeEnv.Assembly, typeEnv.Type);
        }

        public InstanceState DefInstanceState(CST.AssemblyDef assemblyDef, CST.TypeDef typeDef)
        {
            var name = typeDef.QualifiedTypeName(env.Global, assemblyDef);
            var optStyle = default(Nullable<InstanceState>);
            if (typeConstructorToInstanceStateCache.TryGetValue(name, out optStyle))
            {
                if (!optStyle.HasValue)
                    // Already reported error, just skip
                    throw new DefinitionException();
            }
            else
            {
                try
                {
                    optStyle = PrimDefnInstanceState(assemblyDef, typeDef);
                    typeConstructorToInstanceStateCache.Add(name, optStyle);
                }
                catch (DefinitionException)
                {
                    // Suppress further messages
                    typeConstructorToInstanceStateCache.Add(name, null);
                    throw;
                }
            }
            return optStyle.Value;
        }

        private InstanceState PrimDefnInstanceState(AssemblyDef assemblyDef, TypeDef typeDef)
        {
            var ctxt = CST.MessageContextBuilders.Type(env.Global, assemblyDef, typeDef);

            var s = typeDef.Style;

            if (s is CST.ParameterTypeStyle)
                throw new InvalidOperationException("unexpected type parameter");

            if (s is CST.PointerTypeStyle || s is CST.CodePointerTypeStyle || s is CST.NullableTypeStyle ||
                s is CST.ArrayTypeStyle || s is CST.ValueTypeStyle || s is CST.DelegateTypeStyle ||
                s is CST.InterfaceTypeStyle)
                return InstanceState.ManagedOnly;

            var isRuntime = attributeHelper.GetValueFromType
                (assemblyDef, typeDef, attributeHelper.RuntimeAttributeRef, attributeHelper.TheIsRuntimeProperty);
            var baseState = InstanceState.ManagedOnly;
            if (typeDef.Extends != null)
            {
                var extAssemblyDef = default(AssemblyDef);
                var extTypeDef = default(TypeDef);
                if (typeDef.Extends.PrimTryResolve(env.Global, out extAssemblyDef, out extTypeDef))
                    baseState = PrimDefnInstanceState(extAssemblyDef, extTypeDef);
            }
            var state = default(InstanceState);

            var stateIsFixed = false;

            // Look for [Interop(State = ...)] on type itself
            if (attributeHelper.GetValueFromType
                (assemblyDef,
                 typeDef,
                 attributeHelper.InteropAttributeRef,
                 attributeHelper.TheStateProperty,
                 false,
                 ref state))
                stateIsFixed = true;

            if (!stateIsFixed && typeDef.Extends != null)
            {
                // Try to inherit base type's state
                state = baseState;
                if (state != InstanceState.ManagedOnly)
                    stateIsFixed = true;
            }

            if (!stateIsFixed && baseState != InstanceState.ManagedOnly)
            {
                state = baseState;
                stateIsFixed = true;
            }

            if (isRuntime || (typeDef.IsSealed && typeDef.IsAbstract))
                // Don't look at member imports/exports to infer state of runtime and static types
                stateIsFixed = true;

            // Collect member statistics
            var numInstanceImports = 0;
            var numInstanceExports = 0;
            var numStaticExports = 0;
            var numInstanceFieldsAllSupertypes = 0;

            var bail = false;

            foreach (var memberDef in typeDef.Members)
            {
                switch (memberDef.Flavor)
                {
                    case MemberDefFlavor.Field:
                        {
                            var field = (CST.FieldDef)memberDef;
                            if (!field.IsStatic)
                                numInstanceFieldsAllSupertypes++;
                            break;
                        }
                    case MemberDefFlavor.Method:
                        {
                            var methodDef = (CST.MethodDef)memberDef;
                            var isNonInlinable = false;
                            if (IsImported(assemblyDef, typeDef, methodDef))
                            {
                                if (!methodDef.IsStatic)
                                {
                                    numInstanceImports++;
                                    if (state == InstanceState.Merged &&
                                        !IsInlinable(assemblyDef, typeDef, methodDef, state))
                                        isNonInlinable = true;
                                }
                            }
                            else
                            {
                                if (!methodDef.IsStatic && state == InstanceState.Merged)
                                {
                                    if (methodDef.IsConstructor)
                                    {
                                        if (
                                            !(methodDef.Arity > 1 &&
                                              methodDef.ValueParameters[1].Type.Equals(env.JSContextRef)))
                                        {
                                            bail = true;
                                            env.Log
                                                (new InvalidInteropMessage
                                                     (CST.MessageContextBuilders.Member
                                                          (env.Global, assemblyDef, typeDef, methodDef),
                                                      "all constructors for a 'Merged' type must be imported"));
                                        }
                                    }
                                    else if (!env.InlinedMethods.IsInlinable(assemblyDef, typeDef, methodDef))
                                        isNonInlinable = true;
                                }
                            }
                            if (isNonInlinable)
                            {
                                bail = true;
                                env.Log
                                    (new InvalidInteropMessage
                                         (CST.MessageContextBuilders.Member(env.Global, assemblyDef, typeDef, methodDef),
                                          "'Merged' cannot contain non-inlinable instance methods"));
                            }
                            if (IsExported(assemblyDef, typeDef, methodDef))
                            {
                                if (IsBindToInstance(assemblyDef, typeDef, methodDef))
                                    numInstanceExports++;
                                else
                                    numStaticExports++;
                            }
                            break;
                        }
                    case MemberDefFlavor.Event:
                    case MemberDefFlavor.Property:
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
            }

            var extRef = typeDef.Extends;
            while (extRef != null)
            {
                var extAssemblyDef = default(AssemblyDef);
                var extTypeDef = default(TypeDef);
                if (extRef.PrimTryResolve(env.Global, out extAssemblyDef, out extTypeDef))
                {
                    numInstanceFieldsAllSupertypes +=
                        extTypeDef.Members.OfType<CST.FieldDef>().Where(f => !f.IsStatic).Count();
                    extRef = extTypeDef.Extends;
                }
                else
                    extRef = null;
            }

            if (!stateIsFixed && numInstanceImports + numInstanceExports > 0)
                // Look for instance imports or exports to decide state
                state = numInstanceFieldsAllSupertypes == 0
                            ? InstanceState.JavaScriptOnly
                            : InstanceState.ManagedAndJavaScript;

            if (numStaticExports > 0 && typeDef.Arity > 0)
            {
                bail = true;
                env.Log
                    (new InvalidInteropMessage(ctxt, "a higher-kinded type cannot contain exports of static methods"));
            }

            if (state != InstanceState.ManagedOnly && typeDef.IsSealed && typeDef.IsAbstract)
            {
                bail = true;
                env.Log(new InvalidInteropMessage(ctxt, "static types must be 'ManagedOnly'"));
            }

            if (baseState != InstanceState.ManagedOnly && baseState != state)
            {
                bail = true;
                env.Log
                    (new InvalidInteropMessage
                         (ctxt, "type is not the same state as base type, and base type is not 'ManagedOnly'"));
            }

            switch (state)
            {
                case InstanceState.ManagedOnly:
                    if (!isRuntime && numInstanceImports + numInstanceExports > 0)
                    {
                        bail = true;
                        env.Log
                            (new InvalidInteropMessage
                                 (ctxt, "'ManagedOnly' types cannot have imported or exported instance methods"));
                    }
                    break;
                case InstanceState.Merged:
                    if (numInstanceFieldsAllSupertypes > 0)
                    {
                        bail = true;
                        env.Log
                            (new InvalidInteropMessage
                                 (ctxt,
                                  "'Merged' cannot contain managed instance fields, either directly or inherited from supertypes"));
                    }
                    break;
                case InstanceState.ManagedAndJavaScript:
                    // Anything goes!
                    break;
                case InstanceState.JavaScriptOnly:
                    if (numInstanceFieldsAllSupertypes > 0)
                    {
                        bail = true;
                        env.Log
                            (new InvalidInteropMessage
                                 (ctxt,
                                  "a type with state 'JavaScriptOnly' type cannot contain managed instance fields, either directly or inherited from supertypes"));
                    }
                    if (numInstanceExports > 0)
                    {
                        bail = true;
                        env.Log
                            (new InvalidInteropMessage
                                 (ctxt, "a type with state 'JavaScriptOnly' cannot contain exported instance methods"));
                    }
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }

            if (bail)
                throw new DefinitionException();
            else
                return state;
        }

        public int NumInstanceExports(CST.AssemblyDef assemblyDef, CST.TypeDef typeDef)
        {
            var name = typeDef.QualifiedTypeName(env.Global, assemblyDef);
            var n = 0;
            if (!numInstanceExportsCache.TryGetValue(name, out n))
            {
                if (typeDef.Extends != null)
                {
                    var extAssemblyDef = default(AssemblyDef);
                    var extTypeDef = default(TypeDef);
                    if (typeDef.Extends.PrimTryResolve(env.Global, out extAssemblyDef, out extTypeDef))
                        n = NumInstanceExports(extAssemblyDef, extTypeDef);
                }
                n +=
                    typeDef.Members.OfType<CST.MethodDef>().Select(m => IsExported(assemblyDef, typeDef, m) && IsBindToInstance(assemblyDef, typeDef, m)).Count();
                numInstanceExportsCache.Add(name, n);
            }
            return n;
        }

        public int RootTypeSteps(CST.AssemblyDef assemblyDef, CST.TypeDef typeDef)
        {
            var state = DefInstanceState(assemblyDef, typeDef);
            var steps = 0;
            var extRef = typeDef.Extends;
            while (extRef != null)
            {
                if (extRef.PrimTryResolve(env.Global, out assemblyDef, out typeDef))
                {
                    if (DefInstanceState(assemblyDef, typeDef) != state)
                        break;
                    steps++;
                    extRef = typeDef.Extends;
                }
                else
                    break;
            }
            return steps;
        }

        public JST.Expression KeyField(CST.AssemblyDef assemblyDef, CST.TypeDef typeDef)
        {
            var ctxt = CST.MessageContextBuilders.Type(env.Global, assemblyDef, typeDef);
            var keyPropDef = default(CST.PropertyDef);
            foreach (var member in typeDef.Members)
            {
                if (member.Flavor == MemberDefFlavor.Property)
                {
                    var propDef = (CST.PropertyDef)member;
                    if (attributeHelper.PropertyHasAttribute
                        (assemblyDef, typeDef, propDef, attributeHelper.ImportKeyAttributeRef, false))
                    {
                        if (keyPropDef == null)
                            keyPropDef = propDef;
                        else
                        {
                            env.Log
                                (new InvalidInteropMessage
                                     (ctxt, "duplicate keys specified for type with state 'ManagedAndJavaScript'"));
                            throw new DefinitionException();
                        }
                    }
                }
            }

            if (keyPropDef == null)
            {
                var script = attributeHelper.GetValueFromType
                    (assemblyDef, typeDef, attributeHelper.InteropAttributeRef, attributeHelper.TheDefaultKeyProperty);
                if (script == null)
                {
                    env.Log
                        (new InvalidInteropMessage
                             (ctxt,
                              "default key must be specified for type with state 'ManagedAndJavaScript' without an 'ImportKey' attribute"));
                    throw new DefinitionException();
                }
                if (script is JST.FunctionExpression)
                {
                    env.Log(new InvalidInteropMessage(ctxt, "default key must be an identifier, not a function"));
                    throw new DefinitionException();
                }
                return script;
            }
            else
            {
                var script = attributeHelper.GetValueFromProperty
                    (assemblyDef,
                     typeDef,
                     keyPropDef,
                     attributeHelper.ImportAttributeRef,
                     attributeHelper.TheScriptProperty);
                if (script != null && script is JST.FunctionExpression)
                {
                    env.Log
                        (new InvalidInteropMessage
                             (ctxt,
                              "key for type with state 'ManagedAndJavaScript' must be imported as an identifier, not a function"));
                    throw new DefinitionException();
                }
                return RecaseProperty(assemblyDef, typeDef, keyPropDef, script);
            }
        }

        public JST.Expression TypeClassifier(CST.AssemblyDef assemblyDef, CST.TypeDef typeDef)
        {
            switch (DefInstanceState(assemblyDef, typeDef))
            {
                case InstanceState.ManagedOnly:
                    return null;
                case InstanceState.Merged:
                case InstanceState.ManagedAndJavaScript:
                case InstanceState.JavaScriptOnly:
                    return attributeHelper.GetValueFromType
                        (assemblyDef, typeDef, attributeHelper.InteropAttributeRef, attributeHelper.TheScriptProperty);
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public bool UndefinedIsNotNull(CST.AssemblyDef assemblyDef, CST.TypeDef typeDef)
        {
            switch (DefInstanceState(assemblyDef, typeDef))
            {
                case InstanceState.JavaScriptOnly:
                    return attributeHelper.GetValueFromType
                        (assemblyDef, typeDef, attributeHelper.InteropAttributeRef, attributeHelper.TheUndefinedIsNotNullProperty);
                case InstanceState.ManagedOnly:
                case InstanceState.Merged:
                case InstanceState.ManagedAndJavaScript:
                    return false;
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }



    // <slotInfo> ::=
    // {
    //     IsVirtual : bool
    //     ArgType : [<type>]
    //     ResultType : <type>
    //     CustomAttributes : [object]
    // }

    root.ResolveMethod = function ResolveMethod(declType, includeStatic, includeInstance, simpleMethodName, paramTypes,
                                                returnTypeIsKnown, returnTypeOrNull) {
        root.PrepareTypeForReflection(declType);
        var methodName;
        var isStatic;
        if (paramTypes == null) {
            methodName = declType.SimpleToFullName[simpleMethodName];
            if (methodName == null)
                throw root.InvalidOperationExceptionWithMessage("cannot find (unique) member with given name");
            if (methodName.indexOf("method instance ") == 0) {
                if (!includeInstance)
                    throw root.InvalidOperationExceptionWithMessage("cannot find static method with given name");
                isStatic = false;
            }
            if (methodName.indexOf("method static ") == 0) {
                if (!includeStatic)
                    throw root.InvalidOperationExceptionWithMessage("cannot find instance method with given name");
                isStatic = true;
            }
        }
        else {
            // Include implicit 'this' parameter in parameter types
            if (declType.W)
                paramTypes.unshift(root.L["B" + root.PointerTypeConstructor.Slot](declType));
            else
                paramTypes.unshift(declType);
            if (includeStatic) {
                if (returnTypeIsKnown)
                    methodName = root.MethodName(true, simpleMethodName, paramTypes, returnTypeOrNull);
                else
                    methodName = declType.PartialToFullName[root.MethodName(true, simpleMethodName, paramTypes, null)];
                if (methodName != null && declType.NameToSlot[methodName] == null)
                    methodName = undefined;
                if (methodName != null)
                    isStatic = true;
            }
            else
                methodName = null;
            if (includeInstance) {
                var otherMethodName;
                if (returnTypeIsKnown)
                    otherMethodName = root.MethodName(false, simpleMethodName, paramTypes, returnTypeOrNull);
                else
                    otherMethodName = declType.PartialToFullName[root.MethodName(false, simpleMethodName, paramTypes, null)];
                if (otherMethodName != null && declType.NameToSlot[otherMethodName] == null)
                    otherMethodName = undefined;
                if (otherMethodName != null) {
                    if (methodName != null)
                        throw root.InvalidOperationExceptionWithMessage("cannot find unique method with given name and signature (both static and instance versions were found)");
                    methodName = otherMethodName;
                    isStatic = false;
                }
            }
            if (methodName == null)
                throw root.InvalidOperationExceptionWithMessage("cannot find method with given name and signature");
        }
        var slot = declType.NameToSlot[methodName];
        if (slot == null)
            root.Panic("cannot determine slot for method");
        var info = declType.SlotToInfo[slot];
        if (info == null)
            root.Panic("cannot find reflection info for slot");
        return  { slot: slot, info: info, isStatic: isStatic };
    };

    root.ResolveField = function ResolveField(declType, includeStatic, includeInstance, simpleFieldName, fieldTypeOrNull) {
        root.PrepareTypeForReflection(declType);
        var fieldName = null;
        var isStatic;
        if (includeStatic) {
            if (fieldTypeOrNull == null)
                fieldName = declType.PartialToFullName[root.FieldName(true, simpleFieldName, null)];
            else
                fieldName = root.FieldName(true, simpleFieldName, fieldTypeOrNull);
            if (fieldName != null && declType.NameToSlot[fieldName] == null)
                fieldName = undefined;
            if (fieldName != null)
                isStatic = true;
        }
        else
            fieldName = null;
        if (includeInstance) {
            var otherFieldName;
            if (fieldTypeOrNull == null)
                otherFieldName = declType.PartialToFullName[root.FieldName(false, simpleFieldName, null)];
            else
                otherFieldName = root.FieldName(false, simpleFieldName, fieldTypeOrNull);
            if (otherFieldName != null && declType.NameToSlot[otherFieldName] == null)
                otherFieldName = undefined;
            if (otherFieldName != null) {
                if (fieldName != null)
                    throw root.InvalidOperationExceptionWithMessage("cannot find unique field with given name (both static and instance versions were found)");
                fieldName = otherFieldName;
                isStatic = false;
            }
        }
        if (fieldName == null)
            throw root.InvalidOperationExceptionWithMessage("cannot determine field name corresponding to field");
        var slot = declType.NameToSlot[fieldName];
        if (slot == null)
            root.Panic("cannot determine slot for field");
        var info = declType.SlotToInfo[slot];
        if (info == null)
            root.Panic("cannot find info for slot");
        return { slot: slot, info: info, isStatic: isStatic };
    };

    root.DynamicInvokeConstructor = function DynamicInvokeConstructor(declType, simpleMethodName, paramTypes, paramValues) {
        var obj = new declType.I();
        if (declType.W)
            obj = root.P(obj, declType);
        root.DynamicInvokeMethod(declType, false, true, simpleMethodName, paramTypes, true, null, obj, paramValues);
        return obj
    };

    root.GetConstructorAttributes = function GetConstructorAttributes(declType, simpleMethodName, paramTypes) {
        root.ResolveMethod(declType, false, true, simpleMethodName, paramTypes, true, null).info.CustomAttributes;
    }

    root.DynamicInvokeMethod = function DynamicInvokeMethod(declType, includeStatic, includeInstance, simpleMethodName,
                                                            paramTypes, returnTypeIsKnown, returnTypeOrNull, obj,
                                                            paramValues) {
        var a = root.ResolveMethod(declType, includeStatic, includeInstance, simpleMethodName, paramTypes,
                                   returnTypeIsKnown, returnTypeOrNull);
        var paramArity = paramValues == null ? 0 : paramValues.length;
        if (!a.isStatic) {
            if (obj == null)
                throw root.NullReferenceException();
            if (!root.IsInst(obj, declType))
                throw root.TargetException();
        }
        if (paramArity != (a.isStatic ? a.info.ArgTypes.length : a.info.ArgTypes.length - 1))
            throw root.InvalidOperationExceptionWithMessage("number of arguments does not match method arity");
        var args = [];
        for (var i = 0; i < paramArity; i++)
            args.push(a.info.ArgTypes[a.isStatic ? i : i + 1].A(paramValues[i]));
        var method;
        if (a.info.IsVirtual)
            method = obj["V" + a.slot];
        else if (a.isStatic)
            method = declType[a.slot];
        else
            method = obj[a.slot];
        var res = method.apply(obj, args); // valid for static and instance methods
        if (a.info.ResultType != null)
            return a.info.ResultType.B(res);
        else
            return res;
    };

    root.GetMethodAttributes = function GetMethodAttributes(declType, includeStatic, includeInstance, simpleMethodName, paramTypes, returnTypeIsKnown, returnTypeOrNull) {
        root.ResolveMethod(declType, includeStatic, includeInstance, simpleMethodName, paramTypes, returnTypeIsKnown, returnTypeOrNull).info.CustomAttributes;
    }



            // NameToSlot
            body.Add(JST.Statement.DotAssignment(lhs, Constants.TypeNameToSlot, NameToSlotExpression(body)));
            // PartialToFullname
            body.Add
                (JST.Statement.DotAssignment(lhs, Constants.TypePartialToFullName, PartialToFullNameExpression(body)));
            // SimpleToFullName
            body.Add
                (JST.Statement.DotAssignment(lhs, Constants.TypeSimpleToFullName, SimpleToFullNameExpression(body)));
            // SlotToInfo
            body.Add(JST.Statement.DotAssignment(lhs, Constants.TypeSlotToInfo, SlotToInfoExpression(body)));


        private JST.Expression NameToSlotExpression(Seq<JST.Statement> body)
        {
            var objId = nameSupply.GenSym();
            body.Add(JST.Statement.Var(objId, new JST.ObjectLiteral()));

            // TODO: Add implemented interface methods which differ in name from implementing method
            foreach (var methodDef in parent.Methods)
            {
                var name = MethodName(methodDef, false);
                if (name != null)
                {
                    var actMethodRef = default(CST.PolymorphicMethodRef);
                    if (methodDef.IsOverriding)
                        // Use the overridden slot name instead of definition slot name
                        actMethodRef = typeCompEnv.Type.OverriddenMethod(methodDef.MethodSignature);
                    else
                        actMethodRef = new CST.PolymorphicMethodRef(typeCompEnv.TypeRef, methodDef.MethodSignature);
                    body.Add
                        (JST.Statement.DotCall
                             (rootId.ToE(),
                              Constants.RootSetUnique,
                              objId.ToE(),
                              name,
                              env.JSTHelpers.MethodSlotName(typeCompEnv, actMethodRef, false)));
                }
            }

            foreach (var fieldDef in parent.Fields)
            {
                var slot = env.GlobalMapping.ResolveFieldDefToSlot(typeCompEnv.Assembly, typeCompEnv.Type, fieldDef);
                var name = FieldName(fieldDef);
                if (name != null)
                {
                    body.Add
                        (JST.Statement.DotCall
                             (rootId.ToE(),
                              Constants.RootSetUnique,
                              objId.ToE(),
                              name,
                              new JST.StringLiteral
                                  (fieldDef.IsStatic
                                       ? Constants.TypeStaticFieldSlot(slot)
                                       : Constants.ObjectInstanceFieldSlot(slot))));
                }
            }

            return objId.ToE();
        }

        private JST.Expression PartialToFullNameExpression(Seq<JST.Statement> body)
        {
            var objId = nameSupply.GenSym();
            body.Add(JST.Statement.Var(objId, new JST.ObjectLiteral()));

            // TODO: Add implemented interface methods which differ in name from implementing method
            foreach (var methodDef in parent.Methods)
            {
                var name = MethodName(methodDef, true);
                if (name != null)
                    body.Add
                        (JST.Statement.DotCall
                             (rootId.ToE(), Constants.RootSetUnique, objId.ToE(), name, MethodName(methodDef, false)));
            }

            return objId.ToE();
        }

        private JST.Expression SimpleToFullNameExpression(Seq<JST.Statement> body)
        {
            var objId = nameSupply.GenSym();
            body.Add(JST.Statement.Var(objId, new JST.ObjectLiteral()));

            foreach (var methodDef in parent.Methods)
            {
                var name = MethodName(methodDef, false);
                if (name != null)
                    body.Add
                        (JST.Statement.DotCall
                             (rootId.ToE(),
                              Constants.RootSetUnique,
                              objId.ToE(),
                              new JST.StringLiteral(methodDef.Name),
                              name));
            }

            foreach (var fieldDef in parent.Fields)
            {
                var name = FieldName(fieldDef);
                if (name != null)
                    body.Add
                        (JST.Statement.DotCall
                             (rootId.ToE(),
                              Constants.RootSetUnique,
                              objId.ToE(),
                              new JST.StringLiteral(fieldDef.Name),
                              name));
            }

            foreach (var eventDef in parent.Events)
            {
                var name = EventName(eventDef);
                if (name != null)
                    body.Add
                        (JST.Statement.DotCall
                             (rootId.ToE(),
                              Constants.RootSetUnique,
                              objId.ToE(),
                              new JST.StringLiteral(eventDef.Name),
                              name));
                break;
            }

            foreach (var propDef in parent.Properties)
            {
                // This is the only place we care about properties
                var name = PropertyName(propDef);
                body.Add
                    (JST.Statement.DotCall
                         (rootId.ToE(),
                          Constants.RootSetUnique,
                          objId.ToE(),
                          new JST.StringLiteral(propDef.Name),
                          name));
            }

            return objId.ToE();
        }

        private JST.Expression SlotToInfoExpression(Seq<JST.Statement> body)
        {
            var objId = nameSupply.GenSym();
            body.Add(JST.Statement.Var(objId, new JST.ObjectLiteral()));

            foreach (var methodDef in parent.Methods)
            {
                if (methodDef.TypeArity == 0)
                {
                    var actMethodRef = methodDef.IsOverriding
                                           ? // Use info for overridden method
                                       typeCompEnv.Type.OverriddenMethod(methodDef.MethodSignature)
                                           : new CST.PolymorphicMethodRef
                                                 (typeCompEnv.TypeRef, methodDef.MethodSignature);
                    var slotExp = env.JSTHelpers.MethodSlotName(typeCompEnv, actMethodRef, false);
                    var info = new OrdMap<JST.Identifier, JST.Expression>();
                    info.Add(Constants.SlotInfoIsVirtual, new JST.BooleanLiteral(methodDef.IsVirtualOrAbstract));
                    info.Add
                        (Constants.SlotInfoArgTypes,
                         new JST.ArrayLiteral
                             (methodDef.ValueParameters.Select(p => typeCompEnv.ResolveType(p.Type, TypePhase.Id)).
                                  ToSeq()));
                    if (methodDef.Result == null)
                        info.Add(Constants.SlotInfoResultType, JST.Identifier.Undefined.ToE());
                    else
                        info.Add
                            (Constants.SlotInfoResultType,
                             typeCompEnv.ResolveType(methodDef.Result.Type, TypePhase.Id));
                    info.Add
                        (Constants.SlotInfoCustomAttributes,
                         CustomAttributesExpression
                             (body,
                              CST.MessageContextBuilders.Member
                                  (env.Global, typeCompEnv.Assembly, typeCompEnv.Type, methodDef),
                              methodDef.CustomAttributes));
                    body.Add(JST.Statement.IndexAssignment(objId.ToE(), slotExp, new JST.ObjectLiteral(info)));
                }
                // else: TODO: Polymorphic methods
            }

            foreach (var fieldDef in parent.Fields)
            {
                var slot = env.GlobalMapping.ResolveFieldDefToSlot(typeCompEnv.Assembly, typeCompEnv.Type, fieldDef);
                var info = new OrdMap<JST.Identifier, JST.Expression>();
                info.Add(Constants.SlotInfoResultType, typeCompEnv.ResolveType(fieldDef.FieldType, TypePhase.Id));
                info.Add
                    (Constants.SlotInfoCustomAttributes,
                     CustomAttributesExpression
                         (body,
                          CST.MessageContextBuilders.Member
                              (env.Global, typeCompEnv.Assembly, typeCompEnv.Type, fieldDef),
                          fieldDef.CustomAttributes));
                body.Add
                    (JST.Statement.IndexAssignment
                         (objId.ToE(),
                          new JST.StringLiteral
                              (fieldDef.IsStatic
                                   ? Constants.TypeStaticFieldSlot(slot)
                                   : Constants.ObjectInstanceFieldSlot(slot)),
                          new JST.ObjectLiteral(info)));
            }

            foreach (var eventDef in parent.Events)
            {
                var slot = env.GlobalMapping.ResolveEventDefToSlot(typeCompEnv.Assembly, typeCompEnv.Type, eventDef);
                var info = new OrdMap<JST.Identifier, JST.Expression>();
                info.Add(Constants.SlotInfoResultType, typeCompEnv.ResolveType(eventDef.HandlerType, TypePhase.Id));
                info.Add
                    (Constants.SlotInfoCustomAttributes,
                     CustomAttributesExpression
                         (body,
                          CST.MessageContextBuilders.Member
                              (env.Global, typeCompEnv.Assembly, typeCompEnv.Type, eventDef),
                          eventDef.CustomAttributes));
                body.Add
                    (JST.Statement.IndexAssignment
                         (objId.ToE(),
                          new JST.StringLiteral(Constants.ObjectEventSlot(slot)),
                          new JST.ObjectLiteral(info)));
            }

            foreach (var propDef in parent.Properties)
            {
                var slot = env.GlobalMapping.ResolvePropertyDefToSlot(typeCompEnv.Assembly, typeCompEnv.Type, propDef);
                var info = new OrdMap<JST.Identifier, JST.Expression>();
                info.Add(Constants.SlotInfoResultType, typeCompEnv.ResolveType(propDef.FieldType, TypePhase.Id));
                info.Add
                    (Constants.SlotInfoCustomAttributes,
                     CustomAttributesExpression
                         (body,
                          CST.MessageContextBuilders.Member
                              (env.Global, typeCompEnv.Assembly, typeCompEnv.Type, propDef),
                          propDef.CustomAttributes));
                body.Add
                    (JST.Statement.IndexAssignment
                         (objId.ToE(),
                          new JST.StringLiteral(Constants.ObjectPropertySlot(slot)),
                          new JST.ObjectLiteral(info)));
            }

            return objId.ToE();
        }


        // The string representing method name (including argument types etc)
        private JST.Expression MethodName(CST.MethodDef methodDef, bool withoutReturnType)
        {
            if (typeCompEnv.Type.Arity + methodDef.TypeArity == 0)
            {
                var sig = methodDef.MethodSignature;
                if (withoutReturnType)
                    sig = (CST.MethodSignature)sig.WithoutResult();
                var nm = CST.CSTWriter.WithAppend(env.Global, CST.WriterStyle.Uniform, sig.Append);
                // Name of monomorphic method of first-kinded type can be represented as a literal
                return new JST.StringLiteral(nm);
            }
            else if (methodDef.TypeArity == 0)
            {
                // Name of monomorphic method of higher-kinded type must be constructed at run-time
                var argTypesExp =
                    methodDef.ValueParameters.Select(p => typeCompEnv.ResolveType(p.Type, TypePhase.Id)).ToSeq();
                var resTypeExp = default(JST.Expression);
                if (withoutReturnType || methodDef.Result == null)
                    resTypeExp = new JST.NullExpression();
                else
                    resTypeExp = typeCompEnv.ResolveType(methodDef.Result.Type, TypePhase.Id);
                return JST.Expression.DotCall
                    (rootId.ToE(),
                     Constants.RootMethodName,
                     new JST.BooleanLiteral(env.InteropManager.IsStatic(typeCompEnv.Assembly, typeCompEnv.Type, methodDef)),
                     new JST.StringLiteral(methodDef.Name),
                     new JST.ArrayLiteral(argTypesExp),
                     resTypeExp);
            }
            else
            {
                // TODO: Polymorphic method names
                return null;
            }
        }

        private JST.Expression FieldName(CST.FieldDef fieldDef)
        {
            return new JST.StringLiteral(CST.CSTWriter.WithAppend(env.Global, CST.WriterStyle.Uniform, fieldDef.Signature.Append));
        }

        private JST.Expression EventName(CST.EventDef eventDef)
        {
            return new JST.StringLiteral(CST.CSTWriter.WithAppend(env.Global, CST.WriterStyle.Uniform, eventDef.Signature.Append));
        }

        private JST.Expression PropertyName(CST.PropertyDef propDef)
        {
            return new JST.StringLiteral(CST.CSTWriter.WithAppend(env.Global, CST.WriterStyle.Uniform, propDef.Signature.Append));
        }



    // #########################
    //     NameToSlot : string |-> string             -- Map each field and method name (possibly with free type
    //                                                -- variables) to corresponding slot name. Events and properties
    //                                                -- have no slots.
    //     PartialToFullName : string |-> string      -- Map each field and method name (possibly with free type
    //                                                -- variables) with field or return type forced to be void to
    //                                                -- actual field or method name.
    //     SimpleToFullName : string |-> string       -- Map each simple member name (including events and properties)
    //                                                -- to the corresponding actual member name (possibly with free
    //                                                -- type variables), or null if multiple members share the
    //                                                -- same simple name.
    //     SlotToInfo : string |-> <slot info structure>
    //                                                -- Map each method and field slot to its info structure
    // ########################


    // ----------------------------------------------------------------------
    // Reflection helpers
    // ----------------------------------------------------------------------

    root.EnumFields = function EnumFields(declType) {
        root.PrepareTypeForReflection(declType);
        var res = [];
        for (var fieldName in declType.SimpleToFullName) {
            var fullName = declType.SimpleToFullName[fieldName];
            if (fullName.indexOf("field ") == 0) {
                var slot = declType.NameToSlot[fullName];
                var val = declType[slot];
                if (val != null)
                    res.push(fieldName, val.toString());
                // else: is the phantom 'value__' instance field rather than a static field
            }
        }
        return res;
    };


            // Initialize will be defined only on assemblies which have not been initialized yet
            var f = defType.Z.Initialize;
            if (f != null) {
                defType.Z.Initialize = null;
                f();
            }

